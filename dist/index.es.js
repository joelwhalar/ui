import * as kt from "react";
import qi, { useRef as ga, useDebugValue as pD, createElement as sM, useContext as ar, forwardRef as zw, createContext as Ks, useLayoutEffect as lM, useEffect as Qi, useState as jf, useMemo as Ki, useCallback as Zp, useInsertionEffect as uM, useId as Pw, cloneElement as a4, Children as i4, isValidElement as o4, memo as s4, useSyncExternalStore as l4 } from "react";
var ub = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function cM(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var XE = { exports: {} }, Tv = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hD;
function u4() {
  if (hD)
    return Tv;
  hD = 1;
  var n = qi, a = Symbol.for("react.element"), s = Symbol.for("react.fragment"), c = Object.prototype.hasOwnProperty, p = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, v = { key: !0, ref: !0, __self: !0, __source: !0 };
  function h(b, x, E) {
    var w, k = {}, _ = null, A = null;
    E !== void 0 && (_ = "" + E), x.key !== void 0 && (_ = "" + x.key), x.ref !== void 0 && (A = x.ref);
    for (w in x)
      c.call(x, w) && !v.hasOwnProperty(w) && (k[w] = x[w]);
    if (b && b.defaultProps)
      for (w in x = b.defaultProps, x)
        k[w] === void 0 && (k[w] = x[w]);
    return { $$typeof: a, type: b, key: _, ref: A, props: k, _owner: p.current };
  }
  return Tv.Fragment = s, Tv.jsx = h, Tv.jsxs = h, Tv;
}
var kv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mD;
function c4() {
  return mD || (mD = 1, process.env.NODE_ENV !== "production" && function() {
    var n = qi, a = Symbol.for("react.element"), s = Symbol.for("react.portal"), c = Symbol.for("react.fragment"), p = Symbol.for("react.strict_mode"), v = Symbol.for("react.profiler"), h = Symbol.for("react.provider"), b = Symbol.for("react.context"), x = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), w = Symbol.for("react.suspense_list"), k = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), A = Symbol.for("react.offscreen"), L = Symbol.iterator, $ = "@@iterator";
    function Y(P) {
      if (P === null || typeof P != "object")
        return null;
      var ce = L && P[L] || P[$];
      return typeof ce == "function" ? ce : null;
    }
    var K = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function W(P) {
      {
        for (var ce = arguments.length, be = new Array(ce > 1 ? ce - 1 : 0), He = 1; He < ce; He++)
          be[He - 1] = arguments[He];
        F("error", P, be);
      }
    }
    function F(P, ce, be) {
      {
        var He = K.ReactDebugCurrentFrame, ct = He.getStackAddendum();
        ct !== "" && (ce += "%s", be = be.concat([ct]));
        var gt = be.map(function(ft) {
          return String(ft);
        });
        gt.unshift("Warning: " + ce), Function.prototype.apply.call(console[P], console, gt);
      }
    }
    var ne = !1, H = !1, le = !1, re = !1, De = !1, Fe;
    Fe = Symbol.for("react.module.reference");
    function ot(P) {
      return !!(typeof P == "string" || typeof P == "function" || P === c || P === v || De || P === p || P === E || P === w || re || P === A || ne || H || le || typeof P == "object" && P !== null && (P.$$typeof === _ || P.$$typeof === k || P.$$typeof === h || P.$$typeof === b || P.$$typeof === x || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      P.$$typeof === Fe || P.getModuleId !== void 0));
    }
    function vt(P, ce, be) {
      var He = P.displayName;
      if (He)
        return He;
      var ct = ce.displayName || ce.name || "";
      return ct !== "" ? be + "(" + ct + ")" : be;
    }
    function Rt(P) {
      return P.displayName || "Context";
    }
    function $e(P) {
      if (P == null)
        return null;
      if (typeof P.tag == "number" && W("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof P == "function")
        return P.displayName || P.name || null;
      if (typeof P == "string")
        return P;
      switch (P) {
        case c:
          return "Fragment";
        case s:
          return "Portal";
        case v:
          return "Profiler";
        case p:
          return "StrictMode";
        case E:
          return "Suspense";
        case w:
          return "SuspenseList";
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case b:
            var ce = P;
            return Rt(ce) + ".Consumer";
          case h:
            var be = P;
            return Rt(be._context) + ".Provider";
          case x:
            return vt(P, P.render, "ForwardRef");
          case k:
            var He = P.displayName || null;
            return He !== null ? He : $e(P.type) || "Memo";
          case _: {
            var ct = P, gt = ct._payload, ft = ct._init;
            try {
              return $e(ft(gt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Be = Object.assign, jt = 0, tt, Lt, he, Ce, ve, Ae, Ye;
    function Ke() {
    }
    Ke.__reactDisabledLog = !0;
    function cn() {
      {
        if (jt === 0) {
          tt = console.log, Lt = console.info, he = console.warn, Ce = console.error, ve = console.group, Ae = console.groupCollapsed, Ye = console.groupEnd;
          var P = {
            configurable: !0,
            enumerable: !0,
            value: Ke,
            writable: !0
          };
          Object.defineProperties(console, {
            info: P,
            log: P,
            warn: P,
            error: P,
            group: P,
            groupCollapsed: P,
            groupEnd: P
          });
        }
        jt++;
      }
    }
    function Vn() {
      {
        if (jt--, jt === 0) {
          var P = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Be({}, P, {
              value: tt
            }),
            info: Be({}, P, {
              value: Lt
            }),
            warn: Be({}, P, {
              value: he
            }),
            error: Be({}, P, {
              value: Ce
            }),
            group: Be({}, P, {
              value: ve
            }),
            groupCollapsed: Be({}, P, {
              value: Ae
            }),
            groupEnd: Be({}, P, {
              value: Ye
            })
          });
        }
        jt < 0 && W("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var bt = K.ReactCurrentDispatcher, yn;
    function Ot(P, ce, be) {
      {
        if (yn === void 0)
          try {
            throw Error();
          } catch (ct) {
            var He = ct.stack.trim().match(/\n( *(at )?)/);
            yn = He && He[1] || "";
          }
        return `
` + yn + P;
      }
    }
    var Bt = !1, gn;
    {
      var $t = typeof WeakMap == "function" ? WeakMap : Map;
      gn = new $t();
    }
    function ge(P, ce) {
      if (!P || Bt)
        return "";
      {
        var be = gn.get(P);
        if (be !== void 0)
          return be;
      }
      var He;
      Bt = !0;
      var ct = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var gt;
      gt = bt.current, bt.current = null, cn();
      try {
        if (ce) {
          var ft = function() {
            throw Error();
          };
          if (Object.defineProperty(ft.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ft, []);
            } catch (Et) {
              He = Et;
            }
            Reflect.construct(P, [], ft);
          } else {
            try {
              ft.call();
            } catch (Et) {
              He = Et;
            }
            P.call(ft.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Et) {
            He = Et;
          }
          P();
        }
      } catch (Et) {
        if (Et && He && typeof Et.stack == "string") {
          for (var Ge = Et.stack.split(`
`), Xn = He.stack.split(`
`), mn = Ge.length - 1, vn = Xn.length - 1; mn >= 1 && vn >= 0 && Ge[mn] !== Xn[vn]; )
            vn--;
          for (; mn >= 1 && vn >= 0; mn--, vn--)
            if (Ge[mn] !== Xn[vn]) {
              if (mn !== 1 || vn !== 1)
                do
                  if (mn--, vn--, vn < 0 || Ge[mn] !== Xn[vn]) {
                    var Rr = `
` + Ge[mn].replace(" at new ", " at ");
                    return P.displayName && Rr.includes("<anonymous>") && (Rr = Rr.replace("<anonymous>", P.displayName)), typeof P == "function" && gn.set(P, Rr), Rr;
                  }
                while (mn >= 1 && vn >= 0);
              break;
            }
        }
      } finally {
        Bt = !1, bt.current = gt, Vn(), Error.prepareStackTrace = ct;
      }
      var li = P ? P.displayName || P.name : "", nu = li ? Ot(li) : "";
      return typeof P == "function" && gn.set(P, nu), nu;
    }
    function kn(P, ce, be) {
      return ge(P, !1);
    }
    function Mn(P) {
      var ce = P.prototype;
      return !!(ce && ce.isReactComponent);
    }
    function jn(P, ce, be) {
      if (P == null)
        return "";
      if (typeof P == "function")
        return ge(P, Mn(P));
      if (typeof P == "string")
        return Ot(P);
      switch (P) {
        case E:
          return Ot("Suspense");
        case w:
          return Ot("SuspenseList");
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case x:
            return kn(P.render);
          case k:
            return jn(P.type, ce, be);
          case _: {
            var He = P, ct = He._payload, gt = He._init;
            try {
              return jn(gt(ct), ce, be);
            } catch {
            }
          }
        }
      return "";
    }
    var pr = Object.prototype.hasOwnProperty, hr = {}, ba = K.ReactDebugCurrentFrame;
    function Ua(P) {
      if (P) {
        var ce = P._owner, be = jn(P.type, P._source, ce ? ce.type : null);
        ba.setExtraStackFrame(be);
      } else
        ba.setExtraStackFrame(null);
    }
    function Sa(P, ce, be, He, ct) {
      {
        var gt = Function.call.bind(pr);
        for (var ft in P)
          if (gt(P, ft)) {
            var Ge = void 0;
            try {
              if (typeof P[ft] != "function") {
                var Xn = Error((He || "React class") + ": " + be + " type `" + ft + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof P[ft] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Xn.name = "Invariant Violation", Xn;
              }
              Ge = P[ft](ce, ft, He, be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (mn) {
              Ge = mn;
            }
            Ge && !(Ge instanceof Error) && (Ua(ct), W("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", He || "React class", be, ft, typeof Ge), Ua(null)), Ge instanceof Error && !(Ge.message in hr) && (hr[Ge.message] = !0, Ua(ct), W("Failed %s type: %s", be, Ge.message), Ua(null));
          }
      }
    }
    var xa = Array.isArray;
    function Br(P) {
      return xa(P);
    }
    function On(P) {
      {
        var ce = typeof Symbol == "function" && Symbol.toStringTag, be = ce && P[Symbol.toStringTag] || P.constructor.name || "Object";
        return be;
      }
    }
    function Ia(P) {
      try {
        return Ur(P), !1;
      } catch {
        return !0;
      }
    }
    function Ur(P) {
      return "" + P;
    }
    function Ha(P) {
      if (Ia(P))
        return W("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", On(P)), Ur(P);
    }
    var Bn = K.ReactCurrentOwner, mr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, zi, Ca, ye;
    ye = {};
    function Ue(P) {
      if (pr.call(P, "ref")) {
        var ce = Object.getOwnPropertyDescriptor(P, "ref").get;
        if (ce && ce.isReactWarning)
          return !1;
      }
      return P.ref !== void 0;
    }
    function ht(P) {
      if (pr.call(P, "key")) {
        var ce = Object.getOwnPropertyDescriptor(P, "key").get;
        if (ce && ce.isReactWarning)
          return !1;
      }
      return P.key !== void 0;
    }
    function Ut(P, ce) {
      if (typeof P.ref == "string" && Bn.current && ce && Bn.current.stateNode !== ce) {
        var be = $e(Bn.current.type);
        ye[be] || (W('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $e(Bn.current.type), P.ref), ye[be] = !0);
      }
    }
    function bn(P, ce) {
      {
        var be = function() {
          zi || (zi = !0, W("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ce));
        };
        be.isReactWarning = !0, Object.defineProperty(P, "key", {
          get: be,
          configurable: !0
        });
      }
    }
    function pn(P, ce) {
      {
        var be = function() {
          Ca || (Ca = !0, W("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ce));
        };
        be.isReactWarning = !0, Object.defineProperty(P, "ref", {
          get: be,
          configurable: !0
        });
      }
    }
    var hn = function(P, ce, be, He, ct, gt, ft) {
      var Ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: a,
        // Built-in properties that belong on the element
        type: P,
        key: ce,
        ref: be,
        props: ft,
        // Record the component responsible for creating this element.
        _owner: gt
      };
      return Ge._store = {}, Object.defineProperty(Ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: He
      }), Object.defineProperty(Ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ct
      }), Object.freeze && (Object.freeze(Ge.props), Object.freeze(Ge)), Ge;
    };
    function Ir(P, ce, be, He, ct) {
      {
        var gt, ft = {}, Ge = null, Xn = null;
        be !== void 0 && (Ha(be), Ge = "" + be), ht(ce) && (Ha(ce.key), Ge = "" + ce.key), Ue(ce) && (Xn = ce.ref, Ut(ce, ct));
        for (gt in ce)
          pr.call(ce, gt) && !mr.hasOwnProperty(gt) && (ft[gt] = ce[gt]);
        if (P && P.defaultProps) {
          var mn = P.defaultProps;
          for (gt in mn)
            ft[gt] === void 0 && (ft[gt] = mn[gt]);
        }
        if (Ge || Xn) {
          var vn = typeof P == "function" ? P.displayName || P.name || "Unknown" : P;
          Ge && bn(ft, vn), Xn && pn(ft, vn);
        }
        return hn(P, Ge, Xn, ct, He, Bn.current, ft);
      }
    }
    var Xt = K.ReactCurrentOwner, ta = K.ReactDebugCurrentFrame;
    function Gt(P) {
      if (P) {
        var ce = P._owner, be = jn(P.type, P._source, ce ? ce.type : null);
        ta.setExtraStackFrame(be);
      } else
        ta.setExtraStackFrame(null);
    }
    var Nt;
    Nt = !1;
    function ss(P) {
      return typeof P == "object" && P !== null && P.$$typeof === a;
    }
    function na() {
      {
        if (Xt.current) {
          var P = $e(Xt.current.type);
          if (P)
            return `

Check the render method of \`` + P + "`.";
        }
        return "";
      }
    }
    function ls(P) {
      {
        if (P !== void 0) {
          var ce = P.fileName.replace(/^.*[\\\/]/, ""), be = P.lineNumber;
          return `

Check your code at ` + ce + ":" + be + ".";
        }
        return "";
      }
    }
    var Xs = {};
    function tu(P) {
      {
        var ce = na();
        if (!ce) {
          var be = typeof P == "string" ? P : P.displayName || P.name;
          be && (ce = `

Check the top-level render call using <` + be + ">.");
        }
        return ce;
      }
    }
    function Co(P, ce) {
      {
        if (!P._store || P._store.validated || P.key != null)
          return;
        P._store.validated = !0;
        var be = tu(ce);
        if (Xs[be])
          return;
        Xs[be] = !0;
        var He = "";
        P && P._owner && P._owner !== Xt.current && (He = " It was passed a child from " + $e(P._owner.type) + "."), Gt(P), W('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', be, He), Gt(null);
      }
    }
    function us(P, ce) {
      {
        if (typeof P != "object")
          return;
        if (Br(P))
          for (var be = 0; be < P.length; be++) {
            var He = P[be];
            ss(He) && Co(He, ce);
          }
        else if (ss(P))
          P._store && (P._store.validated = !0);
        else if (P) {
          var ct = Y(P);
          if (typeof ct == "function" && ct !== P.entries)
            for (var gt = ct.call(P), ft; !(ft = gt.next()).done; )
              ss(ft.value) && Co(ft.value, ce);
        }
      }
    }
    function kr(P) {
      {
        var ce = P.type;
        if (ce == null || typeof ce == "string")
          return;
        var be;
        if (typeof ce == "function")
          be = ce.propTypes;
        else if (typeof ce == "object" && (ce.$$typeof === x || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ce.$$typeof === k))
          be = ce.propTypes;
        else
          return;
        if (be) {
          var He = $e(ce);
          Sa(be, P.props, "prop", He, P);
        } else if (ce.PropTypes !== void 0 && !Nt) {
          Nt = !0;
          var ct = $e(ce);
          W("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ct || "Unknown");
        }
        typeof ce.getDefaultProps == "function" && !ce.getDefaultProps.isReactClassApproved && W("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function cs(P) {
      {
        for (var ce = Object.keys(P.props), be = 0; be < ce.length; be++) {
          var He = ce[be];
          if (He !== "children" && He !== "key") {
            Gt(P), W("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", He), Gt(null);
            break;
          }
        }
        P.ref !== null && (Gt(P), W("Invalid attribute `ref` supplied to `React.Fragment`."), Gt(null));
      }
    }
    function si(P, ce, be, He, ct, gt) {
      {
        var ft = ot(P);
        if (!ft) {
          var Ge = "";
          (P === void 0 || typeof P == "object" && P !== null && Object.keys(P).length === 0) && (Ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Xn = ls(ct);
          Xn ? Ge += Xn : Ge += na();
          var mn;
          P === null ? mn = "null" : Br(P) ? mn = "array" : P !== void 0 && P.$$typeof === a ? (mn = "<" + ($e(P.type) || "Unknown") + " />", Ge = " Did you accidentally export a JSX literal instead of a component?") : mn = typeof P, W("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", mn, Ge);
        }
        var vn = Ir(P, ce, be, ct, gt);
        if (vn == null)
          return vn;
        if (ft) {
          var Rr = ce.children;
          if (Rr !== void 0)
            if (He)
              if (Br(Rr)) {
                for (var li = 0; li < Rr.length; li++)
                  us(Rr[li], P);
                Object.freeze && Object.freeze(Rr);
              } else
                W("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              us(Rr, P);
        }
        return P === c ? cs(vn) : kr(vn), vn;
      }
    }
    function Zi(P, ce, be) {
      return si(P, ce, be, !0);
    }
    function ra(P, ce, be) {
      return si(P, ce, be, !1);
    }
    var Wa = ra, aa = Zi;
    kv.Fragment = c, kv.jsx = Wa, kv.jsxs = aa;
  }()), kv;
}
process.env.NODE_ENV === "production" ? XE.exports = u4() : XE.exports = c4();
var Oe = XE.exports, Ai = function() {
  return Ai = Object.assign || function(a) {
    for (var s, c = 1, p = arguments.length; c < p; c++) {
      s = arguments[c];
      for (var v in s)
        Object.prototype.hasOwnProperty.call(s, v) && (a[v] = s[v]);
    }
    return a;
  }, Ai.apply(this, arguments);
};
function Jp(n, a, s) {
  if (s || arguments.length === 2)
    for (var c = 0, p = a.length, v; c < p; c++)
      (v || !(c in a)) && (v || (v = Array.prototype.slice.call(a, 0, c)), v[c] = a[c]);
  return n.concat(v || Array.prototype.slice.call(a));
}
function fM(n) {
  var a = /* @__PURE__ */ Object.create(null);
  return function(s) {
    return a[s] === void 0 && (a[s] = n(s)), a[s];
  };
}
var f4 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, dM = /* @__PURE__ */ fM(
  function(n) {
    return f4.test(n) || n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) < 91;
  }
  /* Z+1 */
), Nn = "-ms-", Bv = "-moz-", un = "-webkit-", pM = "comm", vS = "rule", Lw = "decl", d4 = "@import", hM = "@keyframes", p4 = "@layer", mM = Math.abs, $w = String.fromCharCode, ZE = Object.assign;
function h4(n, a) {
  return ea(n, 0) ^ 45 ? (((a << 2 ^ ea(n, 0)) << 2 ^ ea(n, 1)) << 2 ^ ea(n, 2)) << 2 ^ ea(n, 3) : 0;
}
function vM(n) {
  return n.trim();
}
function Wl(n, a) {
  return (n = a.exec(n)) ? n[0] : n;
}
function Ct(n, a, s) {
  return n.replace(a, s);
}
function Db(n, a, s) {
  return n.indexOf(a, s);
}
function ea(n, a) {
  return n.charCodeAt(a) | 0;
}
function eh(n, a, s) {
  return n.slice(a, s);
}
function Ws(n) {
  return n.length;
}
function yM(n) {
  return n.length;
}
function zv(n, a) {
  return a.push(n), n;
}
function m4(n, a) {
  return n.map(a).join("");
}
function vD(n, a) {
  return n.filter(function(s) {
    return !Wl(s, a);
  });
}
var yS = 1, th = 1, gM = 0, So = 0, wr = 0, fh = "";
function gS(n, a, s, c, p, v, h, b) {
  return { value: n, root: a, parent: s, type: c, props: p, children: v, line: yS, column: th, length: h, return: "", siblings: b };
}
function oc(n, a) {
  return ZE(gS("", null, null, "", null, null, 0, n.siblings), n, { length: -n.length }, a);
}
function Lp(n) {
  for (; n.root; )
    n = oc(n.root, { children: [n] });
  zv(n, n.siblings);
}
function v4() {
  return wr;
}
function y4() {
  return wr = So > 0 ? ea(fh, --So) : 0, th--, wr === 10 && (th = 1, yS--), wr;
}
function as() {
  return wr = So < gM ? ea(fh, So++) : 0, th++, wr === 10 && (th = 1, yS++), wr;
}
function Pf() {
  return ea(fh, So);
}
function Ab() {
  return So;
}
function bS(n, a) {
  return eh(fh, n, a);
}
function JE(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function g4(n) {
  return yS = th = 1, gM = Ws(fh = n), So = 0, [];
}
function b4(n) {
  return fh = "", n;
}
function pE(n) {
  return vM(bS(So - 1, ew(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function S4(n) {
  for (; (wr = Pf()) && wr < 33; )
    as();
  return JE(n) > 2 || JE(wr) > 3 ? "" : " ";
}
function x4(n, a) {
  for (; --a && as() && !(wr < 48 || wr > 102 || wr > 57 && wr < 65 || wr > 70 && wr < 97); )
    ;
  return bS(n, Ab() + (a < 6 && Pf() == 32 && as() == 32));
}
function ew(n) {
  for (; as(); )
    switch (wr) {
      case n:
        return So;
      case 34:
      case 39:
        n !== 34 && n !== 39 && ew(wr);
        break;
      case 40:
        n === 41 && ew(n);
        break;
      case 92:
        as();
        break;
    }
  return So;
}
function C4(n, a) {
  for (; as() && n + wr !== 57; )
    if (n + wr === 84 && Pf() === 47)
      break;
  return "/*" + bS(a, So - 1) + "*" + $w(n === 47 ? n : as());
}
function E4(n) {
  for (; !JE(Pf()); )
    as();
  return bS(n, So);
}
function w4(n) {
  return b4(Mb("", null, null, null, [""], n = g4(n), 0, [0], n));
}
function Mb(n, a, s, c, p, v, h, b, x) {
  for (var E = 0, w = 0, k = h, _ = 0, A = 0, L = 0, $ = 1, Y = 1, K = 1, W = 0, F = "", ne = p, H = v, le = c, re = F; Y; )
    switch (L = W, W = as()) {
      case 40:
        if (L != 108 && ea(re, k - 1) == 58) {
          Db(re += Ct(pE(W), "&", "&\f"), "&\f", mM(E ? b[E - 1] : 0)) != -1 && (K = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        re += pE(W);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        re += S4(L);
        break;
      case 92:
        re += x4(Ab() - 1, 7);
        continue;
      case 47:
        switch (Pf()) {
          case 42:
          case 47:
            zv(T4(C4(as(), Ab()), a, s, x), x);
            break;
          default:
            re += "/";
        }
        break;
      case 123 * $:
        b[E++] = Ws(re) * K;
      case 125 * $:
      case 59:
      case 0:
        switch (W) {
          case 0:
          case 125:
            Y = 0;
          case 59 + w:
            K == -1 && (re = Ct(re, /\f/g, "")), A > 0 && Ws(re) - k && zv(A > 32 ? gD(re + ";", c, s, k - 1, x) : gD(Ct(re, " ", "") + ";", c, s, k - 2, x), x);
            break;
          case 59:
            re += ";";
          default:
            if (zv(le = yD(re, a, s, E, w, p, b, F, ne = [], H = [], k, v), v), W === 123)
              if (w === 0)
                Mb(re, a, le, le, ne, v, k, b, H);
              else
                switch (_ === 99 && ea(re, 3) === 110 ? 100 : _) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Mb(n, le, le, c && zv(yD(n, le, le, 0, 0, p, b, F, p, ne = [], k, H), H), p, H, k, b, c ? ne : H);
                    break;
                  default:
                    Mb(re, le, le, le, [""], H, 0, b, H);
                }
        }
        E = w = A = 0, $ = K = 1, F = re = "", k = h;
        break;
      case 58:
        k = 1 + Ws(re), A = L;
      default:
        if ($ < 1) {
          if (W == 123)
            --$;
          else if (W == 125 && $++ == 0 && y4() == 125)
            continue;
        }
        switch (re += $w(W), W * $) {
          case 38:
            K = w > 0 ? 1 : (re += "\f", -1);
            break;
          case 44:
            b[E++] = (Ws(re) - 1) * K, K = 1;
            break;
          case 64:
            Pf() === 45 && (re += pE(as())), _ = Pf(), w = k = Ws(F = re += E4(Ab())), W++;
            break;
          case 45:
            L === 45 && Ws(re) == 2 && ($ = 0);
        }
    }
  return v;
}
function yD(n, a, s, c, p, v, h, b, x, E, w, k) {
  for (var _ = p - 1, A = p === 0 ? v : [""], L = yM(A), $ = 0, Y = 0, K = 0; $ < c; ++$)
    for (var W = 0, F = eh(n, _ + 1, _ = mM(Y = h[$])), ne = n; W < L; ++W)
      (ne = vM(Y > 0 ? A[W] + " " + F : Ct(F, /&\f/g, A[W]))) && (x[K++] = ne);
  return gS(n, a, s, p === 0 ? vS : b, x, E, w, k);
}
function T4(n, a, s, c) {
  return gS(n, a, s, pM, $w(v4()), eh(n, 2, -2), 0, c);
}
function gD(n, a, s, c, p) {
  return gS(n, a, s, Lw, eh(n, 0, c), eh(n, c + 1, -1), c, p);
}
function bM(n, a, s) {
  switch (h4(n, a)) {
    case 5103:
      return un + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return un + n + n;
    case 4789:
      return Bv + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return un + n + Bv + n + Nn + n + n;
    case 5936:
      switch (ea(n, a + 11)) {
        case 114:
          return un + n + Nn + Ct(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return un + n + Nn + Ct(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return un + n + Nn + Ct(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
    case 6828:
    case 4268:
    case 2903:
      return un + n + Nn + n + n;
    case 6165:
      return un + n + Nn + "flex-" + n + n;
    case 5187:
      return un + n + Ct(n, /(\w+).+(:[^]+)/, un + "box-$1$2" + Nn + "flex-$1$2") + n;
    case 5443:
      return un + n + Nn + "flex-item-" + Ct(n, /flex-|-self/g, "") + (Wl(n, /flex-|baseline/) ? "" : Nn + "grid-row-" + Ct(n, /flex-|-self/g, "")) + n;
    case 4675:
      return un + n + Nn + "flex-line-pack" + Ct(n, /align-content|flex-|-self/g, "") + n;
    case 5548:
      return un + n + Nn + Ct(n, "shrink", "negative") + n;
    case 5292:
      return un + n + Nn + Ct(n, "basis", "preferred-size") + n;
    case 6060:
      return un + "box-" + Ct(n, "-grow", "") + un + n + Nn + Ct(n, "grow", "positive") + n;
    case 4554:
      return un + Ct(n, /([^-])(transform)/g, "$1" + un + "$2") + n;
    case 6187:
      return Ct(Ct(Ct(n, /(zoom-|grab)/, un + "$1"), /(image-set)/, un + "$1"), n, "") + n;
    case 5495:
    case 3959:
      return Ct(n, /(image-set\([^]*)/, un + "$1$`$1");
    case 4968:
      return Ct(Ct(n, /(.+:)(flex-)?(.*)/, un + "box-pack:$3" + Nn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + un + n + n;
    case 4200:
      if (!Wl(n, /flex-|baseline/))
        return Nn + "grid-column-align" + eh(n, a) + n;
      break;
    case 2592:
    case 3360:
      return Nn + Ct(n, "template-", "") + n;
    case 4384:
    case 3616:
      return s && s.some(function(c, p) {
        return a = p, Wl(c.props, /grid-\w+-end/);
      }) ? ~Db(n + (s = s[a].value), "span", 0) ? n : Nn + Ct(n, "-start", "") + n + Nn + "grid-row-span:" + (~Db(s, "span", 0) ? Wl(s, /\d+/) : +Wl(s, /\d+/) - +Wl(n, /\d+/)) + ";" : Nn + Ct(n, "-start", "") + n;
    case 4896:
    case 4128:
      return s && s.some(function(c) {
        return Wl(c.props, /grid-\w+-start/);
      }) ? n : Nn + Ct(Ct(n, "-end", "-span"), "span ", "") + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Ct(n, /(.+)-inline(.+)/, un + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Ws(n) - 1 - a > 6)
        switch (ea(n, a + 1)) {
          case 109:
            if (ea(n, a + 4) !== 45)
              break;
          case 102:
            return Ct(n, /(.+:)(.+)-([^]+)/, "$1" + un + "$2-$3$1" + Bv + (ea(n, a + 3) == 108 ? "$3" : "$2-$3")) + n;
          case 115:
            return ~Db(n, "stretch", 0) ? bM(Ct(n, "stretch", "fill-available"), a, s) + n : n;
        }
      break;
    case 5152:
    case 5920:
      return Ct(n, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(c, p, v, h, b, x, E) {
        return Nn + p + ":" + v + E + (h ? Nn + p + "-span:" + (b ? x : +x - +v) + E : "") + n;
      });
    case 4949:
      if (ea(n, a + 6) === 121)
        return Ct(n, ":", ":" + un) + n;
      break;
    case 6444:
      switch (ea(n, ea(n, 14) === 45 ? 18 : 11)) {
        case 120:
          return Ct(n, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + un + (ea(n, 14) === 45 ? "inline-" : "") + "box$3$1" + un + "$2$3$1" + Nn + "$2box$3") + n;
        case 100:
          return Ct(n, ":", ":" + Nn) + n;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return Ct(n, "scroll-", "scroll-snap-") + n;
  }
  return n;
}
function Kb(n, a) {
  for (var s = "", c = 0; c < n.length; c++)
    s += a(n[c], c, n, a) || "";
  return s;
}
function k4(n, a, s, c) {
  switch (n.type) {
    case p4:
      if (n.children.length)
        break;
    case d4:
    case Lw:
      return n.return = n.return || n.value;
    case pM:
      return "";
    case hM:
      return n.return = n.value + "{" + Kb(n.children, c) + "}";
    case vS:
      if (!Ws(n.value = n.props.join(",")))
        return "";
  }
  return Ws(s = Kb(n.children, c)) ? n.return = n.value + "{" + s + "}" : "";
}
function R4(n) {
  var a = yM(n);
  return function(s, c, p, v) {
    for (var h = "", b = 0; b < a; b++)
      h += n[b](s, c, p, v) || "";
    return h;
  };
}
function _4(n) {
  return function(a) {
    a.root || (a = a.return) && n(a);
  };
}
function D4(n, a, s, c) {
  if (n.length > -1 && !n.return)
    switch (n.type) {
      case Lw:
        n.return = bM(n.value, n.length, s);
        return;
      case hM:
        return Kb([oc(n, { value: Ct(n.value, "@", "@" + un) })], c);
      case vS:
        if (n.length)
          return m4(s = n.props, function(p) {
            switch (Wl(p, c = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Lp(oc(n, { props: [Ct(p, /:(read-\w+)/, ":" + Bv + "$1")] })), Lp(oc(n, { props: [p] })), ZE(n, { props: vD(s, c) });
                break;
              case "::placeholder":
                Lp(oc(n, { props: [Ct(p, /:(plac\w+)/, ":" + un + "input-$1")] })), Lp(oc(n, { props: [Ct(p, /:(plac\w+)/, ":" + Bv + "$1")] })), Lp(oc(n, { props: [Ct(p, /:(plac\w+)/, Nn + "input-$1")] })), Lp(oc(n, { props: [p] })), ZE(n, { props: vD(s, c) });
                break;
            }
            return "";
          });
    }
}
var A4 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Bf = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", SM = "active", xM = "data-styled-version", SS = "6.1.8", Nw = `/*!sc*/
`, Fw = typeof window < "u" && "HTMLElement" in window, M4 = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : process.env.NODE_ENV !== "production"), bD = /invalid hook call/i, cb = /* @__PURE__ */ new Set(), O4 = function(n, a) {
  if (process.env.NODE_ENV !== "production") {
    var s = a ? ' with the id of "'.concat(a, '"') : "", c = "The component ".concat(n).concat(s, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, p = console.error;
    try {
      var v = !0;
      console.error = function(h) {
        for (var b = [], x = 1; x < arguments.length; x++)
          b[x - 1] = arguments[x];
        bD.test(h) ? (v = !1, cb.delete(c)) : p.apply(void 0, Jp([h], b, !1));
      }, ga(), v && !cb.has(c) && (console.warn(c), cb.add(c));
    } catch (h) {
      bD.test(h.message) && cb.delete(c);
    } finally {
      console.error = p;
    }
  }
}, xS = Object.freeze([]), nh = Object.freeze({});
function z4(n, a, s) {
  return s === void 0 && (s = nh), n.theme !== s.theme && n.theme || a || s.theme;
}
var tw = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), P4 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, L4 = /(^-|-$)/g;
function SD(n) {
  return n.replace(P4, "-").replace(L4, "");
}
var $4 = /(a)(d)/gi, fb = 52, xD = function(n) {
  return String.fromCharCode(n + (n > 25 ? 39 : 97));
};
function nw(n) {
  var a, s = "";
  for (a = Math.abs(n); a > fb; a = a / fb | 0)
    s = xD(a % fb) + s;
  return (xD(a % fb) + s).replace($4, "$1-$2");
}
var hE, CM = 5381, _f = function(n, a) {
  for (var s = a.length; s; )
    n = 33 * n ^ a.charCodeAt(--s);
  return n;
}, EM = function(n) {
  return _f(CM, n);
};
function N4(n) {
  return nw(EM(n) >>> 0);
}
function wM(n) {
  return process.env.NODE_ENV !== "production" && typeof n == "string" && n || n.displayName || n.name || "Component";
}
function mE(n) {
  return typeof n == "string" && (process.env.NODE_ENV === "production" || n.charAt(0) === n.charAt(0).toLowerCase());
}
var TM = typeof Symbol == "function" && Symbol.for, kM = TM ? Symbol.for("react.memo") : 60115, F4 = TM ? Symbol.for("react.forward_ref") : 60112, V4 = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, j4 = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, RM = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, B4 = ((hE = {})[F4] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, hE[kM] = RM, hE);
function CD(n) {
  return ("type" in (a = n) && a.type.$$typeof) === kM ? RM : "$$typeof" in n ? B4[n.$$typeof] : V4;
  var a;
}
var U4 = Object.defineProperty, I4 = Object.getOwnPropertyNames, ED = Object.getOwnPropertySymbols, H4 = Object.getOwnPropertyDescriptor, W4 = Object.getPrototypeOf, wD = Object.prototype;
function _M(n, a, s) {
  if (typeof a != "string") {
    if (wD) {
      var c = W4(a);
      c && c !== wD && _M(n, c, s);
    }
    var p = I4(a);
    ED && (p = p.concat(ED(a)));
    for (var v = CD(n), h = CD(a), b = 0; b < p.length; ++b) {
      var x = p[b];
      if (!(x in j4 || s && s[x] || h && x in h || v && x in v)) {
        var E = H4(a, x);
        try {
          U4(n, x, E);
        } catch {
        }
      }
    }
  }
  return n;
}
function rh(n) {
  return typeof n == "function";
}
function Vw(n) {
  return typeof n == "object" && "styledComponentId" in n;
}
function Mf(n, a) {
  return n && a ? "".concat(n, " ").concat(a) : n || a || "";
}
function TD(n, a) {
  if (n.length === 0)
    return "";
  for (var s = n[0], c = 1; c < n.length; c++)
    s += a ? a + n[c] : n[c];
  return s;
}
function ah(n) {
  return n !== null && typeof n == "object" && n.constructor.name === Object.name && !("props" in n && n.$$typeof);
}
function rw(n, a, s) {
  if (s === void 0 && (s = !1), !s && !ah(n) && !Array.isArray(n))
    return a;
  if (Array.isArray(a))
    for (var c = 0; c < a.length; c++)
      n[c] = rw(n[c], a[c]);
  else if (ah(a))
    for (var c in a)
      n[c] = rw(n[c], a[c]);
  return n;
}
function jw(n, a) {
  Object.defineProperty(n, "toString", { value: a });
}
var Y4 = process.env.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function G4() {
  for (var n = [], a = 0; a < arguments.length; a++)
    n[a] = arguments[a];
  for (var s = n[0], c = [], p = 1, v = n.length; p < v; p += 1)
    c.push(n[p]);
  return c.forEach(function(h) {
    s = s.replace(/%[a-z]/, h);
  }), s;
}
function dh(n) {
  for (var a = [], s = 1; s < arguments.length; s++)
    a[s - 1] = arguments[s];
  return process.env.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(n, " for more information.").concat(a.length > 0 ? " Args: ".concat(a.join(", ")) : "")) : new Error(G4.apply(void 0, Jp([Y4[n]], a, !1)).trim());
}
var q4 = function() {
  function n(a) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = a;
  }
  return n.prototype.indexOfGroup = function(a) {
    for (var s = 0, c = 0; c < a; c++)
      s += this.groupSizes[c];
    return s;
  }, n.prototype.insertRules = function(a, s) {
    if (a >= this.groupSizes.length) {
      for (var c = this.groupSizes, p = c.length, v = p; a >= v; )
        if ((v <<= 1) < 0)
          throw dh(16, "".concat(a));
      this.groupSizes = new Uint32Array(v), this.groupSizes.set(c), this.length = v;
      for (var h = p; h < v; h++)
        this.groupSizes[h] = 0;
    }
    for (var b = this.indexOfGroup(a + 1), x = (h = 0, s.length); h < x; h++)
      this.tag.insertRule(b, s[h]) && (this.groupSizes[a]++, b++);
  }, n.prototype.clearGroup = function(a) {
    if (a < this.length) {
      var s = this.groupSizes[a], c = this.indexOfGroup(a), p = c + s;
      this.groupSizes[a] = 0;
      for (var v = c; v < p; v++)
        this.tag.deleteRule(c);
    }
  }, n.prototype.getGroup = function(a) {
    var s = "";
    if (a >= this.length || this.groupSizes[a] === 0)
      return s;
    for (var c = this.groupSizes[a], p = this.indexOfGroup(a), v = p + c, h = p; h < v; h++)
      s += "".concat(this.tag.getRule(h)).concat(Nw);
    return s;
  }, n;
}(), Ob = /* @__PURE__ */ new Map(), Xb = /* @__PURE__ */ new Map(), zb = 1, db = function(n) {
  if (Ob.has(n))
    return Ob.get(n);
  for (; Xb.has(zb); )
    zb++;
  var a = zb++;
  if (process.env.NODE_ENV !== "production" && ((0 | a) < 0 || a > 1073741824))
    throw dh(16, "".concat(a));
  return Ob.set(n, a), Xb.set(a, n), a;
}, Q4 = function(n, a) {
  zb = a + 1, Ob.set(n, a), Xb.set(a, n);
}, K4 = "style[".concat(Bf, "][").concat(xM, '="').concat(SS, '"]'), X4 = new RegExp("^".concat(Bf, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Z4 = function(n, a, s) {
  for (var c, p = s.split(","), v = 0, h = p.length; v < h; v++)
    (c = p[v]) && n.registerName(a, c);
}, J4 = function(n, a) {
  for (var s, c = ((s = a.textContent) !== null && s !== void 0 ? s : "").split(Nw), p = [], v = 0, h = c.length; v < h; v++) {
    var b = c[v].trim();
    if (b) {
      var x = b.match(X4);
      if (x) {
        var E = 0 | parseInt(x[1], 10), w = x[2];
        E !== 0 && (Q4(w, E), Z4(n, w, x[3]), n.getTag().insertRules(E, p)), p.length = 0;
      } else
        p.push(b);
    }
  }
};
function eF() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var DM = function(n) {
  var a = document.head, s = n || a, c = document.createElement("style"), p = function(b) {
    var x = Array.from(b.querySelectorAll("style[".concat(Bf, "]")));
    return x[x.length - 1];
  }(s), v = p !== void 0 ? p.nextSibling : null;
  c.setAttribute(Bf, SM), c.setAttribute(xM, SS);
  var h = eF();
  return h && c.setAttribute("nonce", h), s.insertBefore(c, v), c;
}, tF = function() {
  function n(a) {
    this.element = DM(a), this.element.appendChild(document.createTextNode("")), this.sheet = function(s) {
      if (s.sheet)
        return s.sheet;
      for (var c = document.styleSheets, p = 0, v = c.length; p < v; p++) {
        var h = c[p];
        if (h.ownerNode === s)
          return h;
      }
      throw dh(17);
    }(this.element), this.length = 0;
  }
  return n.prototype.insertRule = function(a, s) {
    try {
      return this.sheet.insertRule(s, a), this.length++, !0;
    } catch {
      return !1;
    }
  }, n.prototype.deleteRule = function(a) {
    this.sheet.deleteRule(a), this.length--;
  }, n.prototype.getRule = function(a) {
    var s = this.sheet.cssRules[a];
    return s && s.cssText ? s.cssText : "";
  }, n;
}(), nF = function() {
  function n(a) {
    this.element = DM(a), this.nodes = this.element.childNodes, this.length = 0;
  }
  return n.prototype.insertRule = function(a, s) {
    if (a <= this.length && a >= 0) {
      var c = document.createTextNode(s);
      return this.element.insertBefore(c, this.nodes[a] || null), this.length++, !0;
    }
    return !1;
  }, n.prototype.deleteRule = function(a) {
    this.element.removeChild(this.nodes[a]), this.length--;
  }, n.prototype.getRule = function(a) {
    return a < this.length ? this.nodes[a].textContent : "";
  }, n;
}(), rF = function() {
  function n(a) {
    this.rules = [], this.length = 0;
  }
  return n.prototype.insertRule = function(a, s) {
    return a <= this.length && (this.rules.splice(a, 0, s), this.length++, !0);
  }, n.prototype.deleteRule = function(a) {
    this.rules.splice(a, 1), this.length--;
  }, n.prototype.getRule = function(a) {
    return a < this.length ? this.rules[a] : "";
  }, n;
}(), kD = Fw, aF = { isServer: !Fw, useCSSOMInjection: !M4 }, AM = function() {
  function n(a, s, c) {
    a === void 0 && (a = nh), s === void 0 && (s = {});
    var p = this;
    this.options = Ai(Ai({}, aF), a), this.gs = s, this.names = new Map(c), this.server = !!a.isServer, !this.server && Fw && kD && (kD = !1, function(v) {
      for (var h = document.querySelectorAll(K4), b = 0, x = h.length; b < x; b++) {
        var E = h[b];
        E && E.getAttribute(Bf) !== SM && (J4(v, E), E.parentNode && E.parentNode.removeChild(E));
      }
    }(this)), jw(this, function() {
      return function(v) {
        for (var h = v.getTag(), b = h.length, x = "", E = function(k) {
          var _ = function(K) {
            return Xb.get(K);
          }(k);
          if (_ === void 0)
            return "continue";
          var A = v.names.get(_), L = h.getGroup(k);
          if (A === void 0 || L.length === 0)
            return "continue";
          var $ = "".concat(Bf, ".g").concat(k, '[id="').concat(_, '"]'), Y = "";
          A !== void 0 && A.forEach(function(K) {
            K.length > 0 && (Y += "".concat(K, ","));
          }), x += "".concat(L).concat($, '{content:"').concat(Y, '"}').concat(Nw);
        }, w = 0; w < b; w++)
          E(w);
        return x;
      }(p);
    });
  }
  return n.registerId = function(a) {
    return db(a);
  }, n.prototype.reconstructWithOptions = function(a, s) {
    return s === void 0 && (s = !0), new n(Ai(Ai({}, this.options), a), this.gs, s && this.names || void 0);
  }, n.prototype.allocateGSInstance = function(a) {
    return this.gs[a] = (this.gs[a] || 0) + 1;
  }, n.prototype.getTag = function() {
    return this.tag || (this.tag = (a = function(s) {
      var c = s.useCSSOMInjection, p = s.target;
      return s.isServer ? new rF(p) : c ? new tF(p) : new nF(p);
    }(this.options), new q4(a)));
    var a;
  }, n.prototype.hasNameForId = function(a, s) {
    return this.names.has(a) && this.names.get(a).has(s);
  }, n.prototype.registerName = function(a, s) {
    if (db(a), this.names.has(a))
      this.names.get(a).add(s);
    else {
      var c = /* @__PURE__ */ new Set();
      c.add(s), this.names.set(a, c);
    }
  }, n.prototype.insertRules = function(a, s, c) {
    this.registerName(a, s), this.getTag().insertRules(db(a), c);
  }, n.prototype.clearNames = function(a) {
    this.names.has(a) && this.names.get(a).clear();
  }, n.prototype.clearRules = function(a) {
    this.getTag().clearGroup(db(a)), this.clearNames(a);
  }, n.prototype.clearTag = function() {
    this.tag = void 0;
  }, n;
}(), iF = /&/g, oF = /^\s*\/\/.*$/gm;
function MM(n, a) {
  return n.map(function(s) {
    return s.type === "rule" && (s.value = "".concat(a, " ").concat(s.value), s.value = s.value.replaceAll(",", ",".concat(a, " ")), s.props = s.props.map(function(c) {
      return "".concat(a, " ").concat(c);
    })), Array.isArray(s.children) && s.type !== "@keyframes" && (s.children = MM(s.children, a)), s;
  });
}
function sF(n) {
  var a, s, c, p = n === void 0 ? nh : n, v = p.options, h = v === void 0 ? nh : v, b = p.plugins, x = b === void 0 ? xS : b, E = function(_, A, L) {
    return L.startsWith(s) && L.endsWith(s) && L.replaceAll(s, "").length > 0 ? ".".concat(a) : _;
  }, w = x.slice();
  w.push(function(_) {
    _.type === vS && _.value.includes("&") && (_.props[0] = _.props[0].replace(iF, s).replace(c, E));
  }), h.prefix && w.push(D4), w.push(k4);
  var k = function(_, A, L, $) {
    A === void 0 && (A = ""), L === void 0 && (L = ""), $ === void 0 && ($ = "&"), a = $, s = A, c = new RegExp("\\".concat(s, "\\b"), "g");
    var Y = _.replace(oF, ""), K = w4(L || A ? "".concat(L, " ").concat(A, " { ").concat(Y, " }") : Y);
    h.namespace && (K = MM(K, h.namespace));
    var W = [];
    return Kb(K, R4(w.concat(_4(function(F) {
      return W.push(F);
    })))), W;
  };
  return k.hash = x.length ? x.reduce(function(_, A) {
    return A.name || dh(15), _f(_, A.name);
  }, CM).toString() : "", k;
}
var lF = new AM(), aw = sF(), OM = qi.createContext({ shouldForwardProp: void 0, styleSheet: lF, stylis: aw });
OM.Consumer;
qi.createContext(void 0);
function RD() {
  return ar(OM);
}
var _D = function() {
  function n(a, s) {
    var c = this;
    this.inject = function(p, v) {
      v === void 0 && (v = aw);
      var h = c.name + v.hash;
      p.hasNameForId(c.id, h) || p.insertRules(c.id, h, v(c.rules, h, "@keyframes"));
    }, this.name = a, this.id = "sc-keyframes-".concat(a), this.rules = s, jw(this, function() {
      throw dh(12, String(c.name));
    });
  }
  return n.prototype.getName = function(a) {
    return a === void 0 && (a = aw), this.name + a.hash;
  }, n;
}(), uF = function(n) {
  return n >= "A" && n <= "Z";
};
function DD(n) {
  for (var a = "", s = 0; s < n.length; s++) {
    var c = n[s];
    if (s === 1 && c === "-" && n[0] === "-")
      return n;
    uF(c) ? a += "-" + c.toLowerCase() : a += c;
  }
  return a.startsWith("ms-") ? "-" + a : a;
}
var zM = function(n) {
  return n == null || n === !1 || n === "";
}, PM = function(n) {
  var a, s, c = [];
  for (var p in n) {
    var v = n[p];
    n.hasOwnProperty(p) && !zM(v) && (Array.isArray(v) && v.isCss || rh(v) ? c.push("".concat(DD(p), ":"), v, ";") : ah(v) ? c.push.apply(c, Jp(Jp(["".concat(p, " {")], PM(v), !1), ["}"], !1)) : c.push("".concat(DD(p), ": ").concat((a = p, (s = v) == null || typeof s == "boolean" || s === "" ? "" : typeof s != "number" || s === 0 || a in A4 || a.startsWith("--") ? String(s).trim() : "".concat(s, "px")), ";")));
  }
  return c;
};
function Lf(n, a, s, c) {
  if (zM(n))
    return [];
  if (Vw(n))
    return [".".concat(n.styledComponentId)];
  if (rh(n)) {
    if (!rh(v = n) || v.prototype && v.prototype.isReactComponent || !a)
      return [n];
    var p = n(a);
    return process.env.NODE_ENV === "production" || typeof p != "object" || Array.isArray(p) || p instanceof _D || ah(p) || p === null || console.error("".concat(wM(n), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Lf(p, a, s, c);
  }
  var v;
  return n instanceof _D ? s ? (n.inject(s, c), [n.getName(c)]) : [n] : ah(n) ? PM(n) : Array.isArray(n) ? Array.prototype.concat.apply(xS, n.map(function(h) {
    return Lf(h, a, s, c);
  })) : [n.toString()];
}
function cF(n) {
  for (var a = 0; a < n.length; a += 1) {
    var s = n[a];
    if (rh(s) && !Vw(s))
      return !1;
  }
  return !0;
}
var fF = EM(SS), dF = function() {
  function n(a, s, c) {
    this.rules = a, this.staticRulesId = "", this.isStatic = process.env.NODE_ENV === "production" && (c === void 0 || c.isStatic) && cF(a), this.componentId = s, this.baseHash = _f(fF, s), this.baseStyle = c, AM.registerId(s);
  }
  return n.prototype.generateAndInjectStyles = function(a, s, c) {
    var p = this.baseStyle ? this.baseStyle.generateAndInjectStyles(a, s, c) : "";
    if (this.isStatic && !c.hash)
      if (this.staticRulesId && s.hasNameForId(this.componentId, this.staticRulesId))
        p = Mf(p, this.staticRulesId);
      else {
        var v = TD(Lf(this.rules, a, s, c)), h = nw(_f(this.baseHash, v) >>> 0);
        if (!s.hasNameForId(this.componentId, h)) {
          var b = c(v, ".".concat(h), void 0, this.componentId);
          s.insertRules(this.componentId, h, b);
        }
        p = Mf(p, h), this.staticRulesId = h;
      }
    else {
      for (var x = _f(this.baseHash, c.hash), E = "", w = 0; w < this.rules.length; w++) {
        var k = this.rules[w];
        if (typeof k == "string")
          E += k, process.env.NODE_ENV !== "production" && (x = _f(x, k));
        else if (k) {
          var _ = TD(Lf(k, a, s, c));
          x = _f(x, _ + w), E += _;
        }
      }
      if (E) {
        var A = nw(x >>> 0);
        s.hasNameForId(this.componentId, A) || s.insertRules(this.componentId, A, c(E, ".".concat(A), void 0, this.componentId)), p = Mf(p, A);
      }
    }
    return p;
  }, n;
}(), LM = qi.createContext(void 0);
LM.Consumer;
var vE = {}, AD = /* @__PURE__ */ new Set();
function pF(n, a, s) {
  var c = Vw(n), p = n, v = !mE(n), h = a.attrs, b = h === void 0 ? xS : h, x = a.componentId, E = x === void 0 ? function(ne, H) {
    var le = typeof ne != "string" ? "sc" : SD(ne);
    vE[le] = (vE[le] || 0) + 1;
    var re = "".concat(le, "-").concat(N4(SS + le + vE[le]));
    return H ? "".concat(H, "-").concat(re) : re;
  }(a.displayName, a.parentComponentId) : x, w = a.displayName, k = w === void 0 ? function(ne) {
    return mE(ne) ? "styled.".concat(ne) : "Styled(".concat(wM(ne), ")");
  }(n) : w, _ = a.displayName && a.componentId ? "".concat(SD(a.displayName), "-").concat(a.componentId) : a.componentId || E, A = c && p.attrs ? p.attrs.concat(b).filter(Boolean) : b, L = a.shouldForwardProp;
  if (c && p.shouldForwardProp) {
    var $ = p.shouldForwardProp;
    if (a.shouldForwardProp) {
      var Y = a.shouldForwardProp;
      L = function(ne, H) {
        return $(ne, H) && Y(ne, H);
      };
    } else
      L = $;
  }
  var K = new dF(s, _, c ? p.componentStyle : void 0);
  function W(ne, H) {
    return function(le, re, De) {
      var Fe = le.attrs, ot = le.componentStyle, vt = le.defaultProps, Rt = le.foldedComponentIds, $e = le.styledComponentId, Be = le.target, jt = qi.useContext(LM), tt = RD(), Lt = le.shouldForwardProp || tt.shouldForwardProp;
      process.env.NODE_ENV !== "production" && pD($e);
      var he = z4(re, jt, vt) || nh, Ce = function(Vn, bt, yn) {
        for (var Ot, Bt = Ai(Ai({}, bt), { className: void 0, theme: yn }), gn = 0; gn < Vn.length; gn += 1) {
          var $t = rh(Ot = Vn[gn]) ? Ot(Bt) : Ot;
          for (var ge in $t)
            Bt[ge] = ge === "className" ? Mf(Bt[ge], $t[ge]) : ge === "style" ? Ai(Ai({}, Bt[ge]), $t[ge]) : $t[ge];
        }
        return bt.className && (Bt.className = Mf(Bt.className, bt.className)), Bt;
      }(Fe, re, he), ve = Ce.as || Be, Ae = {};
      for (var Ye in Ce)
        Ce[Ye] === void 0 || Ye[0] === "$" || Ye === "as" || Ye === "theme" && Ce.theme === he || (Ye === "forwardedAs" ? Ae.as = Ce.forwardedAs : Lt && !Lt(Ye, ve) || (Ae[Ye] = Ce[Ye], Lt || process.env.NODE_ENV !== "development" || dM(Ye) || AD.has(Ye) || !tw.has(ve) || (AD.add(Ye), console.warn('styled-components: it looks like an unknown prop "'.concat(Ye, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var Ke = function(Vn, bt) {
        var yn = RD(), Ot = Vn.generateAndInjectStyles(bt, yn.styleSheet, yn.stylis);
        return process.env.NODE_ENV !== "production" && pD(Ot), Ot;
      }(ot, Ce);
      process.env.NODE_ENV !== "production" && le.warnTooManyClasses && le.warnTooManyClasses(Ke);
      var cn = Mf(Rt, $e);
      return Ke && (cn += " " + Ke), Ce.className && (cn += " " + Ce.className), Ae[mE(ve) && !tw.has(ve) ? "class" : "className"] = cn, Ae.ref = De, sM(ve, Ae);
    }(F, ne, H);
  }
  W.displayName = k;
  var F = qi.forwardRef(W);
  return F.attrs = A, F.componentStyle = K, F.displayName = k, F.shouldForwardProp = L, F.foldedComponentIds = c ? Mf(p.foldedComponentIds, p.styledComponentId) : "", F.styledComponentId = _, F.target = c ? p.target : n, Object.defineProperty(F, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(ne) {
    this._foldedDefaultProps = c ? function(H) {
      for (var le = [], re = 1; re < arguments.length; re++)
        le[re - 1] = arguments[re];
      for (var De = 0, Fe = le; De < Fe.length; De++)
        rw(H, Fe[De], !0);
      return H;
    }({}, p.defaultProps, ne) : ne;
  } }), process.env.NODE_ENV !== "production" && (O4(k, _), F.warnTooManyClasses = /* @__PURE__ */ function(ne, H) {
    var le = {}, re = !1;
    return function(De) {
      if (!re && (le[De] = !0, Object.keys(le).length >= 200)) {
        var Fe = H ? ' with the id of "'.concat(H, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(ne).concat(Fe, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), re = !0, le = {};
      }
    };
  }(k, _)), jw(F, function() {
    return ".".concat(F.styledComponentId);
  }), v && _M(F, n, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), F;
}
function MD(n, a) {
  for (var s = [n[0]], c = 0, p = a.length; c < p; c += 1)
    s.push(a[c], n[c + 1]);
  return s;
}
var OD = function(n) {
  return Object.assign(n, { isCss: !0 });
};
function hF(n) {
  for (var a = [], s = 1; s < arguments.length; s++)
    a[s - 1] = arguments[s];
  if (rh(n) || ah(n))
    return OD(Lf(MD(xS, Jp([n], a, !0))));
  var c = n;
  return a.length === 0 && c.length === 1 && typeof c[0] == "string" ? Lf(c) : OD(Lf(MD(c, a)));
}
function iw(n, a, s) {
  if (s === void 0 && (s = nh), !a)
    throw dh(1, a);
  var c = function(p) {
    for (var v = [], h = 1; h < arguments.length; h++)
      v[h - 1] = arguments[h];
    return n(a, s, hF.apply(void 0, Jp([p], v, !1)));
  };
  return c.attrs = function(p) {
    return iw(n, a, Ai(Ai({}, s), { attrs: Array.prototype.concat(s.attrs, p).filter(Boolean) }));
  }, c.withConfig = function(p) {
    return iw(n, a, Ai(Ai({}, s), p));
  }, c;
}
var $M = function(n) {
  return iw(pF, n);
}, NM = $M;
tw.forEach(function(n) {
  NM[n] = $M(n);
});
process.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var pb = "__sc-".concat(Bf, "__");
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && typeof window < "u" && (window[pb] || (window[pb] = 0), window[pb] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[pb] += 1);
const mF = NM.button`
  border: 0;
  line-height: 1;
  font-size: 15px;
  cursor: pointer;
  font-weight: 700;
  font-weight: bold;
  border-radius: 10px;
  display: inline-block;
  color: ${(n) => n.primary ? "#fff" : "#000"};
  background-color: ${(n) => n.primary ? "#FF5655" : "#f4c4c4"};
  padding: ${(n) => n.size === "small" ? "7px 25px 8px" : n.size === "medium" ? "9px 30px 11px" : "14px 30px 16px"};
`, aQ = ({
  size: n,
  primary: a,
  disabled: s,
  text: c,
  onClick: p,
  ...v
}) => /* @__PURE__ */ Oe.jsx(
  mF,
  {
    type: "button",
    onClick: p,
    primary: a,
    disabled: s,
    size: n,
    ...v,
    children: c
  }
);
function vF(n) {
  if (n.sheet)
    return n.sheet;
  for (var a = 0; a < document.styleSheets.length; a++)
    if (document.styleSheets[a].ownerNode === n)
      return document.styleSheets[a];
}
function yF(n) {
  var a = document.createElement("style");
  return a.setAttribute("data-emotion", n.key), n.nonce !== void 0 && a.setAttribute("nonce", n.nonce), a.appendChild(document.createTextNode("")), a.setAttribute("data-s", ""), a;
}
var gF = /* @__PURE__ */ function() {
  function n(s) {
    var c = this;
    this._insertTag = function(p) {
      var v;
      c.tags.length === 0 ? c.insertionPoint ? v = c.insertionPoint.nextSibling : c.prepend ? v = c.container.firstChild : v = c.before : v = c.tags[c.tags.length - 1].nextSibling, c.container.insertBefore(p, v), c.tags.push(p);
    }, this.isSpeedy = s.speedy === void 0 ? process.env.NODE_ENV === "production" : s.speedy, this.tags = [], this.ctr = 0, this.nonce = s.nonce, this.key = s.key, this.container = s.container, this.prepend = s.prepend, this.insertionPoint = s.insertionPoint, this.before = null;
  }
  var a = n.prototype;
  return a.hydrate = function(c) {
    c.forEach(this._insertTag);
  }, a.insert = function(c) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(yF(this));
    var p = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var v = c.charCodeAt(0) === 64 && c.charCodeAt(1) === 105;
      v && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + c + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !v;
    }
    if (this.isSpeedy) {
      var h = vF(p);
      try {
        h.insertRule(c, h.cssRules.length);
      } catch (b) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(c) && console.error('There was a problem inserting the following rule: "' + c + '"', b);
      }
    } else
      p.appendChild(document.createTextNode(c));
    this.ctr++;
  }, a.flush = function() {
    this.tags.forEach(function(c) {
      return c.parentNode && c.parentNode.removeChild(c);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, n;
}(), Ba = "-ms-", Zb = "-moz-", en = "-webkit-", Bw = "comm", Uw = "rule", Iw = "decl", bF = "@import", FM = "@keyframes", SF = "@layer", xF = Math.abs, CS = String.fromCharCode, CF = Object.assign;
function EF(n, a) {
  return ya(n, 0) ^ 45 ? (((a << 2 ^ ya(n, 0)) << 2 ^ ya(n, 1)) << 2 ^ ya(n, 2)) << 2 ^ ya(n, 3) : 0;
}
function VM(n) {
  return n.trim();
}
function wF(n, a) {
  return (n = a.exec(n)) ? n[0] : n;
}
function tn(n, a, s) {
  return n.replace(a, s);
}
function ow(n, a) {
  return n.indexOf(a);
}
function ya(n, a) {
  return n.charCodeAt(a) | 0;
}
function Jv(n, a, s) {
  return n.slice(a, s);
}
function Ys(n) {
  return n.length;
}
function Hw(n) {
  return n.length;
}
function hb(n, a) {
  return a.push(n), n;
}
function TF(n, a) {
  return n.map(a).join("");
}
var ES = 1, ih = 1, jM = 0, Mi = 0, Tr = 0, ph = "";
function wS(n, a, s, c, p, v, h) {
  return { value: n, root: a, parent: s, type: c, props: p, children: v, line: ES, column: ih, length: h, return: "" };
}
function Rv(n, a) {
  return CF(wS("", null, null, "", null, null, 0), n, { length: -n.length }, a);
}
function kF() {
  return Tr;
}
function RF() {
  return Tr = Mi > 0 ? ya(ph, --Mi) : 0, ih--, Tr === 10 && (ih = 1, ES--), Tr;
}
function Yi() {
  return Tr = Mi < jM ? ya(ph, Mi++) : 0, ih++, Tr === 10 && (ih = 1, ES++), Tr;
}
function Gs() {
  return ya(ph, Mi);
}
function Pb() {
  return Mi;
}
function uy(n, a) {
  return Jv(ph, n, a);
}
function ey(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function BM(n) {
  return ES = ih = 1, jM = Ys(ph = n), Mi = 0, [];
}
function UM(n) {
  return ph = "", n;
}
function Lb(n) {
  return VM(uy(Mi - 1, sw(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function _F(n) {
  for (; (Tr = Gs()) && Tr < 33; )
    Yi();
  return ey(n) > 2 || ey(Tr) > 3 ? "" : " ";
}
function DF(n, a) {
  for (; --a && Yi() && !(Tr < 48 || Tr > 102 || Tr > 57 && Tr < 65 || Tr > 70 && Tr < 97); )
    ;
  return uy(n, Pb() + (a < 6 && Gs() == 32 && Yi() == 32));
}
function sw(n) {
  for (; Yi(); )
    switch (Tr) {
      case n:
        return Mi;
      case 34:
      case 39:
        n !== 34 && n !== 39 && sw(Tr);
        break;
      case 40:
        n === 41 && sw(n);
        break;
      case 92:
        Yi();
        break;
    }
  return Mi;
}
function AF(n, a) {
  for (; Yi() && n + Tr !== 57; )
    if (n + Tr === 84 && Gs() === 47)
      break;
  return "/*" + uy(a, Mi - 1) + "*" + CS(n === 47 ? n : Yi());
}
function MF(n) {
  for (; !ey(Gs()); )
    Yi();
  return uy(n, Mi);
}
function OF(n) {
  return UM($b("", null, null, null, [""], n = BM(n), 0, [0], n));
}
function $b(n, a, s, c, p, v, h, b, x) {
  for (var E = 0, w = 0, k = h, _ = 0, A = 0, L = 0, $ = 1, Y = 1, K = 1, W = 0, F = "", ne = p, H = v, le = c, re = F; Y; )
    switch (L = W, W = Yi()) {
      case 40:
        if (L != 108 && ya(re, k - 1) == 58) {
          ow(re += tn(Lb(W), "&", "&\f"), "&\f") != -1 && (K = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        re += Lb(W);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        re += _F(L);
        break;
      case 92:
        re += DF(Pb() - 1, 7);
        continue;
      case 47:
        switch (Gs()) {
          case 42:
          case 47:
            hb(zF(AF(Yi(), Pb()), a, s), x);
            break;
          default:
            re += "/";
        }
        break;
      case 123 * $:
        b[E++] = Ys(re) * K;
      case 125 * $:
      case 59:
      case 0:
        switch (W) {
          case 0:
          case 125:
            Y = 0;
          case 59 + w:
            K == -1 && (re = tn(re, /\f/g, "")), A > 0 && Ys(re) - k && hb(A > 32 ? PD(re + ";", c, s, k - 1) : PD(tn(re, " ", "") + ";", c, s, k - 2), x);
            break;
          case 59:
            re += ";";
          default:
            if (hb(le = zD(re, a, s, E, w, p, b, F, ne = [], H = [], k), v), W === 123)
              if (w === 0)
                $b(re, a, le, le, ne, v, k, b, H);
              else
                switch (_ === 99 && ya(re, 3) === 110 ? 100 : _) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    $b(n, le, le, c && hb(zD(n, le, le, 0, 0, p, b, F, p, ne = [], k), H), p, H, k, b, c ? ne : H);
                    break;
                  default:
                    $b(re, le, le, le, [""], H, 0, b, H);
                }
        }
        E = w = A = 0, $ = K = 1, F = re = "", k = h;
        break;
      case 58:
        k = 1 + Ys(re), A = L;
      default:
        if ($ < 1) {
          if (W == 123)
            --$;
          else if (W == 125 && $++ == 0 && RF() == 125)
            continue;
        }
        switch (re += CS(W), W * $) {
          case 38:
            K = w > 0 ? 1 : (re += "\f", -1);
            break;
          case 44:
            b[E++] = (Ys(re) - 1) * K, K = 1;
            break;
          case 64:
            Gs() === 45 && (re += Lb(Yi())), _ = Gs(), w = k = Ys(F = re += MF(Pb())), W++;
            break;
          case 45:
            L === 45 && Ys(re) == 2 && ($ = 0);
        }
    }
  return v;
}
function zD(n, a, s, c, p, v, h, b, x, E, w) {
  for (var k = p - 1, _ = p === 0 ? v : [""], A = Hw(_), L = 0, $ = 0, Y = 0; L < c; ++L)
    for (var K = 0, W = Jv(n, k + 1, k = xF($ = h[L])), F = n; K < A; ++K)
      (F = VM($ > 0 ? _[K] + " " + W : tn(W, /&\f/g, _[K]))) && (x[Y++] = F);
  return wS(n, a, s, p === 0 ? Uw : b, x, E, w);
}
function zF(n, a, s) {
  return wS(n, a, s, Bw, CS(kF()), Jv(n, 2, -2), 0);
}
function PD(n, a, s, c) {
  return wS(n, a, s, Iw, Jv(n, 0, c), Jv(n, c + 1, -1), c);
}
function Gp(n, a) {
  for (var s = "", c = Hw(n), p = 0; p < c; p++)
    s += a(n[p], p, n, a) || "";
  return s;
}
function PF(n, a, s, c) {
  switch (n.type) {
    case SF:
      if (n.children.length)
        break;
    case bF:
    case Iw:
      return n.return = n.return || n.value;
    case Bw:
      return "";
    case FM:
      return n.return = n.value + "{" + Gp(n.children, c) + "}";
    case Uw:
      n.value = n.props.join(",");
  }
  return Ys(s = Gp(n.children, c)) ? n.return = n.value + "{" + s + "}" : "";
}
function LF(n) {
  var a = Hw(n);
  return function(s, c, p, v) {
    for (var h = "", b = 0; b < a; b++)
      h += n[b](s, c, p, v) || "";
    return h;
  };
}
function $F(n) {
  return function(a) {
    a.root || (a = a.return) && n(a);
  };
}
var LD = function(a) {
  var s = /* @__PURE__ */ new WeakMap();
  return function(c) {
    if (s.has(c))
      return s.get(c);
    var p = a(c);
    return s.set(c, p), p;
  };
}, NF = function(a, s, c) {
  for (var p = 0, v = 0; p = v, v = Gs(), p === 38 && v === 12 && (s[c] = 1), !ey(v); )
    Yi();
  return uy(a, Mi);
}, FF = function(a, s) {
  var c = -1, p = 44;
  do
    switch (ey(p)) {
      case 0:
        p === 38 && Gs() === 12 && (s[c] = 1), a[c] += NF(Mi - 1, s, c);
        break;
      case 2:
        a[c] += Lb(p);
        break;
      case 4:
        if (p === 44) {
          a[++c] = Gs() === 58 ? "&\f" : "", s[c] = a[c].length;
          break;
        }
      default:
        a[c] += CS(p);
    }
  while (p = Yi());
  return a;
}, VF = function(a, s) {
  return UM(FF(BM(a), s));
}, $D = /* @__PURE__ */ new WeakMap(), jF = function(a) {
  if (!(a.type !== "rule" || !a.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  a.length < 1)) {
    for (var s = a.value, c = a.parent, p = a.column === c.column && a.line === c.line; c.type !== "rule"; )
      if (c = c.parent, !c)
        return;
    if (!(a.props.length === 1 && s.charCodeAt(0) !== 58 && !$D.get(c)) && !p) {
      $D.set(a, !0);
      for (var v = [], h = VF(s, v), b = c.props, x = 0, E = 0; x < h.length; x++)
        for (var w = 0; w < b.length; w++, E++)
          a.props[E] = v[x] ? h[x].replace(/&\f/g, b[w]) : b[w] + " " + h[x];
    }
  }
}, BF = function(a) {
  if (a.type === "decl") {
    var s = a.value;
    // charcode for l
    s.charCodeAt(0) === 108 && // charcode for b
    s.charCodeAt(2) === 98 && (a.return = "", a.value = "");
  }
}, UF = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", IF = function(a) {
  return a.type === "comm" && a.children.indexOf(UF) > -1;
}, HF = function(a) {
  return function(s, c, p) {
    if (!(s.type !== "rule" || a.compat)) {
      var v = s.value.match(/(:first|:nth|:nth-last)-child/g);
      if (v) {
        for (var h = !!s.parent, b = h ? s.parent.children : (
          // global rule at the root level
          p
        ), x = b.length - 1; x >= 0; x--) {
          var E = b[x];
          if (E.line < s.line)
            break;
          if (E.column < s.column) {
            if (IF(E))
              return;
            break;
          }
        }
        v.forEach(function(w) {
          console.error('The pseudo class "' + w + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + w.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, IM = function(a) {
  return a.type.charCodeAt(1) === 105 && a.type.charCodeAt(0) === 64;
}, WF = function(a, s) {
  for (var c = a - 1; c >= 0; c--)
    if (!IM(s[c]))
      return !0;
  return !1;
}, ND = function(a) {
  a.type = "", a.value = "", a.return = "", a.children = "", a.props = "";
}, YF = function(a, s, c) {
  IM(a) && (a.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), ND(a)) : WF(s, c) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), ND(a)));
};
function HM(n, a) {
  switch (EF(n, a)) {
    case 5103:
      return en + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return en + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return en + n + Zb + n + Ba + n + n;
    case 6828:
    case 4268:
      return en + n + Ba + n + n;
    case 6165:
      return en + n + Ba + "flex-" + n + n;
    case 5187:
      return en + n + tn(n, /(\w+).+(:[^]+)/, en + "box-$1$2" + Ba + "flex-$1$2") + n;
    case 5443:
      return en + n + Ba + "flex-item-" + tn(n, /flex-|-self/, "") + n;
    case 4675:
      return en + n + Ba + "flex-line-pack" + tn(n, /align-content|flex-|-self/, "") + n;
    case 5548:
      return en + n + Ba + tn(n, "shrink", "negative") + n;
    case 5292:
      return en + n + Ba + tn(n, "basis", "preferred-size") + n;
    case 6060:
      return en + "box-" + tn(n, "-grow", "") + en + n + Ba + tn(n, "grow", "positive") + n;
    case 4554:
      return en + tn(n, /([^-])(transform)/g, "$1" + en + "$2") + n;
    case 6187:
      return tn(tn(tn(n, /(zoom-|grab)/, en + "$1"), /(image-set)/, en + "$1"), n, "") + n;
    case 5495:
    case 3959:
      return tn(n, /(image-set\([^]*)/, en + "$1$`$1");
    case 4968:
      return tn(tn(n, /(.+:)(flex-)?(.*)/, en + "box-pack:$3" + Ba + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + en + n + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return tn(n, /(.+)-inline(.+)/, en + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Ys(n) - 1 - a > 6)
        switch (ya(n, a + 1)) {
          case 109:
            if (ya(n, a + 4) !== 45)
              break;
          case 102:
            return tn(n, /(.+:)(.+)-([^]+)/, "$1" + en + "$2-$3$1" + Zb + (ya(n, a + 3) == 108 ? "$3" : "$2-$3")) + n;
          case 115:
            return ~ow(n, "stretch") ? HM(tn(n, "stretch", "fill-available"), a) + n : n;
        }
      break;
    case 4949:
      if (ya(n, a + 1) !== 115)
        break;
    case 6444:
      switch (ya(n, Ys(n) - 3 - (~ow(n, "!important") && 10))) {
        case 107:
          return tn(n, ":", ":" + en) + n;
        case 101:
          return tn(n, /(.+:)([^;!]+)(;|!.+)?/, "$1" + en + (ya(n, 14) === 45 ? "inline-" : "") + "box$3$1" + en + "$2$3$1" + Ba + "$2box$3") + n;
      }
      break;
    case 5936:
      switch (ya(n, a + 11)) {
        case 114:
          return en + n + Ba + tn(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return en + n + Ba + tn(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return en + n + Ba + tn(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return en + n + Ba + n + n;
  }
  return n;
}
var GF = function(a, s, c, p) {
  if (a.length > -1 && !a.return)
    switch (a.type) {
      case Iw:
        a.return = HM(a.value, a.length);
        break;
      case FM:
        return Gp([Rv(a, {
          value: tn(a.value, "@", "@" + en)
        })], p);
      case Uw:
        if (a.length)
          return TF(a.props, function(v) {
            switch (wF(v, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return Gp([Rv(a, {
                  props: [tn(v, /:(read-\w+)/, ":" + Zb + "$1")]
                })], p);
              case "::placeholder":
                return Gp([Rv(a, {
                  props: [tn(v, /:(plac\w+)/, ":" + en + "input-$1")]
                }), Rv(a, {
                  props: [tn(v, /:(plac\w+)/, ":" + Zb + "$1")]
                }), Rv(a, {
                  props: [tn(v, /:(plac\w+)/, Ba + "input-$1")]
                })], p);
            }
            return "";
          });
    }
}, qF = [GF], QF = function(a) {
  var s = a.key;
  if (process.env.NODE_ENV !== "production" && !s)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (s === "css") {
    var c = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(c, function($) {
      var Y = $.getAttribute("data-emotion");
      Y.indexOf(" ") !== -1 && (document.head.appendChild($), $.setAttribute("data-s", ""));
    });
  }
  var p = a.stylisPlugins || qF;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(s))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + s + '" was passed');
  var v = {}, h, b = [];
  h = a.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + s + ' "]'),
    function($) {
      for (var Y = $.getAttribute("data-emotion").split(" "), K = 1; K < Y.length; K++)
        v[Y[K]] = !0;
      b.push($);
    }
  );
  var x, E = [jF, BF];
  process.env.NODE_ENV !== "production" && E.push(HF({
    get compat() {
      return L.compat;
    }
  }), YF);
  {
    var w, k = [PF, process.env.NODE_ENV !== "production" ? function($) {
      $.root || ($.return ? w.insert($.return) : $.value && $.type !== Bw && w.insert($.value + "{}"));
    } : $F(function($) {
      w.insert($);
    })], _ = LF(E.concat(p, k)), A = function(Y) {
      return Gp(OF(Y), _);
    };
    x = function(Y, K, W, F) {
      w = W, process.env.NODE_ENV !== "production" && K.map !== void 0 && (w = {
        insert: function(H) {
          W.insert(H + K.map);
        }
      }), A(Y ? Y + "{" + K.styles + "}" : K.styles), F && (L.inserted[K.name] = !0);
    };
  }
  var L = {
    key: s,
    sheet: new gF({
      key: s,
      container: h,
      nonce: a.nonce,
      speedy: a.speedy,
      prepend: a.prepend,
      insertionPoint: a.insertionPoint
    }),
    nonce: a.nonce,
    inserted: v,
    registered: {},
    insert: x
  };
  return L.sheet.hydrate(b), L;
};
function Jb() {
  return Jb = Object.assign ? Object.assign.bind() : function(n) {
    for (var a = 1; a < arguments.length; a++) {
      var s = arguments[a];
      for (var c in s)
        Object.prototype.hasOwnProperty.call(s, c) && (n[c] = s[c]);
    }
    return n;
  }, Jb.apply(this, arguments);
}
var lw = { exports: {} }, sn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FD;
function KF() {
  if (FD)
    return sn;
  FD = 1;
  var n = typeof Symbol == "function" && Symbol.for, a = n ? Symbol.for("react.element") : 60103, s = n ? Symbol.for("react.portal") : 60106, c = n ? Symbol.for("react.fragment") : 60107, p = n ? Symbol.for("react.strict_mode") : 60108, v = n ? Symbol.for("react.profiler") : 60114, h = n ? Symbol.for("react.provider") : 60109, b = n ? Symbol.for("react.context") : 60110, x = n ? Symbol.for("react.async_mode") : 60111, E = n ? Symbol.for("react.concurrent_mode") : 60111, w = n ? Symbol.for("react.forward_ref") : 60112, k = n ? Symbol.for("react.suspense") : 60113, _ = n ? Symbol.for("react.suspense_list") : 60120, A = n ? Symbol.for("react.memo") : 60115, L = n ? Symbol.for("react.lazy") : 60116, $ = n ? Symbol.for("react.block") : 60121, Y = n ? Symbol.for("react.fundamental") : 60117, K = n ? Symbol.for("react.responder") : 60118, W = n ? Symbol.for("react.scope") : 60119;
  function F(H) {
    if (typeof H == "object" && H !== null) {
      var le = H.$$typeof;
      switch (le) {
        case a:
          switch (H = H.type, H) {
            case x:
            case E:
            case c:
            case v:
            case p:
            case k:
              return H;
            default:
              switch (H = H && H.$$typeof, H) {
                case b:
                case w:
                case L:
                case A:
                case h:
                  return H;
                default:
                  return le;
              }
          }
        case s:
          return le;
      }
    }
  }
  function ne(H) {
    return F(H) === E;
  }
  return sn.AsyncMode = x, sn.ConcurrentMode = E, sn.ContextConsumer = b, sn.ContextProvider = h, sn.Element = a, sn.ForwardRef = w, sn.Fragment = c, sn.Lazy = L, sn.Memo = A, sn.Portal = s, sn.Profiler = v, sn.StrictMode = p, sn.Suspense = k, sn.isAsyncMode = function(H) {
    return ne(H) || F(H) === x;
  }, sn.isConcurrentMode = ne, sn.isContextConsumer = function(H) {
    return F(H) === b;
  }, sn.isContextProvider = function(H) {
    return F(H) === h;
  }, sn.isElement = function(H) {
    return typeof H == "object" && H !== null && H.$$typeof === a;
  }, sn.isForwardRef = function(H) {
    return F(H) === w;
  }, sn.isFragment = function(H) {
    return F(H) === c;
  }, sn.isLazy = function(H) {
    return F(H) === L;
  }, sn.isMemo = function(H) {
    return F(H) === A;
  }, sn.isPortal = function(H) {
    return F(H) === s;
  }, sn.isProfiler = function(H) {
    return F(H) === v;
  }, sn.isStrictMode = function(H) {
    return F(H) === p;
  }, sn.isSuspense = function(H) {
    return F(H) === k;
  }, sn.isValidElementType = function(H) {
    return typeof H == "string" || typeof H == "function" || H === c || H === E || H === v || H === p || H === k || H === _ || typeof H == "object" && H !== null && (H.$$typeof === L || H.$$typeof === A || H.$$typeof === h || H.$$typeof === b || H.$$typeof === w || H.$$typeof === Y || H.$$typeof === K || H.$$typeof === W || H.$$typeof === $);
  }, sn.typeOf = F, sn;
}
var ln = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VD;
function XF() {
  return VD || (VD = 1, process.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, a = n ? Symbol.for("react.element") : 60103, s = n ? Symbol.for("react.portal") : 60106, c = n ? Symbol.for("react.fragment") : 60107, p = n ? Symbol.for("react.strict_mode") : 60108, v = n ? Symbol.for("react.profiler") : 60114, h = n ? Symbol.for("react.provider") : 60109, b = n ? Symbol.for("react.context") : 60110, x = n ? Symbol.for("react.async_mode") : 60111, E = n ? Symbol.for("react.concurrent_mode") : 60111, w = n ? Symbol.for("react.forward_ref") : 60112, k = n ? Symbol.for("react.suspense") : 60113, _ = n ? Symbol.for("react.suspense_list") : 60120, A = n ? Symbol.for("react.memo") : 60115, L = n ? Symbol.for("react.lazy") : 60116, $ = n ? Symbol.for("react.block") : 60121, Y = n ? Symbol.for("react.fundamental") : 60117, K = n ? Symbol.for("react.responder") : 60118, W = n ? Symbol.for("react.scope") : 60119;
    function F(ge) {
      return typeof ge == "string" || typeof ge == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ge === c || ge === E || ge === v || ge === p || ge === k || ge === _ || typeof ge == "object" && ge !== null && (ge.$$typeof === L || ge.$$typeof === A || ge.$$typeof === h || ge.$$typeof === b || ge.$$typeof === w || ge.$$typeof === Y || ge.$$typeof === K || ge.$$typeof === W || ge.$$typeof === $);
    }
    function ne(ge) {
      if (typeof ge == "object" && ge !== null) {
        var kn = ge.$$typeof;
        switch (kn) {
          case a:
            var Mn = ge.type;
            switch (Mn) {
              case x:
              case E:
              case c:
              case v:
              case p:
              case k:
                return Mn;
              default:
                var jn = Mn && Mn.$$typeof;
                switch (jn) {
                  case b:
                  case w:
                  case L:
                  case A:
                  case h:
                    return jn;
                  default:
                    return kn;
                }
            }
          case s:
            return kn;
        }
      }
    }
    var H = x, le = E, re = b, De = h, Fe = a, ot = w, vt = c, Rt = L, $e = A, Be = s, jt = v, tt = p, Lt = k, he = !1;
    function Ce(ge) {
      return he || (he = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), ve(ge) || ne(ge) === x;
    }
    function ve(ge) {
      return ne(ge) === E;
    }
    function Ae(ge) {
      return ne(ge) === b;
    }
    function Ye(ge) {
      return ne(ge) === h;
    }
    function Ke(ge) {
      return typeof ge == "object" && ge !== null && ge.$$typeof === a;
    }
    function cn(ge) {
      return ne(ge) === w;
    }
    function Vn(ge) {
      return ne(ge) === c;
    }
    function bt(ge) {
      return ne(ge) === L;
    }
    function yn(ge) {
      return ne(ge) === A;
    }
    function Ot(ge) {
      return ne(ge) === s;
    }
    function Bt(ge) {
      return ne(ge) === v;
    }
    function gn(ge) {
      return ne(ge) === p;
    }
    function $t(ge) {
      return ne(ge) === k;
    }
    ln.AsyncMode = H, ln.ConcurrentMode = le, ln.ContextConsumer = re, ln.ContextProvider = De, ln.Element = Fe, ln.ForwardRef = ot, ln.Fragment = vt, ln.Lazy = Rt, ln.Memo = $e, ln.Portal = Be, ln.Profiler = jt, ln.StrictMode = tt, ln.Suspense = Lt, ln.isAsyncMode = Ce, ln.isConcurrentMode = ve, ln.isContextConsumer = Ae, ln.isContextProvider = Ye, ln.isElement = Ke, ln.isForwardRef = cn, ln.isFragment = Vn, ln.isLazy = bt, ln.isMemo = yn, ln.isPortal = Ot, ln.isProfiler = Bt, ln.isStrictMode = gn, ln.isSuspense = $t, ln.isValidElementType = F, ln.typeOf = ne;
  }()), ln;
}
process.env.NODE_ENV === "production" ? lw.exports = KF() : lw.exports = XF();
var ZF = lw.exports, WM = ZF, JF = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, eV = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, YM = {};
YM[WM.ForwardRef] = JF;
YM[WM.Memo] = eV;
var tV = !0;
function Ww(n, a, s) {
  var c = "";
  return s.split(" ").forEach(function(p) {
    n[p] !== void 0 ? a.push(n[p] + ";") : c += p + " ";
  }), c;
}
var TS = function(a, s, c) {
  var p = a.key + "-" + s.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (c === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  tV === !1) && a.registered[p] === void 0 && (a.registered[p] = s.styles);
}, kS = function(a, s, c) {
  TS(a, s, c);
  var p = a.key + "-" + s.name;
  if (a.inserted[s.name] === void 0) {
    var v = s;
    do
      a.insert(s === v ? "." + p : "", v, a.sheet, !0), v = v.next;
    while (v !== void 0);
  }
};
function nV(n) {
  for (var a = 0, s, c = 0, p = n.length; p >= 4; ++c, p -= 4)
    s = n.charCodeAt(c) & 255 | (n.charCodeAt(++c) & 255) << 8 | (n.charCodeAt(++c) & 255) << 16 | (n.charCodeAt(++c) & 255) << 24, s = /* Math.imul(k, m): */
    (s & 65535) * 1540483477 + ((s >>> 16) * 59797 << 16), s ^= /* k >>> r: */
    s >>> 24, a = /* Math.imul(k, m): */
    (s & 65535) * 1540483477 + ((s >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (a & 65535) * 1540483477 + ((a >>> 16) * 59797 << 16);
  switch (p) {
    case 3:
      a ^= (n.charCodeAt(c + 2) & 255) << 16;
    case 2:
      a ^= (n.charCodeAt(c + 1) & 255) << 8;
    case 1:
      a ^= n.charCodeAt(c) & 255, a = /* Math.imul(h, m): */
      (a & 65535) * 1540483477 + ((a >>> 16) * 59797 << 16);
  }
  return a ^= a >>> 13, a = /* Math.imul(h, m): */
  (a & 65535) * 1540483477 + ((a >>> 16) * 59797 << 16), ((a ^ a >>> 15) >>> 0).toString(36);
}
var rV = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, jD = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, aV = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", iV = /[A-Z]|^ms/g, GM = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Yw = function(a) {
  return a.charCodeAt(1) === 45;
}, BD = function(a) {
  return a != null && typeof a != "boolean";
}, yE = /* @__PURE__ */ fM(function(n) {
  return Yw(n) ? n : n.replace(iV, "-$&").toLowerCase();
}), eS = function(a, s) {
  switch (a) {
    case "animation":
    case "animationName":
      if (typeof s == "string")
        return s.replace(GM, function(c, p, v) {
          return ns = {
            name: p,
            styles: v,
            next: ns
          }, p;
        });
  }
  return rV[a] !== 1 && !Yw(a) && typeof s == "number" && s !== 0 ? s + "px" : s;
};
if (process.env.NODE_ENV !== "production") {
  var oV = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, sV = ["normal", "none", "initial", "inherit", "unset"], lV = eS, uV = /^-ms-/, cV = /-(.)/g, UD = {};
  eS = function(a, s) {
    if (a === "content" && (typeof s != "string" || sV.indexOf(s) === -1 && !oV.test(s) && (s.charAt(0) !== s.charAt(s.length - 1) || s.charAt(0) !== '"' && s.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + s + "\"'`");
    var c = lV(a, s);
    return c !== "" && !Yw(a) && a.indexOf("-") !== -1 && UD[a] === void 0 && (UD[a] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + a.replace(uV, "ms-").replace(cV, function(p, v) {
      return v.toUpperCase();
    }) + "?")), c;
  };
}
var qM = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function ty(n, a, s) {
  if (s == null)
    return "";
  if (s.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && s.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(qM);
    return s;
  }
  switch (typeof s) {
    case "boolean":
      return "";
    case "object": {
      if (s.anim === 1)
        return ns = {
          name: s.name,
          styles: s.styles,
          next: ns
        }, s.name;
      if (s.styles !== void 0) {
        var c = s.next;
        if (c !== void 0)
          for (; c !== void 0; )
            ns = {
              name: c.name,
              styles: c.styles,
              next: ns
            }, c = c.next;
        var p = s.styles + ";";
        return process.env.NODE_ENV !== "production" && s.map !== void 0 && (p += s.map), p;
      }
      return fV(n, a, s);
    }
    case "function": {
      if (n !== void 0) {
        var v = ns, h = s(n);
        return ns = v, ty(n, a, h);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var b = [], x = s.replace(GM, function(w, k, _) {
          var A = "animation" + b.length;
          return b.push("const " + A + " = keyframes`" + _.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + A + "}";
        });
        b.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(b, ["`" + x + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + x + "`"));
      }
      break;
  }
  if (a == null)
    return s;
  var E = a[s];
  return E !== void 0 ? E : s;
}
function fV(n, a, s) {
  var c = "";
  if (Array.isArray(s))
    for (var p = 0; p < s.length; p++)
      c += ty(n, a, s[p]) + ";";
  else
    for (var v in s) {
      var h = s[v];
      if (typeof h != "object")
        a != null && a[h] !== void 0 ? c += v + "{" + a[h] + "}" : BD(h) && (c += yE(v) + ":" + eS(v, h) + ";");
      else {
        if (v === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(qM);
        if (Array.isArray(h) && typeof h[0] == "string" && (a == null || a[h[0]] === void 0))
          for (var b = 0; b < h.length; b++)
            BD(h[b]) && (c += yE(v) + ":" + eS(v, h[b]) + ";");
        else {
          var x = ty(n, a, h);
          switch (v) {
            case "animation":
            case "animationName": {
              c += yE(v) + ":" + x + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && v === "undefined" && console.error(aV), c += v + "{" + x + "}";
          }
        }
      }
    }
  return c;
}
var ID = /label:\s*([^\s;\n{]+)\s*(;|$)/g, QM;
process.env.NODE_ENV !== "production" && (QM = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var ns, oh = function(a, s, c) {
  if (a.length === 1 && typeof a[0] == "object" && a[0] !== null && a[0].styles !== void 0)
    return a[0];
  var p = !0, v = "";
  ns = void 0;
  var h = a[0];
  h == null || h.raw === void 0 ? (p = !1, v += ty(c, s, h)) : (process.env.NODE_ENV !== "production" && h[0] === void 0 && console.error(jD), v += h[0]);
  for (var b = 1; b < a.length; b++)
    v += ty(c, s, a[b]), p && (process.env.NODE_ENV !== "production" && h[b] === void 0 && console.error(jD), v += h[b]);
  var x;
  process.env.NODE_ENV !== "production" && (v = v.replace(QM, function(_) {
    return x = _, "";
  })), ID.lastIndex = 0;
  for (var E = "", w; (w = ID.exec(v)) !== null; )
    E += "-" + // $FlowFixMe we know it's not null
    w[1];
  var k = nV(v) + E;
  return process.env.NODE_ENV !== "production" ? {
    name: k,
    styles: v,
    map: x,
    next: ns,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: k,
    styles: v,
    next: ns
  };
}, dV = function(a) {
  return a();
}, KM = kt.useInsertionEffect ? kt.useInsertionEffect : !1, Gw = KM || dV, HD = KM || kt.useLayoutEffect, pV = {}.hasOwnProperty, qw = /* @__PURE__ */ kt.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ QF({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (qw.displayName = "EmotionCacheContext");
qw.Provider;
var RS = function(a) {
  return /* @__PURE__ */ zw(function(s, c) {
    var p = ar(qw);
    return a(s, p, c);
  });
}, pc = /* @__PURE__ */ kt.createContext({});
process.env.NODE_ENV !== "production" && (pc.displayName = "EmotionThemeContext");
var hV = function(a, s) {
  if (typeof s == "function") {
    var c = s(a);
    if (process.env.NODE_ENV !== "production" && (c == null || typeof c != "object" || Array.isArray(c)))
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    return c;
  }
  if (process.env.NODE_ENV !== "production" && (s == null || typeof s != "object" || Array.isArray(s)))
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  return Jb({}, a, s);
}, mV = /* @__PURE__ */ LD(function(n) {
  return LD(function(a) {
    return hV(n, a);
  });
}), vV = function(a) {
  var s = kt.useContext(pc);
  return a.theme !== s && (s = mV(s)(a.theme)), /* @__PURE__ */ kt.createElement(pc.Provider, {
    value: s
  }, a.children);
}, WD = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", YD = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", yV = function(a) {
  var s = a.cache, c = a.serialized, p = a.isStringTag;
  return TS(s, c, p), Gw(function() {
    return kS(s, c, p);
  }), null;
}, gV = /* @__PURE__ */ RS(function(n, a, s) {
  var c = n.css;
  typeof c == "string" && a.registered[c] !== void 0 && (c = a.registered[c]);
  var p = n[WD], v = [c], h = "";
  typeof n.className == "string" ? h = Ww(a.registered, v, n.className) : n.className != null && (h = n.className + " ");
  var b = oh(v, void 0, kt.useContext(pc));
  if (process.env.NODE_ENV !== "production" && b.name.indexOf("-") === -1) {
    var x = n[YD];
    x && (b = oh([b, "label:" + x + ";"]));
  }
  h += a.key + "-" + b.name;
  var E = {};
  for (var w in n)
    pV.call(n, w) && w !== "css" && w !== WD && (process.env.NODE_ENV === "production" || w !== YD) && (E[w] = n[w]);
  return E.ref = s, E.className = h, /* @__PURE__ */ kt.createElement(kt.Fragment, null, /* @__PURE__ */ kt.createElement(yV, {
    cache: a,
    serialized: b,
    isStringTag: typeof p == "string"
  }), /* @__PURE__ */ kt.createElement(p, E));
});
process.env.NODE_ENV !== "production" && (gV.displayName = "EmotionCssPropInternal");
var bV = {
  name: "@emotion/react",
  version: "11.11.3",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      import: "./dist/emotion-react.cjs.mjs",
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        import: "./macro.d.mts",
        default: "./macro.d.ts"
      },
      default: "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.2",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            import: "./macro.d.mts",
            default: "./macro.d.ts"
          },
          default: "./macro.js"
        }
      }
    }
  }
}, GD = !1, cy = /* @__PURE__ */ RS(function(n, a) {
  process.env.NODE_ENV !== "production" && !GD && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (n.className || n.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), GD = !0);
  var s = n.styles, c = oh([s], void 0, kt.useContext(pc)), p = kt.useRef();
  return HD(function() {
    var v = a.key + "-global", h = new a.sheet.constructor({
      key: v,
      nonce: a.sheet.nonce,
      container: a.sheet.container,
      speedy: a.sheet.isSpeedy
    }), b = !1, x = document.querySelector('style[data-emotion="' + v + " " + c.name + '"]');
    return a.sheet.tags.length && (h.before = a.sheet.tags[0]), x !== null && (b = !0, x.setAttribute("data-emotion", v), h.hydrate([x])), p.current = [h, b], function() {
      h.flush();
    };
  }, [a]), HD(function() {
    var v = p.current, h = v[0], b = v[1];
    if (b) {
      v[1] = !1;
      return;
    }
    if (c.next !== void 0 && kS(a, c.next, !0), h.tags.length) {
      var x = h.tags[h.tags.length - 1].nextElementSibling;
      h.before = x, h.flush();
    }
    a.insert("", c, h, !1);
  }, [a, c.name]), null;
});
process.env.NODE_ENV !== "production" && (cy.displayName = "EmotionGlobal");
function SV() {
  for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
    a[s] = arguments[s];
  return oh(a);
}
var XM = function() {
  var a = SV.apply(void 0, arguments), s = "animation-" + a.name;
  return {
    name: s,
    styles: "@keyframes " + s + "{" + a.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, xV = function n(a) {
  for (var s = a.length, c = 0, p = ""; c < s; c++) {
    var v = a[c];
    if (v != null) {
      var h = void 0;
      switch (typeof v) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(v))
            h = n(v);
          else {
            process.env.NODE_ENV !== "production" && v.styles !== void 0 && v.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), h = "";
            for (var b in v)
              v[b] && b && (h && (h += " "), h += b);
          }
          break;
        }
        default:
          h = v;
      }
      h && (p && (p += " "), p += h);
    }
  }
  return p;
};
function CV(n, a, s) {
  var c = [], p = Ww(n, c, s);
  return c.length < 2 ? s : p + a(c);
}
var EV = function(a) {
  var s = a.cache, c = a.serializedArr;
  return Gw(function() {
    for (var p = 0; p < c.length; p++)
      kS(s, c[p], !1);
  }), null;
}, wV = /* @__PURE__ */ RS(function(n, a) {
  var s = !1, c = [], p = function() {
    if (s && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var E = arguments.length, w = new Array(E), k = 0; k < E; k++)
      w[k] = arguments[k];
    var _ = oh(w, a.registered);
    return c.push(_), TS(a, _, !1), a.key + "-" + _.name;
  }, v = function() {
    if (s && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var E = arguments.length, w = new Array(E), k = 0; k < E; k++)
      w[k] = arguments[k];
    return CV(a.registered, p, xV(w));
  }, h = {
    css: p,
    cx: v,
    theme: kt.useContext(pc)
  }, b = n.children(h);
  return s = !0, /* @__PURE__ */ kt.createElement(kt.Fragment, null, /* @__PURE__ */ kt.createElement(EV, {
    cache: a,
    serializedArr: c
  }), b);
});
process.env.NODE_ENV !== "production" && (wV.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var qD = !0, TV = typeof jest < "u" || typeof vi < "u";
  if (qD && !TV) {
    var QD = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : qD ? window : global
    ), KD = "__EMOTION_REACT_" + bV.version.split(".")[0] + "__";
    QD[KD] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), QD[KD] = !0;
  }
}
const iQ = () => XM`
  from {
    border-color: #E4E8EC;
    background-color: #E4E8EC;
  }
  to {
    border-color: #D8D8D8;
    background-color: #D8D8D8;
  }
`, kV = {
  primary: {
    50: "#F3F5F6",
    100: "#DEE2E8",
    200: "#C4C8CF",
    300: "#8B94A2",
    400: "#54657D",
    500: "#1C2128",
    600: "#3A495F",
    700: "#303D4F",
    800: "#15191E",
    900: "#000000"
  },
  secondary: {
    50: "#FFE6CC",
    100: "#FFD1A3",
    200: "#F9BD80",
    300: "#FBB874",
    400: "#F8A34F",
    500: "#F6993C",
    600: "#EF8215",
    700: "#DB730A",
    800: "#C86909",
    900: "#753D04"
  },
  tertiary: {
    50: "#F6F7FE",
    100: "#D9D9F7",
    200: "#CDCCF5",
    300: "#B4B2F0",
    400: "#A2A0EE",
    500: "#918EEB",
    600: "#765EED",
    700: "#644AE8",
    800: "#3B3687",
    900: "#32275D"
  },
  neutral: {
    50: "#FCFCFD",
    100: "#F6F8FA",
    200: "#E6E8EB",
    300: "#B3B8BC",
    400: "#828B93",
    500: "#555C62",
    600: "#42484C",
    700: "#393E42",
    800: "#383838",
    900: "#000000"
  },
  link: {
    default: "#007AFF",
    disabled: "#80A9F9",
    hover: "#4F87F8",
    visited: "#0949C8"
  },
  /**
   * Complementary
   */
  beige: {
    50: "#E9E1DD",
    100: "#F9F7F6",
    200: "#F1ECE9",
    300: "#E9E1DD",
    400: "#E0D4CC",
    500: "#CBBCB3",
    600: "#BEACA2",
    700: "#9C8B81",
    800: "#635A54",
    900: "#413C3A"
  },
  lightBlue: {
    50: "#F6FBFE",
    100: "#ECF6FD",
    200: "#DDEBF9",
    300: "#C6DEF4",
    400: "#A1CCF3",
    500: "#7FAFDC",
    600: "#5599D8",
    700: "#3278B8",
    800: "#19578F",
    900: "#123C64"
  },
  softPink: {
    50: "#FDF7F7",
    100: "#FBEFEE",
    200: "#FCE5E3",
    300: "#FFD0CC",
    400: "#FFBDB8",
    500: "#FFAAA3",
    600: "#FF938A",
    700: "#F7786E",
    800: "#EC5D51",
    900: "#B8392E"
  },
  /**
   * Feedback
   */
  error: {
    50: "#FCF0ED",
    100: "#F9DDD7",
    200: "#F2B3A6",
    300: "#F59380",
    400: "#EA7962",
    500: "#E35C31",
    600: "#D84E22",
    700: "#B9421D",
    800: "#963617",
    900: "#652410"
  },
  success: {
    50: "#EFFBF8",
    100: "#D6F5EE",
    200: "#ADEBDD",
    300: "#7CDEC9",
    400: "#50D3B7",
    500: "#34C0A2",
    600: "#2EA98E",
    700: "#258873",
    800: "#1C6858",
    900: "#154C40"
  }
}, RV = {
  50: "0px 4px 12px -2px rgba(0, 0, 0, 0.01), 0px 10px 23px -3px rgba(0, 0, 0, 0.07);",
  100: "0px 10px 16px -3px rgba(0, 0, 0, 0.04), 0px 2px 8px -2px rgba(0, 0, 0, 0.02)",
  200: "0px 10px 23px -3px rgba(0, 0, 0, 0.07), 0px 4px 12px -2px rgba(0, 0, 0, 0.01)",
  300: "0px 20px 44px -3px rgba(0, 0, 0, 0.08), 0px 8px 17px -4px rgba(0, 0, 0, 0.04)",
  400: "0px -10px 100px -5px rgba(0, 0, 0, 0.05), 0px 35px 116px -3px rgba(0, 0, 0, 0.08), 0px 32px 41px -4px rgba(0, 0, 0, 0.06)"
}, _V = {
  body: "Founders Grotesk, sans-serif",
  heading: "Founders Grotesk, sans-serif"
}, DV = {
  "2xs": "10px",
  xs: "11px",
  sm: "12px",
  md: "14px",
  lg: "16px",
  xl: "18px",
  "2xl": "20px",
  "3xl": "24px",
  "4xl": "28px",
  "5xl": "36px",
  "6xl": "48px"
}, AV = {
  xs: "320px",
  sm: "414px",
  md: "768px",
  lg: "960px",
  xl: "1200px",
  "2xl": "1536px"
};
var ZM = String.raw, JM = ZM`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, MV = () => /* @__PURE__ */ Oe.jsx(cy, { styles: JM }), OV = ({ scope: n = "" }) => /* @__PURE__ */ Oe.jsx(
  cy,
  {
    styles: ZM`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${n} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${n} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${n} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${n} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${n} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${n} :where(b, strong) {
        font-weight: bold;
      }

      ${n} small {
        font-size: 80%;
      }

      ${n} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${n} sub {
        bottom: -0.25em;
      }

      ${n} sup {
        top: -0.5em;
      }

      ${n} img {
        border-style: none;
      }

      ${n} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${n} :where(button, input) {
        overflow: visible;
      }

      ${n} :where(button, select) {
        text-transform: none;
      }

      ${n} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${n} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${n} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${n} progress {
        vertical-align: baseline;
      }

      ${n} textarea {
        overflow: auto;
      }

      ${n} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${n} input[type="number"]::-webkit-inner-spin-button,
      ${n} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${n} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${n} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${n} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${n} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${n} details {
        display: block;
      }

      ${n} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${n} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${n} button {
        background: transparent;
        padding: 0;
      }

      ${n} fieldset {
        margin: 0;
        padding: 0;
      }

      ${n} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${n} textarea {
        resize: vertical;
      }

      ${n} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${n} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${n} table {
        border-collapse: collapse;
      }

      ${n} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${n} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${n} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${n} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${n} select::-ms-expand {
        display: none;
      }

      ${JM}
    `
  }
);
function zV(n, a) {
  return `${n} returned \`undefined\`. Seems you forgot to wrap component within ${a}`;
}
function fy(n = {}) {
  const {
    name: a,
    strict: s = !0,
    hookName: c = "useContext",
    providerName: p = "Provider",
    errorMessage: v,
    defaultValue: h
  } = n, b = Ks(h);
  b.displayName = a;
  function x() {
    var E;
    const w = ar(b);
    if (!w && s) {
      const k = new Error(
        v ?? zV(c, p)
      );
      throw k.name = "ContextError", (E = Error.captureStackTrace) == null || E.call(Error, k, x), k;
    }
    return w;
  }
  return [b.Provider, x, b];
}
var [PV, LV] = fy({
  strict: !1,
  name: "PortalManagerContext"
});
function eO(n) {
  const { children: a, zIndex: s } = n;
  return /* @__PURE__ */ Oe.jsx(PV, { value: { zIndex: s }, children: a });
}
eO.displayName = "PortalManager";
var tS = globalThis != null && globalThis.document ? lM : Qi, uw = { exports: {} }, Ri = {}, mb = { exports: {} }, gE = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XD;
function $V() {
  return XD || (XD = 1, function(n) {
    function a(he, Ce) {
      var ve = he.length;
      he.push(Ce);
      e:
        for (; 0 < ve; ) {
          var Ae = ve - 1 >>> 1, Ye = he[Ae];
          if (0 < p(Ye, Ce))
            he[Ae] = Ce, he[ve] = Ye, ve = Ae;
          else
            break e;
        }
    }
    function s(he) {
      return he.length === 0 ? null : he[0];
    }
    function c(he) {
      if (he.length === 0)
        return null;
      var Ce = he[0], ve = he.pop();
      if (ve !== Ce) {
        he[0] = ve;
        e:
          for (var Ae = 0, Ye = he.length, Ke = Ye >>> 1; Ae < Ke; ) {
            var cn = 2 * (Ae + 1) - 1, Vn = he[cn], bt = cn + 1, yn = he[bt];
            if (0 > p(Vn, ve))
              bt < Ye && 0 > p(yn, Vn) ? (he[Ae] = yn, he[bt] = ve, Ae = bt) : (he[Ae] = Vn, he[cn] = ve, Ae = cn);
            else if (bt < Ye && 0 > p(yn, ve))
              he[Ae] = yn, he[bt] = ve, Ae = bt;
            else
              break e;
          }
      }
      return Ce;
    }
    function p(he, Ce) {
      var ve = he.sortIndex - Ce.sortIndex;
      return ve !== 0 ? ve : he.id - Ce.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var v = performance;
      n.unstable_now = function() {
        return v.now();
      };
    } else {
      var h = Date, b = h.now();
      n.unstable_now = function() {
        return h.now() - b;
      };
    }
    var x = [], E = [], w = 1, k = null, _ = 3, A = !1, L = !1, $ = !1, Y = typeof setTimeout == "function" ? setTimeout : null, K = typeof clearTimeout == "function" ? clearTimeout : null, W = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function F(he) {
      for (var Ce = s(E); Ce !== null; ) {
        if (Ce.callback === null)
          c(E);
        else if (Ce.startTime <= he)
          c(E), Ce.sortIndex = Ce.expirationTime, a(x, Ce);
        else
          break;
        Ce = s(E);
      }
    }
    function ne(he) {
      if ($ = !1, F(he), !L)
        if (s(x) !== null)
          L = !0, tt(H);
        else {
          var Ce = s(E);
          Ce !== null && Lt(ne, Ce.startTime - he);
        }
    }
    function H(he, Ce) {
      L = !1, $ && ($ = !1, K(De), De = -1), A = !0;
      var ve = _;
      try {
        for (F(Ce), k = s(x); k !== null && (!(k.expirationTime > Ce) || he && !vt()); ) {
          var Ae = k.callback;
          if (typeof Ae == "function") {
            k.callback = null, _ = k.priorityLevel;
            var Ye = Ae(k.expirationTime <= Ce);
            Ce = n.unstable_now(), typeof Ye == "function" ? k.callback = Ye : k === s(x) && c(x), F(Ce);
          } else
            c(x);
          k = s(x);
        }
        if (k !== null)
          var Ke = !0;
        else {
          var cn = s(E);
          cn !== null && Lt(ne, cn.startTime - Ce), Ke = !1;
        }
        return Ke;
      } finally {
        k = null, _ = ve, A = !1;
      }
    }
    var le = !1, re = null, De = -1, Fe = 5, ot = -1;
    function vt() {
      return !(n.unstable_now() - ot < Fe);
    }
    function Rt() {
      if (re !== null) {
        var he = n.unstable_now();
        ot = he;
        var Ce = !0;
        try {
          Ce = re(!0, he);
        } finally {
          Ce ? $e() : (le = !1, re = null);
        }
      } else
        le = !1;
    }
    var $e;
    if (typeof W == "function")
      $e = function() {
        W(Rt);
      };
    else if (typeof MessageChannel < "u") {
      var Be = new MessageChannel(), jt = Be.port2;
      Be.port1.onmessage = Rt, $e = function() {
        jt.postMessage(null);
      };
    } else
      $e = function() {
        Y(Rt, 0);
      };
    function tt(he) {
      re = he, le || (le = !0, $e());
    }
    function Lt(he, Ce) {
      De = Y(function() {
        he(n.unstable_now());
      }, Ce);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(he) {
      he.callback = null;
    }, n.unstable_continueExecution = function() {
      L || A || (L = !0, tt(H));
    }, n.unstable_forceFrameRate = function(he) {
      0 > he || 125 < he ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Fe = 0 < he ? Math.floor(1e3 / he) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return _;
    }, n.unstable_getFirstCallbackNode = function() {
      return s(x);
    }, n.unstable_next = function(he) {
      switch (_) {
        case 1:
        case 2:
        case 3:
          var Ce = 3;
          break;
        default:
          Ce = _;
      }
      var ve = _;
      _ = Ce;
      try {
        return he();
      } finally {
        _ = ve;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(he, Ce) {
      switch (he) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          he = 3;
      }
      var ve = _;
      _ = he;
      try {
        return Ce();
      } finally {
        _ = ve;
      }
    }, n.unstable_scheduleCallback = function(he, Ce, ve) {
      var Ae = n.unstable_now();
      switch (typeof ve == "object" && ve !== null ? (ve = ve.delay, ve = typeof ve == "number" && 0 < ve ? Ae + ve : Ae) : ve = Ae, he) {
        case 1:
          var Ye = -1;
          break;
        case 2:
          Ye = 250;
          break;
        case 5:
          Ye = 1073741823;
          break;
        case 4:
          Ye = 1e4;
          break;
        default:
          Ye = 5e3;
      }
      return Ye = ve + Ye, he = { id: w++, callback: Ce, priorityLevel: he, startTime: ve, expirationTime: Ye, sortIndex: -1 }, ve > Ae ? (he.sortIndex = ve, a(E, he), s(x) === null && he === s(E) && ($ ? (K(De), De = -1) : $ = !0, Lt(ne, ve - Ae))) : (he.sortIndex = Ye, a(x, he), L || A || (L = !0, tt(H))), he;
    }, n.unstable_shouldYield = vt, n.unstable_wrapCallback = function(he) {
      var Ce = _;
      return function() {
        var ve = _;
        _ = Ce;
        try {
          return he.apply(this, arguments);
        } finally {
          _ = ve;
        }
      };
    };
  }(gE)), gE;
}
var bE = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZD;
function NV() {
  return ZD || (ZD = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var a = !1, s = !1, c = 5;
      function p(ye, Ue) {
        var ht = ye.length;
        ye.push(Ue), b(ye, Ue, ht);
      }
      function v(ye) {
        return ye.length === 0 ? null : ye[0];
      }
      function h(ye) {
        if (ye.length === 0)
          return null;
        var Ue = ye[0], ht = ye.pop();
        return ht !== Ue && (ye[0] = ht, x(ye, ht, 0)), Ue;
      }
      function b(ye, Ue, ht) {
        for (var Ut = ht; Ut > 0; ) {
          var bn = Ut - 1 >>> 1, pn = ye[bn];
          if (E(pn, Ue) > 0)
            ye[bn] = Ue, ye[Ut] = pn, Ut = bn;
          else
            return;
        }
      }
      function x(ye, Ue, ht) {
        for (var Ut = ht, bn = ye.length, pn = bn >>> 1; Ut < pn; ) {
          var hn = (Ut + 1) * 2 - 1, Ir = ye[hn], Xt = hn + 1, ta = ye[Xt];
          if (E(Ir, Ue) < 0)
            Xt < bn && E(ta, Ir) < 0 ? (ye[Ut] = ta, ye[Xt] = Ue, Ut = Xt) : (ye[Ut] = Ir, ye[hn] = Ue, Ut = hn);
          else if (Xt < bn && E(ta, Ue) < 0)
            ye[Ut] = ta, ye[Xt] = Ue, Ut = Xt;
          else
            return;
        }
      }
      function E(ye, Ue) {
        var ht = ye.sortIndex - Ue.sortIndex;
        return ht !== 0 ? ht : ye.id - Ue.id;
      }
      var w = 1, k = 2, _ = 3, A = 4, L = 5;
      function $(ye, Ue) {
      }
      var Y = typeof performance == "object" && typeof performance.now == "function";
      if (Y) {
        var K = performance;
        n.unstable_now = function() {
          return K.now();
        };
      } else {
        var W = Date, F = W.now();
        n.unstable_now = function() {
          return W.now() - F;
        };
      }
      var ne = 1073741823, H = -1, le = 250, re = 5e3, De = 1e4, Fe = ne, ot = [], vt = [], Rt = 1, $e = null, Be = _, jt = !1, tt = !1, Lt = !1, he = typeof setTimeout == "function" ? setTimeout : null, Ce = typeof clearTimeout == "function" ? clearTimeout : null, ve = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ae(ye) {
        for (var Ue = v(vt); Ue !== null; ) {
          if (Ue.callback === null)
            h(vt);
          else if (Ue.startTime <= ye)
            h(vt), Ue.sortIndex = Ue.expirationTime, p(ot, Ue);
          else
            return;
          Ue = v(vt);
        }
      }
      function Ye(ye) {
        if (Lt = !1, Ae(ye), !tt)
          if (v(ot) !== null)
            tt = !0, Ha(Ke);
          else {
            var Ue = v(vt);
            Ue !== null && Bn(Ye, Ue.startTime - ye);
          }
      }
      function Ke(ye, Ue) {
        tt = !1, Lt && (Lt = !1, mr()), jt = !0;
        var ht = Be;
        try {
          var Ut;
          if (!s)
            return cn(ye, Ue);
        } finally {
          $e = null, Be = ht, jt = !1;
        }
      }
      function cn(ye, Ue) {
        var ht = Ue;
        for (Ae(ht), $e = v(ot); $e !== null && !a && !($e.expirationTime > ht && (!ye || Ua())); ) {
          var Ut = $e.callback;
          if (typeof Ut == "function") {
            $e.callback = null, Be = $e.priorityLevel;
            var bn = $e.expirationTime <= ht, pn = Ut(bn);
            ht = n.unstable_now(), typeof pn == "function" ? $e.callback = pn : $e === v(ot) && h(ot), Ae(ht);
          } else
            h(ot);
          $e = v(ot);
        }
        if ($e !== null)
          return !0;
        var hn = v(vt);
        return hn !== null && Bn(Ye, hn.startTime - ht), !1;
      }
      function Vn(ye, Ue) {
        switch (ye) {
          case w:
          case k:
          case _:
          case A:
          case L:
            break;
          default:
            ye = _;
        }
        var ht = Be;
        Be = ye;
        try {
          return Ue();
        } finally {
          Be = ht;
        }
      }
      function bt(ye) {
        var Ue;
        switch (Be) {
          case w:
          case k:
          case _:
            Ue = _;
            break;
          default:
            Ue = Be;
            break;
        }
        var ht = Be;
        Be = Ue;
        try {
          return ye();
        } finally {
          Be = ht;
        }
      }
      function yn(ye) {
        var Ue = Be;
        return function() {
          var ht = Be;
          Be = Ue;
          try {
            return ye.apply(this, arguments);
          } finally {
            Be = ht;
          }
        };
      }
      function Ot(ye, Ue, ht) {
        var Ut = n.unstable_now(), bn;
        if (typeof ht == "object" && ht !== null) {
          var pn = ht.delay;
          typeof pn == "number" && pn > 0 ? bn = Ut + pn : bn = Ut;
        } else
          bn = Ut;
        var hn;
        switch (ye) {
          case w:
            hn = H;
            break;
          case k:
            hn = le;
            break;
          case L:
            hn = Fe;
            break;
          case A:
            hn = De;
            break;
          case _:
          default:
            hn = re;
            break;
        }
        var Ir = bn + hn, Xt = {
          id: Rt++,
          callback: Ue,
          priorityLevel: ye,
          startTime: bn,
          expirationTime: Ir,
          sortIndex: -1
        };
        return bn > Ut ? (Xt.sortIndex = bn, p(vt, Xt), v(ot) === null && Xt === v(vt) && (Lt ? mr() : Lt = !0, Bn(Ye, bn - Ut))) : (Xt.sortIndex = Ir, p(ot, Xt), !tt && !jt && (tt = !0, Ha(Ke))), Xt;
      }
      function Bt() {
      }
      function gn() {
        !tt && !jt && (tt = !0, Ha(Ke));
      }
      function $t() {
        return v(ot);
      }
      function ge(ye) {
        ye.callback = null;
      }
      function kn() {
        return Be;
      }
      var Mn = !1, jn = null, pr = -1, hr = c, ba = -1;
      function Ua() {
        var ye = n.unstable_now() - ba;
        return !(ye < hr);
      }
      function Sa() {
      }
      function xa(ye) {
        if (ye < 0 || ye > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ye > 0 ? hr = Math.floor(1e3 / ye) : hr = c;
      }
      var Br = function() {
        if (jn !== null) {
          var ye = n.unstable_now();
          ba = ye;
          var Ue = !0, ht = !0;
          try {
            ht = jn(Ue, ye);
          } finally {
            ht ? On() : (Mn = !1, jn = null);
          }
        } else
          Mn = !1;
      }, On;
      if (typeof ve == "function")
        On = function() {
          ve(Br);
        };
      else if (typeof MessageChannel < "u") {
        var Ia = new MessageChannel(), Ur = Ia.port2;
        Ia.port1.onmessage = Br, On = function() {
          Ur.postMessage(null);
        };
      } else
        On = function() {
          he(Br, 0);
        };
      function Ha(ye) {
        jn = ye, Mn || (Mn = !0, On());
      }
      function Bn(ye, Ue) {
        pr = he(function() {
          ye(n.unstable_now());
        }, Ue);
      }
      function mr() {
        Ce(pr), pr = -1;
      }
      var zi = Sa, Ca = null;
      n.unstable_IdlePriority = L, n.unstable_ImmediatePriority = w, n.unstable_LowPriority = A, n.unstable_NormalPriority = _, n.unstable_Profiling = Ca, n.unstable_UserBlockingPriority = k, n.unstable_cancelCallback = ge, n.unstable_continueExecution = gn, n.unstable_forceFrameRate = xa, n.unstable_getCurrentPriorityLevel = kn, n.unstable_getFirstCallbackNode = $t, n.unstable_next = bt, n.unstable_pauseExecution = Bt, n.unstable_requestPaint = zi, n.unstable_runWithPriority = Vn, n.unstable_scheduleCallback = Ot, n.unstable_shouldYield = Ua, n.unstable_wrapCallback = yn, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(bE)), bE;
}
var JD;
function tO() {
  return JD || (JD = 1, process.env.NODE_ENV === "production" ? mb.exports = $V() : mb.exports = NV()), mb.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e2;
function FV() {
  if (e2)
    return Ri;
  e2 = 1;
  var n = qi, a = tO();
  function s(r) {
    for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + r, u = 1; u < arguments.length; u++)
      i += "&args[]=" + encodeURIComponent(arguments[u]);
    return "Minified React error #" + r + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var c = /* @__PURE__ */ new Set(), p = {};
  function v(r, i) {
    h(r, i), h(r + "Capture", i);
  }
  function h(r, i) {
    for (p[r] = i, r = 0; r < i.length; r++)
      c.add(i[r]);
  }
  var b = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), x = Object.prototype.hasOwnProperty, E = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, w = {}, k = {};
  function _(r) {
    return x.call(k, r) ? !0 : x.call(w, r) ? !1 : E.test(r) ? k[r] = !0 : (w[r] = !0, !1);
  }
  function A(r, i, u, d) {
    if (u !== null && u.type === 0)
      return !1;
    switch (typeof i) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return d ? !1 : u !== null ? !u.acceptsBooleans : (r = r.toLowerCase().slice(0, 5), r !== "data-" && r !== "aria-");
      default:
        return !1;
    }
  }
  function L(r, i, u, d) {
    if (i === null || typeof i > "u" || A(r, i, u, d))
      return !0;
    if (d)
      return !1;
    if (u !== null)
      switch (u.type) {
        case 3:
          return !i;
        case 4:
          return i === !1;
        case 5:
          return isNaN(i);
        case 6:
          return isNaN(i) || 1 > i;
      }
    return !1;
  }
  function $(r, i, u, d, y, S, R) {
    this.acceptsBooleans = i === 2 || i === 3 || i === 4, this.attributeName = d, this.attributeNamespace = y, this.mustUseProperty = u, this.propertyName = r, this.type = i, this.sanitizeURL = S, this.removeEmptyString = R;
  }
  var Y = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(r) {
    Y[r] = new $(r, 0, !1, r, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(r) {
    var i = r[0];
    Y[i] = new $(i, 1, !1, r[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(r) {
    Y[r] = new $(r, 2, !1, r.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(r) {
    Y[r] = new $(r, 2, !1, r, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(r) {
    Y[r] = new $(r, 3, !1, r.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(r) {
    Y[r] = new $(r, 3, !0, r, null, !1, !1);
  }), ["capture", "download"].forEach(function(r) {
    Y[r] = new $(r, 4, !1, r, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(r) {
    Y[r] = new $(r, 6, !1, r, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(r) {
    Y[r] = new $(r, 5, !1, r.toLowerCase(), null, !1, !1);
  });
  var K = /[\-:]([a-z])/g;
  function W(r) {
    return r[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(r) {
    var i = r.replace(
      K,
      W
    );
    Y[i] = new $(i, 1, !1, r, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(r) {
    var i = r.replace(K, W);
    Y[i] = new $(i, 1, !1, r, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(r) {
    var i = r.replace(K, W);
    Y[i] = new $(i, 1, !1, r, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(r) {
    Y[r] = new $(r, 1, !1, r.toLowerCase(), null, !1, !1);
  }), Y.xlinkHref = new $("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(r) {
    Y[r] = new $(r, 1, !1, r.toLowerCase(), null, !0, !0);
  });
  function F(r, i, u, d) {
    var y = Y.hasOwnProperty(i) ? Y[i] : null;
    (y !== null ? y.type !== 0 : d || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (L(i, u, y, d) && (u = null), d || y === null ? _(i) && (u === null ? r.removeAttribute(i) : r.setAttribute(i, "" + u)) : y.mustUseProperty ? r[y.propertyName] = u === null ? y.type === 3 ? !1 : "" : u : (i = y.attributeName, d = y.attributeNamespace, u === null ? r.removeAttribute(i) : (y = y.type, u = y === 3 || y === 4 && u === !0 ? "" : "" + u, d ? r.setAttributeNS(d, i, u) : r.setAttribute(i, u))));
  }
  var ne = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, H = Symbol.for("react.element"), le = Symbol.for("react.portal"), re = Symbol.for("react.fragment"), De = Symbol.for("react.strict_mode"), Fe = Symbol.for("react.profiler"), ot = Symbol.for("react.provider"), vt = Symbol.for("react.context"), Rt = Symbol.for("react.forward_ref"), $e = Symbol.for("react.suspense"), Be = Symbol.for("react.suspense_list"), jt = Symbol.for("react.memo"), tt = Symbol.for("react.lazy"), Lt = Symbol.for("react.offscreen"), he = Symbol.iterator;
  function Ce(r) {
    return r === null || typeof r != "object" ? null : (r = he && r[he] || r["@@iterator"], typeof r == "function" ? r : null);
  }
  var ve = Object.assign, Ae;
  function Ye(r) {
    if (Ae === void 0)
      try {
        throw Error();
      } catch (u) {
        var i = u.stack.trim().match(/\n( *(at )?)/);
        Ae = i && i[1] || "";
      }
    return `
` + Ae + r;
  }
  var Ke = !1;
  function cn(r, i) {
    if (!r || Ke)
      return "";
    Ke = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (i)
        if (i = function() {
          throw Error();
        }, Object.defineProperty(i.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(i, []);
          } catch (te) {
            var d = te;
          }
          Reflect.construct(r, [], i);
        } else {
          try {
            i.call();
          } catch (te) {
            d = te;
          }
          r.call(i.prototype);
        }
      else {
        try {
          throw Error();
        } catch (te) {
          d = te;
        }
        r();
      }
    } catch (te) {
      if (te && d && typeof te.stack == "string") {
        for (var y = te.stack.split(`
`), S = d.stack.split(`
`), R = y.length - 1, z = S.length - 1; 1 <= R && 0 <= z && y[R] !== S[z]; )
          z--;
        for (; 1 <= R && 0 <= z; R--, z--)
          if (y[R] !== S[z]) {
            if (R !== 1 || z !== 1)
              do
                if (R--, z--, 0 > z || y[R] !== S[z]) {
                  var N = `
` + y[R].replace(" at new ", " at ");
                  return r.displayName && N.includes("<anonymous>") && (N = N.replace("<anonymous>", r.displayName)), N;
                }
              while (1 <= R && 0 <= z);
            break;
          }
      }
    } finally {
      Ke = !1, Error.prepareStackTrace = u;
    }
    return (r = r ? r.displayName || r.name : "") ? Ye(r) : "";
  }
  function Vn(r) {
    switch (r.tag) {
      case 5:
        return Ye(r.type);
      case 16:
        return Ye("Lazy");
      case 13:
        return Ye("Suspense");
      case 19:
        return Ye("SuspenseList");
      case 0:
      case 2:
      case 15:
        return r = cn(r.type, !1), r;
      case 11:
        return r = cn(r.type.render, !1), r;
      case 1:
        return r = cn(r.type, !0), r;
      default:
        return "";
    }
  }
  function bt(r) {
    if (r == null)
      return null;
    if (typeof r == "function")
      return r.displayName || r.name || null;
    if (typeof r == "string")
      return r;
    switch (r) {
      case re:
        return "Fragment";
      case le:
        return "Portal";
      case Fe:
        return "Profiler";
      case De:
        return "StrictMode";
      case $e:
        return "Suspense";
      case Be:
        return "SuspenseList";
    }
    if (typeof r == "object")
      switch (r.$$typeof) {
        case vt:
          return (r.displayName || "Context") + ".Consumer";
        case ot:
          return (r._context.displayName || "Context") + ".Provider";
        case Rt:
          var i = r.render;
          return r = r.displayName, r || (r = i.displayName || i.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case jt:
          return i = r.displayName || null, i !== null ? i : bt(r.type) || "Memo";
        case tt:
          i = r._payload, r = r._init;
          try {
            return bt(r(i));
          } catch {
          }
      }
    return null;
  }
  function yn(r) {
    var i = r.type;
    switch (r.tag) {
      case 24:
        return "Cache";
      case 9:
        return (i.displayName || "Context") + ".Consumer";
      case 10:
        return (i._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return r = i.render, r = r.displayName || r.name || "", i.displayName || (r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return i;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return bt(i);
      case 8:
        return i === De ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof i == "function")
          return i.displayName || i.name || null;
        if (typeof i == "string")
          return i;
    }
    return null;
  }
  function Ot(r) {
    switch (typeof r) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function Bt(r) {
    var i = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function gn(r) {
    var i = Bt(r) ? "checked" : "value", u = Object.getOwnPropertyDescriptor(r.constructor.prototype, i), d = "" + r[i];
    if (!r.hasOwnProperty(i) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var y = u.get, S = u.set;
      return Object.defineProperty(r, i, { configurable: !0, get: function() {
        return y.call(this);
      }, set: function(R) {
        d = "" + R, S.call(this, R);
      } }), Object.defineProperty(r, i, { enumerable: u.enumerable }), { getValue: function() {
        return d;
      }, setValue: function(R) {
        d = "" + R;
      }, stopTracking: function() {
        r._valueTracker = null, delete r[i];
      } };
    }
  }
  function $t(r) {
    r._valueTracker || (r._valueTracker = gn(r));
  }
  function ge(r) {
    if (!r)
      return !1;
    var i = r._valueTracker;
    if (!i)
      return !0;
    var u = i.getValue(), d = "";
    return r && (d = Bt(r) ? r.checked ? "true" : "false" : r.value), r = d, r !== u ? (i.setValue(r), !0) : !1;
  }
  function kn(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u")
      return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  function Mn(r, i) {
    var u = i.checked;
    return ve({}, i, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: u ?? r._wrapperState.initialChecked });
  }
  function jn(r, i) {
    var u = i.defaultValue == null ? "" : i.defaultValue, d = i.checked != null ? i.checked : i.defaultChecked;
    u = Ot(i.value != null ? i.value : u), r._wrapperState = { initialChecked: d, initialValue: u, controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null };
  }
  function pr(r, i) {
    i = i.checked, i != null && F(r, "checked", i, !1);
  }
  function hr(r, i) {
    pr(r, i);
    var u = Ot(i.value), d = i.type;
    if (u != null)
      d === "number" ? (u === 0 && r.value === "" || r.value != u) && (r.value = "" + u) : r.value !== "" + u && (r.value = "" + u);
    else if (d === "submit" || d === "reset") {
      r.removeAttribute("value");
      return;
    }
    i.hasOwnProperty("value") ? Ua(r, i.type, u) : i.hasOwnProperty("defaultValue") && Ua(r, i.type, Ot(i.defaultValue)), i.checked == null && i.defaultChecked != null && (r.defaultChecked = !!i.defaultChecked);
  }
  function ba(r, i, u) {
    if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
      var d = i.type;
      if (!(d !== "submit" && d !== "reset" || i.value !== void 0 && i.value !== null))
        return;
      i = "" + r._wrapperState.initialValue, u || i === r.value || (r.value = i), r.defaultValue = i;
    }
    u = r.name, u !== "" && (r.name = ""), r.defaultChecked = !!r._wrapperState.initialChecked, u !== "" && (r.name = u);
  }
  function Ua(r, i, u) {
    (i !== "number" || kn(r.ownerDocument) !== r) && (u == null ? r.defaultValue = "" + r._wrapperState.initialValue : r.defaultValue !== "" + u && (r.defaultValue = "" + u));
  }
  var Sa = Array.isArray;
  function xa(r, i, u, d) {
    if (r = r.options, i) {
      i = {};
      for (var y = 0; y < u.length; y++)
        i["$" + u[y]] = !0;
      for (u = 0; u < r.length; u++)
        y = i.hasOwnProperty("$" + r[u].value), r[u].selected !== y && (r[u].selected = y), y && d && (r[u].defaultSelected = !0);
    } else {
      for (u = "" + Ot(u), i = null, y = 0; y < r.length; y++) {
        if (r[y].value === u) {
          r[y].selected = !0, d && (r[y].defaultSelected = !0);
          return;
        }
        i !== null || r[y].disabled || (i = r[y]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function Br(r, i) {
    if (i.dangerouslySetInnerHTML != null)
      throw Error(s(91));
    return ve({}, i, { value: void 0, defaultValue: void 0, children: "" + r._wrapperState.initialValue });
  }
  function On(r, i) {
    var u = i.value;
    if (u == null) {
      if (u = i.children, i = i.defaultValue, u != null) {
        if (i != null)
          throw Error(s(92));
        if (Sa(u)) {
          if (1 < u.length)
            throw Error(s(93));
          u = u[0];
        }
        i = u;
      }
      i == null && (i = ""), u = i;
    }
    r._wrapperState = { initialValue: Ot(u) };
  }
  function Ia(r, i) {
    var u = Ot(i.value), d = Ot(i.defaultValue);
    u != null && (u = "" + u, u !== r.value && (r.value = u), i.defaultValue == null && r.defaultValue !== u && (r.defaultValue = u)), d != null && (r.defaultValue = "" + d);
  }
  function Ur(r) {
    var i = r.textContent;
    i === r._wrapperState.initialValue && i !== "" && i !== null && (r.value = i);
  }
  function Ha(r) {
    switch (r) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Bn(r, i) {
    return r == null || r === "http://www.w3.org/1999/xhtml" ? Ha(i) : r === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : r;
  }
  var mr, zi = function(r) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, u, d, y) {
      MSApp.execUnsafeLocalFunction(function() {
        return r(i, u, d, y);
      });
    } : r;
  }(function(r, i) {
    if (r.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in r)
      r.innerHTML = i;
    else {
      for (mr = mr || document.createElement("div"), mr.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>", i = mr.firstChild; r.firstChild; )
        r.removeChild(r.firstChild);
      for (; i.firstChild; )
        r.appendChild(i.firstChild);
    }
  });
  function Ca(r, i) {
    if (i) {
      var u = r.firstChild;
      if (u && u === r.lastChild && u.nodeType === 3) {
        u.nodeValue = i;
        return;
      }
    }
    r.textContent = i;
  }
  var ye = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Ue = ["Webkit", "ms", "Moz", "O"];
  Object.keys(ye).forEach(function(r) {
    Ue.forEach(function(i) {
      i = i + r.charAt(0).toUpperCase() + r.substring(1), ye[i] = ye[r];
    });
  });
  function ht(r, i, u) {
    return i == null || typeof i == "boolean" || i === "" ? "" : u || typeof i != "number" || i === 0 || ye.hasOwnProperty(r) && ye[r] ? ("" + i).trim() : i + "px";
  }
  function Ut(r, i) {
    r = r.style;
    for (var u in i)
      if (i.hasOwnProperty(u)) {
        var d = u.indexOf("--") === 0, y = ht(u, i[u], d);
        u === "float" && (u = "cssFloat"), d ? r.setProperty(u, y) : r[u] = y;
      }
  }
  var bn = ve({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function pn(r, i) {
    if (i) {
      if (bn[r] && (i.children != null || i.dangerouslySetInnerHTML != null))
        throw Error(s(137, r));
      if (i.dangerouslySetInnerHTML != null) {
        if (i.children != null)
          throw Error(s(60));
        if (typeof i.dangerouslySetInnerHTML != "object" || !("__html" in i.dangerouslySetInnerHTML))
          throw Error(s(61));
      }
      if (i.style != null && typeof i.style != "object")
        throw Error(s(62));
    }
  }
  function hn(r, i) {
    if (r.indexOf("-") === -1)
      return typeof i.is == "string";
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Ir = null;
  function Xt(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
  }
  var ta = null, Gt = null, Nt = null;
  function ss(r) {
    if (r = $c(r)) {
      if (typeof ta != "function")
        throw Error(s(280));
      var i = r.stateNode;
      i && (i = We(i), ta(r.stateNode, r.type, i));
    }
  }
  function na(r) {
    Gt ? Nt ? Nt.push(r) : Nt = [r] : Gt = r;
  }
  function ls() {
    if (Gt) {
      var r = Gt, i = Nt;
      if (Nt = Gt = null, ss(r), i)
        for (r = 0; r < i.length; r++)
          ss(i[r]);
    }
  }
  function Xs(r, i) {
    return r(i);
  }
  function tu() {
  }
  var Co = !1;
  function us(r, i, u) {
    if (Co)
      return r(i, u);
    Co = !0;
    try {
      return Xs(r, i, u);
    } finally {
      Co = !1, (Gt !== null || Nt !== null) && (tu(), ls());
    }
  }
  function kr(r, i) {
    var u = r.stateNode;
    if (u === null)
      return null;
    var d = We(u);
    if (d === null)
      return null;
    u = d[i];
    e:
      switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (r = r.type, d = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !d;
          break e;
        default:
          r = !1;
      }
    if (r)
      return null;
    if (u && typeof u != "function")
      throw Error(s(231, i, typeof u));
    return u;
  }
  var cs = !1;
  if (b)
    try {
      var si = {};
      Object.defineProperty(si, "passive", { get: function() {
        cs = !0;
      } }), window.addEventListener("test", si, si), window.removeEventListener("test", si, si);
    } catch {
      cs = !1;
    }
  function Zi(r, i, u, d, y, S, R, z, N) {
    var te = Array.prototype.slice.call(arguments, 3);
    try {
      i.apply(u, te);
    } catch (fe) {
      this.onError(fe);
    }
  }
  var ra = !1, Wa = null, aa = !1, P = null, ce = { onError: function(r) {
    ra = !0, Wa = r;
  } };
  function be(r, i, u, d, y, S, R, z, N) {
    ra = !1, Wa = null, Zi.apply(ce, arguments);
  }
  function He(r, i, u, d, y, S, R, z, N) {
    if (be.apply(this, arguments), ra) {
      if (ra) {
        var te = Wa;
        ra = !1, Wa = null;
      } else
        throw Error(s(198));
      aa || (aa = !0, P = te);
    }
  }
  function ct(r) {
    var i = r, u = r;
    if (r.alternate)
      for (; i.return; )
        i = i.return;
    else {
      r = i;
      do
        i = r, i.flags & 4098 && (u = i.return), r = i.return;
      while (r);
    }
    return i.tag === 3 ? u : null;
  }
  function gt(r) {
    if (r.tag === 13) {
      var i = r.memoizedState;
      if (i === null && (r = r.alternate, r !== null && (i = r.memoizedState)), i !== null)
        return i.dehydrated;
    }
    return null;
  }
  function ft(r) {
    if (ct(r) !== r)
      throw Error(s(188));
  }
  function Ge(r) {
    var i = r.alternate;
    if (!i) {
      if (i = ct(r), i === null)
        throw Error(s(188));
      return i !== r ? null : r;
    }
    for (var u = r, d = i; ; ) {
      var y = u.return;
      if (y === null)
        break;
      var S = y.alternate;
      if (S === null) {
        if (d = y.return, d !== null) {
          u = d;
          continue;
        }
        break;
      }
      if (y.child === S.child) {
        for (S = y.child; S; ) {
          if (S === u)
            return ft(y), r;
          if (S === d)
            return ft(y), i;
          S = S.sibling;
        }
        throw Error(s(188));
      }
      if (u.return !== d.return)
        u = y, d = S;
      else {
        for (var R = !1, z = y.child; z; ) {
          if (z === u) {
            R = !0, u = y, d = S;
            break;
          }
          if (z === d) {
            R = !0, d = y, u = S;
            break;
          }
          z = z.sibling;
        }
        if (!R) {
          for (z = S.child; z; ) {
            if (z === u) {
              R = !0, u = S, d = y;
              break;
            }
            if (z === d) {
              R = !0, d = S, u = y;
              break;
            }
            z = z.sibling;
          }
          if (!R)
            throw Error(s(189));
        }
      }
      if (u.alternate !== d)
        throw Error(s(190));
    }
    if (u.tag !== 3)
      throw Error(s(188));
    return u.stateNode.current === u ? r : i;
  }
  function Xn(r) {
    return r = Ge(r), r !== null ? mn(r) : null;
  }
  function mn(r) {
    if (r.tag === 5 || r.tag === 6)
      return r;
    for (r = r.child; r !== null; ) {
      var i = mn(r);
      if (i !== null)
        return i;
      r = r.sibling;
    }
    return null;
  }
  var vn = a.unstable_scheduleCallback, Rr = a.unstable_cancelCallback, li = a.unstable_shouldYield, nu = a.unstable_requestPaint, Et = a.unstable_now, yc = a.unstable_getCurrentPriorityLevel, Pi = a.unstable_ImmediatePriority, mt = a.unstable_UserBlockingPriority, Li = a.unstable_NormalPriority, Hf = a.unstable_LowPriority, gc = a.unstable_IdlePriority, Zs = null, Ea = null;
  function Wf(r) {
    if (Ea && typeof Ea.onCommitFiberRoot == "function")
      try {
        Ea.onCommitFiberRoot(Zs, r, void 0, (r.current.flags & 128) === 128);
      } catch {
      }
  }
  var wa = Math.clz32 ? Math.clz32 : vh, Yf = Math.log, Gf = Math.LN2;
  function vh(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (Yf(r) / Gf | 0) | 0;
  }
  var ru = 64, fs = 4194304;
  function Eo(r) {
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return r & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return r;
    }
  }
  function Ya(r, i) {
    var u = r.pendingLanes;
    if (u === 0)
      return 0;
    var d = 0, y = r.suspendedLanes, S = r.pingedLanes, R = u & 268435455;
    if (R !== 0) {
      var z = R & ~y;
      z !== 0 ? d = Eo(z) : (S &= R, S !== 0 && (d = Eo(S)));
    } else
      R = u & ~y, R !== 0 ? d = Eo(R) : S !== 0 && (d = Eo(S));
    if (d === 0)
      return 0;
    if (i !== 0 && i !== d && !(i & y) && (y = d & -d, S = i & -i, y >= S || y === 16 && (S & 4194240) !== 0))
      return i;
    if (d & 4 && (d |= u & 16), i = r.entangledLanes, i !== 0)
      for (r = r.entanglements, i &= d; 0 < i; )
        u = 31 - wa(i), y = 1 << u, d |= r[u], i &= ~y;
    return d;
  }
  function bc(r, i) {
    switch (r) {
      case 1:
      case 2:
      case 4:
        return i + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wo(r, i) {
    for (var u = r.suspendedLanes, d = r.pingedLanes, y = r.expirationTimes, S = r.pendingLanes; 0 < S; ) {
      var R = 31 - wa(S), z = 1 << R, N = y[R];
      N === -1 ? (!(z & u) || z & d) && (y[R] = bc(z, i)) : N <= i && (r.expiredLanes |= z), S &= ~z;
    }
  }
  function Js(r) {
    return r = r.pendingLanes & -1073741825, r !== 0 ? r : r & 1073741824 ? 1073741824 : 0;
  }
  function au() {
    var r = ru;
    return ru <<= 1, !(ru & 4194240) && (ru = 64), r;
  }
  function Sc(r) {
    for (var i = [], u = 0; 31 > u; u++)
      i.push(r);
    return i;
  }
  function Ji(r, i, u) {
    r.pendingLanes |= i, i !== 536870912 && (r.suspendedLanes = 0, r.pingedLanes = 0), r = r.eventTimes, i = 31 - wa(i), r[i] = u;
  }
  function yh(r, i) {
    var u = r.pendingLanes & ~i;
    r.pendingLanes = i, r.suspendedLanes = 0, r.pingedLanes = 0, r.expiredLanes &= i, r.mutableReadLanes &= i, r.entangledLanes &= i, i = r.entanglements;
    var d = r.eventTimes;
    for (r = r.expirationTimes; 0 < u; ) {
      var y = 31 - wa(u), S = 1 << y;
      i[y] = 0, d[y] = -1, r[y] = -1, u &= ~S;
    }
  }
  function el(r, i) {
    var u = r.entangledLanes |= i;
    for (r = r.entanglements; u; ) {
      var d = 31 - wa(u), y = 1 << d;
      y & i | r[d] & i && (r[d] |= i), u &= ~y;
    }
  }
  var It = 0;
  function iu(r) {
    return r &= -r, 1 < r ? 4 < r ? r & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var qf, ou, Zt, su, xc, st = !1, tl = [], Sn = null, Hr = null, Wr = null, To = /* @__PURE__ */ new Map(), Yn = /* @__PURE__ */ new Map(), Ht = [], Cc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ta(r, i) {
    switch (r) {
      case "focusin":
      case "focusout":
        Sn = null;
        break;
      case "dragenter":
      case "dragleave":
        Hr = null;
        break;
      case "mouseover":
      case "mouseout":
        Wr = null;
        break;
      case "pointerover":
      case "pointerout":
        To.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Yn.delete(i.pointerId);
    }
  }
  function Rn(r, i, u, d, y, S) {
    return r === null || r.nativeEvent !== S ? (r = { blockedOn: i, domEventName: u, eventSystemFlags: d, nativeEvent: S, targetContainers: [y] }, i !== null && (i = $c(i), i !== null && ou(i)), r) : (r.eventSystemFlags |= d, i = r.targetContainers, y !== null && i.indexOf(y) === -1 && i.push(y), r);
  }
  function ka(r, i, u, d, y) {
    switch (i) {
      case "focusin":
        return Sn = Rn(Sn, r, i, u, d, y), !0;
      case "dragenter":
        return Hr = Rn(Hr, r, i, u, d, y), !0;
      case "mouseover":
        return Wr = Rn(Wr, r, i, u, d, y), !0;
      case "pointerover":
        var S = y.pointerId;
        return To.set(S, Rn(To.get(S) || null, r, i, u, d, y)), !0;
      case "gotpointercapture":
        return S = y.pointerId, Yn.set(S, Rn(Yn.get(S) || null, r, i, u, d, y)), !0;
    }
    return !1;
  }
  function Qf(r) {
    var i = ci(r.target);
    if (i !== null) {
      var u = ct(i);
      if (u !== null) {
        if (i = u.tag, i === 13) {
          if (i = gt(u), i !== null) {
            r.blockedOn = i, xc(r.priority, function() {
              Zt(u);
            });
            return;
          }
        } else if (i === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function ko(r) {
    if (r.blockedOn !== null)
      return !1;
    for (var i = r.targetContainers; 0 < i.length; ) {
      var u = St(r.domEventName, r.eventSystemFlags, i[0], r.nativeEvent);
      if (u === null) {
        u = r.nativeEvent;
        var d = new u.constructor(u.type, u);
        Ir = d, u.target.dispatchEvent(d), Ir = null;
      } else
        return i = $c(u), i !== null && ou(i), r.blockedOn = u, !1;
      i.shift();
    }
    return !0;
  }
  function Ec(r, i, u) {
    ko(r) && u.delete(i);
  }
  function wc() {
    st = !1, Sn !== null && ko(Sn) && (Sn = null), Hr !== null && ko(Hr) && (Hr = null), Wr !== null && ko(Wr) && (Wr = null), To.forEach(Ec), Yn.forEach(Ec);
  }
  function nl(r, i) {
    r.blockedOn === i && (r.blockedOn = null, st || (st = !0, a.unstable_scheduleCallback(a.unstable_NormalPriority, wc)));
  }
  function rl(r) {
    function i(y) {
      return nl(y, r);
    }
    if (0 < tl.length) {
      nl(tl[0], r);
      for (var u = 1; u < tl.length; u++) {
        var d = tl[u];
        d.blockedOn === r && (d.blockedOn = null);
      }
    }
    for (Sn !== null && nl(Sn, r), Hr !== null && nl(Hr, r), Wr !== null && nl(Wr, r), To.forEach(i), Yn.forEach(i), u = 0; u < Ht.length; u++)
      d = Ht[u], d.blockedOn === r && (d.blockedOn = null);
    for (; 0 < Ht.length && (u = Ht[0], u.blockedOn === null); )
      Qf(u), u.blockedOn === null && Ht.shift();
  }
  var Ro = ne.ReactCurrentBatchConfig, _o = !0;
  function O(r, i, u, d) {
    var y = It, S = Ro.transition;
    Ro.transition = null;
    try {
      It = 1, ee(r, i, u, d);
    } finally {
      It = y, Ro.transition = S;
    }
  }
  function j(r, i, u, d) {
    var y = It, S = Ro.transition;
    Ro.transition = null;
    try {
      It = 4, ee(r, i, u, d);
    } finally {
      It = y, Ro.transition = S;
    }
  }
  function ee(r, i, u, d) {
    if (_o) {
      var y = St(r, i, u, d);
      if (y === null)
        sd(r, i, d, Ee, u), Ta(r, d);
      else if (ka(y, r, i, u, d))
        d.stopPropagation();
      else if (Ta(r, d), i & 4 && -1 < Cc.indexOf(r)) {
        for (; y !== null; ) {
          var S = $c(y);
          if (S !== null && qf(S), S = St(r, i, u, d), S === null && sd(r, i, d, Ee, u), S === y)
            break;
          y = S;
        }
        y !== null && d.stopPropagation();
      } else
        sd(r, i, d, null, u);
    }
  }
  var Ee = null;
  function St(r, i, u, d) {
    if (Ee = null, r = Xt(d), r = ci(r), r !== null)
      if (i = ct(r), i === null)
        r = null;
      else if (u = i.tag, u === 13) {
        if (r = gt(i), r !== null)
          return r;
        r = null;
      } else if (u === 3) {
        if (i.stateNode.current.memoizedState.isDehydrated)
          return i.tag === 3 ? i.stateNode.containerInfo : null;
        r = null;
      } else
        i !== r && (r = null);
    return Ee = r, null;
  }
  function Wt(r) {
    switch (r) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (yc()) {
          case Pi:
            return 1;
          case mt:
            return 4;
          case Li:
          case Hf:
            return 16;
          case gc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Mt = null, yt = null, qt = null;
  function Yr() {
    if (qt)
      return qt;
    var r, i = yt, u = i.length, d, y = "value" in Mt ? Mt.value : Mt.textContent, S = y.length;
    for (r = 0; r < u && i[r] === y[r]; r++)
      ;
    var R = u - r;
    for (d = 1; d <= R && i[u - d] === y[S - d]; d++)
      ;
    return qt = y.slice(r, 1 < d ? 1 - d : void 0);
  }
  function Zn(r) {
    var i = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && i === 13 && (r = 13)) : r = i, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
  }
  function $i() {
    return !0;
  }
  function lu() {
    return !1;
  }
  function _r(r) {
    function i(u, d, y, S, R) {
      this._reactName = u, this._targetInst = y, this.type = d, this.nativeEvent = S, this.target = R, this.currentTarget = null;
      for (var z in r)
        r.hasOwnProperty(z) && (u = r[z], this[z] = u ? u(S) : S[z]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? $i : lu, this.isPropagationStopped = lu, this;
    }
    return ve(i.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var u = this.nativeEvent;
      u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = $i);
    }, stopPropagation: function() {
      var u = this.nativeEvent;
      u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = $i);
    }, persist: function() {
    }, isPersistent: $i }), i;
  }
  var Ni = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(r) {
    return r.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Kf = _r(Ni), uu = ve({}, Ni, { view: 0, detail: 0 }), Sy = _r(uu), Xf, gh, Tc, vr = ve({}, uu, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ch, button: 0, buttons: 0, relatedTarget: function(r) {
    return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
  }, movementX: function(r) {
    return "movementX" in r ? r.movementX : (r !== Tc && (Tc && r.type === "mousemove" ? (Xf = r.screenX - Tc.screenX, gh = r.screenY - Tc.screenY) : gh = Xf = 0, Tc = r), Xf);
  }, movementY: function(r) {
    return "movementY" in r ? r.movementY : gh;
  } }), Zf = _r(vr), xy = ve({}, vr, { dataTransfer: 0 }), Cy = _r(xy), jS = ve({}, uu, { relatedTarget: 0 }), ds = _r(jS), bh = ve({}, Ni, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Ey = _r(bh), BS = ve({}, Ni, { clipboardData: function(r) {
    return "clipboardData" in r ? r.clipboardData : window.clipboardData;
  } }), US = _r(BS), IS = ve({}, Ni, { data: 0 }), Sh = _r(IS), xh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, wy = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Ty = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function ky(r) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(r) : (r = Ty[r]) ? !!i[r] : !1;
  }
  function Ch() {
    return ky;
  }
  var Do = ve({}, uu, { key: function(r) {
    if (r.key) {
      var i = xh[r.key] || r.key;
      if (i !== "Unidentified")
        return i;
    }
    return r.type === "keypress" ? (r = Zn(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? wy[r.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ch, charCode: function(r) {
    return r.type === "keypress" ? Zn(r) : 0;
  }, keyCode: function(r) {
    return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
  }, which: function(r) {
    return r.type === "keypress" ? Zn(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
  } }), HS = _r(Do), Eh = ve({}, vr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Jf = _r(Eh), wh = ve({}, uu, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ch }), WS = _r(wh), ed = ve({}, Ni, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ry = _r(ed), Ra = ve({}, vr, {
    deltaX: function(r) {
      return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
    },
    deltaY: function(r) {
      return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Ao = _r(Ra), Jn = [9, 13, 27, 32], Fi = b && "CompositionEvent" in window, al = null;
  b && "documentMode" in document && (al = document.documentMode);
  var td = b && "TextEvent" in window && !al, _y = b && (!Fi || al && 8 < al && 11 >= al), cu = " ", Dy = !1;
  function Ay(r, i) {
    switch (r) {
      case "keyup":
        return Jn.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function nd(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
  }
  var fu = !1;
  function YS(r, i) {
    switch (r) {
      case "compositionend":
        return nd(i);
      case "keypress":
        return i.which !== 32 ? null : (Dy = !0, cu);
      case "textInput":
        return r = i.data, r === cu && Dy ? null : r;
      default:
        return null;
    }
  }
  function GS(r, i) {
    if (fu)
      return r === "compositionend" || !Fi && Ay(r, i) ? (r = Yr(), qt = yt = Mt = null, fu = !1, r) : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which)
            return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return _y && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var My = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Oy(r) {
    var i = r && r.nodeName && r.nodeName.toLowerCase();
    return i === "input" ? !!My[r.type] : i === "textarea";
  }
  function zy(r, i, u, d) {
    na(d), i = zc(i, "onChange"), 0 < i.length && (u = new Kf("onChange", "change", null, u, d), r.push({ event: u, listeners: i }));
  }
  var kc = null, du = null;
  function pu(r) {
    od(r, 0);
  }
  function hu(r) {
    var i = vu(r);
    if (ge(i))
      return r;
  }
  function Py(r, i) {
    if (r === "change")
      return i;
  }
  var Th = !1;
  if (b) {
    var kh;
    if (b) {
      var Rh = "oninput" in document;
      if (!Rh) {
        var Ly = document.createElement("div");
        Ly.setAttribute("oninput", "return;"), Rh = typeof Ly.oninput == "function";
      }
      kh = Rh;
    } else
      kh = !1;
    Th = kh && (!document.documentMode || 9 < document.documentMode);
  }
  function $y() {
    kc && (kc.detachEvent("onpropertychange", Ny), du = kc = null);
  }
  function Ny(r) {
    if (r.propertyName === "value" && hu(du)) {
      var i = [];
      zy(i, du, r, Xt(r)), us(pu, i);
    }
  }
  function qS(r, i, u) {
    r === "focusin" ? ($y(), kc = i, du = u, kc.attachEvent("onpropertychange", Ny)) : r === "focusout" && $y();
  }
  function QS(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown")
      return hu(du);
  }
  function KS(r, i) {
    if (r === "click")
      return hu(i);
  }
  function Fy(r, i) {
    if (r === "input" || r === "change")
      return hu(i);
  }
  function XS(r, i) {
    return r === i && (r !== 0 || 1 / r === 1 / i) || r !== r && i !== i;
  }
  var ui = typeof Object.is == "function" ? Object.is : XS;
  function Rc(r, i) {
    if (ui(r, i))
      return !0;
    if (typeof r != "object" || r === null || typeof i != "object" || i === null)
      return !1;
    var u = Object.keys(r), d = Object.keys(i);
    if (u.length !== d.length)
      return !1;
    for (d = 0; d < u.length; d++) {
      var y = u[d];
      if (!x.call(i, y) || !ui(r[y], i[y]))
        return !1;
    }
    return !0;
  }
  function Vy(r) {
    for (; r && r.firstChild; )
      r = r.firstChild;
    return r;
  }
  function jy(r, i) {
    var u = Vy(r);
    r = 0;
    for (var d; u; ) {
      if (u.nodeType === 3) {
        if (d = r + u.textContent.length, r <= i && d >= i)
          return { node: u, offset: i - r };
        r = d;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = Vy(u);
    }
  }
  function By(r, i) {
    return r && i ? r === i ? !0 : r && r.nodeType === 3 ? !1 : i && i.nodeType === 3 ? By(r, i.parentNode) : "contains" in r ? r.contains(i) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function rd() {
    for (var r = window, i = kn(); i instanceof r.HTMLIFrameElement; ) {
      try {
        var u = typeof i.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u)
        r = i.contentWindow;
      else
        break;
      i = kn(r.document);
    }
    return i;
  }
  function Mo(r) {
    var i = r && r.nodeName && r.nodeName.toLowerCase();
    return i && (i === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || i === "textarea" || r.contentEditable === "true");
  }
  function ad(r) {
    var i = rd(), u = r.focusedElem, d = r.selectionRange;
    if (i !== u && u && u.ownerDocument && By(u.ownerDocument.documentElement, u)) {
      if (d !== null && Mo(u)) {
        if (i = d.start, r = d.end, r === void 0 && (r = i), "selectionStart" in u)
          u.selectionStart = i, u.selectionEnd = Math.min(r, u.value.length);
        else if (r = (i = u.ownerDocument || document) && i.defaultView || window, r.getSelection) {
          r = r.getSelection();
          var y = u.textContent.length, S = Math.min(d.start, y);
          d = d.end === void 0 ? S : Math.min(d.end, y), !r.extend && S > d && (y = d, d = S, S = y), y = jy(u, S);
          var R = jy(
            u,
            d
          );
          y && R && (r.rangeCount !== 1 || r.anchorNode !== y.node || r.anchorOffset !== y.offset || r.focusNode !== R.node || r.focusOffset !== R.offset) && (i = i.createRange(), i.setStart(y.node, y.offset), r.removeAllRanges(), S > d ? (r.addRange(i), r.extend(R.node, R.offset)) : (i.setEnd(R.node, R.offset), r.addRange(i)));
        }
      }
      for (i = [], r = u; r = r.parentNode; )
        r.nodeType === 1 && i.push({ element: r, left: r.scrollLeft, top: r.scrollTop });
      for (typeof u.focus == "function" && u.focus(), u = 0; u < i.length; u++)
        r = i[u], r.element.scrollLeft = r.left, r.element.scrollTop = r.top;
    }
  }
  var Uy = b && "documentMode" in document && 11 >= document.documentMode, Vi = null, _h = null, _c = null, Dh = !1;
  function Iy(r, i, u) {
    var d = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    Dh || Vi == null || Vi !== kn(d) || (d = Vi, "selectionStart" in d && Mo(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), _c && Rc(_c, d) || (_c = d, d = zc(_h, "onSelect"), 0 < d.length && (i = new Kf("onSelect", "select", null, i, u), r.push({ event: i, listeners: d }), i.target = Vi)));
  }
  function id(r, i) {
    var u = {};
    return u[r.toLowerCase()] = i.toLowerCase(), u["Webkit" + r] = "webkit" + i, u["Moz" + r] = "moz" + i, u;
  }
  var il = { animationend: id("Animation", "AnimationEnd"), animationiteration: id("Animation", "AnimationIteration"), animationstart: id("Animation", "AnimationStart"), transitionend: id("Transition", "TransitionEnd") }, Ah = {}, Mh = {};
  b && (Mh = document.createElement("div").style, "AnimationEvent" in window || (delete il.animationend.animation, delete il.animationiteration.animation, delete il.animationstart.animation), "TransitionEvent" in window || delete il.transitionend.transition);
  function yr(r) {
    if (Ah[r])
      return Ah[r];
    if (!il[r])
      return r;
    var i = il[r], u;
    for (u in i)
      if (i.hasOwnProperty(u) && u in Mh)
        return Ah[r] = i[u];
    return r;
  }
  var Oh = yr("animationend"), Hy = yr("animationiteration"), Wy = yr("animationstart"), Yy = yr("transitionend"), Gy = /* @__PURE__ */ new Map(), qy = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Oo(r, i) {
    Gy.set(r, i), v(i, [r]);
  }
  for (var Dc = 0; Dc < qy.length; Dc++) {
    var ol = qy[Dc], ZS = ol.toLowerCase(), Ac = ol[0].toUpperCase() + ol.slice(1);
    Oo(ZS, "on" + Ac);
  }
  Oo(Oh, "onAnimationEnd"), Oo(Hy, "onAnimationIteration"), Oo(Wy, "onAnimationStart"), Oo("dblclick", "onDoubleClick"), Oo("focusin", "onFocus"), Oo("focusout", "onBlur"), Oo(Yy, "onTransitionEnd"), h("onMouseEnter", ["mouseout", "mouseover"]), h("onMouseLeave", ["mouseout", "mouseover"]), h("onPointerEnter", ["pointerout", "pointerover"]), h("onPointerLeave", ["pointerout", "pointerover"]), v("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), v("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), v("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), v("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), v("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), v("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Mc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), JS = new Set("cancel close invalid load scroll toggle".split(" ").concat(Mc));
  function Qy(r, i, u) {
    var d = r.type || "unknown-event";
    r.currentTarget = u, He(d, i, void 0, r), r.currentTarget = null;
  }
  function od(r, i) {
    i = (i & 4) !== 0;
    for (var u = 0; u < r.length; u++) {
      var d = r[u], y = d.event;
      d = d.listeners;
      e: {
        var S = void 0;
        if (i)
          for (var R = d.length - 1; 0 <= R; R--) {
            var z = d[R], N = z.instance, te = z.currentTarget;
            if (z = z.listener, N !== S && y.isPropagationStopped())
              break e;
            Qy(y, z, te), S = N;
          }
        else
          for (R = 0; R < d.length; R++) {
            if (z = d[R], N = z.instance, te = z.currentTarget, z = z.listener, N !== S && y.isPropagationStopped())
              break e;
            Qy(y, z, te), S = N;
          }
      }
    }
    if (aa)
      throw r = P, aa = !1, P = null, r;
  }
  function fn(r, i) {
    var u = i[Vh];
    u === void 0 && (u = i[Vh] = /* @__PURE__ */ new Set());
    var d = r + "__bubble";
    u.has(d) || (Ky(i, r, 2, !1), u.add(d));
  }
  function ps(r, i, u) {
    var d = 0;
    i && (d |= 4), Ky(u, r, d, i);
  }
  var zo = "_reactListening" + Math.random().toString(36).slice(2);
  function mu(r) {
    if (!r[zo]) {
      r[zo] = !0, c.forEach(function(u) {
        u !== "selectionchange" && (JS.has(u) || ps(u, !1, r), ps(u, !0, r));
      });
      var i = r.nodeType === 9 ? r : r.ownerDocument;
      i === null || i[zo] || (i[zo] = !0, ps("selectionchange", !1, i));
    }
  }
  function Ky(r, i, u, d) {
    switch (Wt(i)) {
      case 1:
        var y = O;
        break;
      case 4:
        y = j;
        break;
      default:
        y = ee;
    }
    u = y.bind(null, i, u, r), y = void 0, !cs || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (y = !0), d ? y !== void 0 ? r.addEventListener(i, u, { capture: !0, passive: y }) : r.addEventListener(i, u, !0) : y !== void 0 ? r.addEventListener(i, u, { passive: y }) : r.addEventListener(i, u, !1);
  }
  function sd(r, i, u, d, y) {
    var S = d;
    if (!(i & 1) && !(i & 2) && d !== null)
      e:
        for (; ; ) {
          if (d === null)
            return;
          var R = d.tag;
          if (R === 3 || R === 4) {
            var z = d.stateNode.containerInfo;
            if (z === y || z.nodeType === 8 && z.parentNode === y)
              break;
            if (R === 4)
              for (R = d.return; R !== null; ) {
                var N = R.tag;
                if ((N === 3 || N === 4) && (N = R.stateNode.containerInfo, N === y || N.nodeType === 8 && N.parentNode === y))
                  return;
                R = R.return;
              }
            for (; z !== null; ) {
              if (R = ci(z), R === null)
                return;
              if (N = R.tag, N === 5 || N === 6) {
                d = S = R;
                continue e;
              }
              z = z.parentNode;
            }
          }
          d = d.return;
        }
    us(function() {
      var te = S, fe = Xt(u), de = [];
      e: {
        var ue = Gy.get(r);
        if (ue !== void 0) {
          var Te = Kf, ze = r;
          switch (r) {
            case "keypress":
              if (Zn(u) === 0)
                break e;
            case "keydown":
            case "keyup":
              Te = HS;
              break;
            case "focusin":
              ze = "focus", Te = ds;
              break;
            case "focusout":
              ze = "blur", Te = ds;
              break;
            case "beforeblur":
            case "afterblur":
              Te = ds;
              break;
            case "click":
              if (u.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Te = Zf;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Te = Cy;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Te = WS;
              break;
            case Oh:
            case Hy:
            case Wy:
              Te = Ey;
              break;
            case Yy:
              Te = Ry;
              break;
            case "scroll":
              Te = Sy;
              break;
            case "wheel":
              Te = Ao;
              break;
            case "copy":
            case "cut":
            case "paste":
              Te = US;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Te = Jf;
          }
          var Ne = (i & 4) !== 0, qn = !Ne && r === "scroll", G = Ne ? ue !== null ? ue + "Capture" : null : ue;
          Ne = [];
          for (var B = te, X; B !== null; ) {
            X = B;
            var me = X.stateNode;
            if (X.tag === 5 && me !== null && (X = me, G !== null && (me = kr(B, G), me != null && Ne.push(Oc(B, me, X)))), qn)
              break;
            B = B.return;
          }
          0 < Ne.length && (ue = new Te(ue, ze, null, u, fe), de.push({ event: ue, listeners: Ne }));
        }
      }
      if (!(i & 7)) {
        e: {
          if (ue = r === "mouseover" || r === "pointerover", Te = r === "mouseout" || r === "pointerout", ue && u !== Ir && (ze = u.relatedTarget || u.fromElement) && (ci(ze) || ze[Po]))
            break e;
          if ((Te || ue) && (ue = fe.window === fe ? fe : (ue = fe.ownerDocument) ? ue.defaultView || ue.parentWindow : window, Te ? (ze = u.relatedTarget || u.toElement, Te = te, ze = ze ? ci(ze) : null, ze !== null && (qn = ct(ze), ze !== qn || ze.tag !== 5 && ze.tag !== 6) && (ze = null)) : (Te = null, ze = te), Te !== ze)) {
            if (Ne = Zf, me = "onMouseLeave", G = "onMouseEnter", B = "mouse", (r === "pointerout" || r === "pointerover") && (Ne = Jf, me = "onPointerLeave", G = "onPointerEnter", B = "pointer"), qn = Te == null ? ue : vu(Te), X = ze == null ? ue : vu(ze), ue = new Ne(me, B + "leave", Te, u, fe), ue.target = qn, ue.relatedTarget = X, me = null, ci(fe) === te && (Ne = new Ne(G, B + "enter", ze, u, fe), Ne.target = X, Ne.relatedTarget = qn, me = Ne), qn = me, Te && ze)
              t: {
                for (Ne = Te, G = ze, B = 0, X = Ne; X; X = sl(X))
                  B++;
                for (X = 0, me = G; me; me = sl(me))
                  X++;
                for (; 0 < B - X; )
                  Ne = sl(Ne), B--;
                for (; 0 < X - B; )
                  G = sl(G), X--;
                for (; B--; ) {
                  if (Ne === G || G !== null && Ne === G.alternate)
                    break t;
                  Ne = sl(Ne), G = sl(G);
                }
                Ne = null;
              }
            else
              Ne = null;
            Te !== null && zh(de, ue, Te, Ne, !1), ze !== null && qn !== null && zh(de, qn, ze, Ne, !0);
          }
        }
        e: {
          if (ue = te ? vu(te) : window, Te = ue.nodeName && ue.nodeName.toLowerCase(), Te === "select" || Te === "input" && ue.type === "file")
            var Ve = Py;
          else if (Oy(ue))
            if (Th)
              Ve = Fy;
            else {
              Ve = QS;
              var Pe = qS;
            }
          else
            (Te = ue.nodeName) && Te.toLowerCase() === "input" && (ue.type === "checkbox" || ue.type === "radio") && (Ve = KS);
          if (Ve && (Ve = Ve(r, te))) {
            zy(de, Ve, u, fe);
            break e;
          }
          Pe && Pe(r, ue, te), r === "focusout" && (Pe = ue._wrapperState) && Pe.controlled && ue.type === "number" && Ua(ue, "number", ue.value);
        }
        switch (Pe = te ? vu(te) : window, r) {
          case "focusin":
            (Oy(Pe) || Pe.contentEditable === "true") && (Vi = Pe, _h = te, _c = null);
            break;
          case "focusout":
            _c = _h = Vi = null;
            break;
          case "mousedown":
            Dh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Dh = !1, Iy(de, u, fe);
            break;
          case "selectionchange":
            if (Uy)
              break;
          case "keydown":
          case "keyup":
            Iy(de, u, fe);
        }
        var Ie;
        if (Fi)
          e: {
            switch (r) {
              case "compositionstart":
                var at = "onCompositionStart";
                break e;
              case "compositionend":
                at = "onCompositionEnd";
                break e;
              case "compositionupdate":
                at = "onCompositionUpdate";
                break e;
            }
            at = void 0;
          }
        else
          fu ? Ay(r, u) && (at = "onCompositionEnd") : r === "keydown" && u.keyCode === 229 && (at = "onCompositionStart");
        at && (_y && u.locale !== "ko" && (fu || at !== "onCompositionStart" ? at === "onCompositionEnd" && fu && (Ie = Yr()) : (Mt = fe, yt = "value" in Mt ? Mt.value : Mt.textContent, fu = !0)), Pe = zc(te, at), 0 < Pe.length && (at = new Sh(at, r, null, u, fe), de.push({ event: at, listeners: Pe }), Ie ? at.data = Ie : (Ie = nd(u), Ie !== null && (at.data = Ie)))), (Ie = td ? YS(r, u) : GS(r, u)) && (te = zc(te, "onBeforeInput"), 0 < te.length && (fe = new Sh("onBeforeInput", "beforeinput", null, u, fe), de.push({ event: fe, listeners: te }), fe.data = Ie));
      }
      od(de, i);
    });
  }
  function Oc(r, i, u) {
    return { instance: r, listener: i, currentTarget: u };
  }
  function zc(r, i) {
    for (var u = i + "Capture", d = []; r !== null; ) {
      var y = r, S = y.stateNode;
      y.tag === 5 && S !== null && (y = S, S = kr(r, u), S != null && d.unshift(Oc(r, S, y)), S = kr(r, i), S != null && d.push(Oc(r, S, y))), r = r.return;
    }
    return d;
  }
  function sl(r) {
    if (r === null)
      return null;
    do
      r = r.return;
    while (r && r.tag !== 5);
    return r || null;
  }
  function zh(r, i, u, d, y) {
    for (var S = i._reactName, R = []; u !== null && u !== d; ) {
      var z = u, N = z.alternate, te = z.stateNode;
      if (N !== null && N === d)
        break;
      z.tag === 5 && te !== null && (z = te, y ? (N = kr(u, S), N != null && R.unshift(Oc(u, N, z))) : y || (N = kr(u, S), N != null && R.push(Oc(u, N, z)))), u = u.return;
    }
    R.length !== 0 && r.push({ event: i, listeners: R });
  }
  var Ph = /\r\n?/g, e1 = /\u0000|\uFFFD/g;
  function Lh(r) {
    return (typeof r == "string" ? r : "" + r).replace(Ph, `
`).replace(e1, "");
  }
  function ld(r, i, u) {
    if (i = Lh(i), Lh(r) !== i && u)
      throw Error(s(425));
  }
  function ud() {
  }
  var $h = null, ll = null;
  function Pc(r, i) {
    return r === "textarea" || r === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var ul = typeof setTimeout == "function" ? setTimeout : void 0, Xy = typeof clearTimeout == "function" ? clearTimeout : void 0, Nh = typeof Promise == "function" ? Promise : void 0, Fh = typeof queueMicrotask == "function" ? queueMicrotask : typeof Nh < "u" ? function(r) {
    return Nh.resolve(null).then(r).catch(t1);
  } : ul;
  function t1(r) {
    setTimeout(function() {
      throw r;
    });
  }
  function hs(r, i) {
    var u = i, d = 0;
    do {
      var y = u.nextSibling;
      if (r.removeChild(u), y && y.nodeType === 8)
        if (u = y.data, u === "/$") {
          if (d === 0) {
            r.removeChild(y), rl(i);
            return;
          }
          d--;
        } else
          u !== "$" && u !== "$?" && u !== "$!" || d++;
      u = y;
    } while (u);
    rl(i);
  }
  function ji(r) {
    for (; r != null; r = r.nextSibling) {
      var i = r.nodeType;
      if (i === 1 || i === 3)
        break;
      if (i === 8) {
        if (i = r.data, i === "$" || i === "$!" || i === "$?")
          break;
        if (i === "/$")
          return null;
      }
    }
    return r;
  }
  function Lc(r) {
    r = r.previousSibling;
    for (var i = 0; r; ) {
      if (r.nodeType === 8) {
        var u = r.data;
        if (u === "$" || u === "$!" || u === "$?") {
          if (i === 0)
            return r;
          i--;
        } else
          u === "/$" && i++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  var ms = Math.random().toString(36).slice(2), eo = "__reactFiber$" + ms, cl = "__reactProps$" + ms, Po = "__reactContainer$" + ms, Vh = "__reactEvents$" + ms, n1 = "__reactListeners$" + ms, jh = "__reactHandles$" + ms;
  function ci(r) {
    var i = r[eo];
    if (i)
      return i;
    for (var u = r.parentNode; u; ) {
      if (i = u[Po] || u[eo]) {
        if (u = i.alternate, i.child !== null || u !== null && u.child !== null)
          for (r = Lc(r); r !== null; ) {
            if (u = r[eo])
              return u;
            r = Lc(r);
          }
        return i;
      }
      r = u, u = r.parentNode;
    }
    return null;
  }
  function $c(r) {
    return r = r[eo] || r[Po], !r || r.tag !== 5 && r.tag !== 6 && r.tag !== 13 && r.tag !== 3 ? null : r;
  }
  function vu(r) {
    if (r.tag === 5 || r.tag === 6)
      return r.stateNode;
    throw Error(s(33));
  }
  function We(r) {
    return r[cl] || null;
  }
  var vs = [], xn = -1;
  function dt(r) {
    return { current: r };
  }
  function Yt(r) {
    0 > xn || (r.current = vs[xn], vs[xn] = null, xn--);
  }
  function Qt(r, i) {
    xn++, vs[xn] = r.current, r.current = i;
  }
  var to = {}, rt = dt(to), Un = dt(!1), _a = to;
  function fi(r, i) {
    var u = r.type.contextTypes;
    if (!u)
      return to;
    var d = r.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === i)
      return d.__reactInternalMemoizedMaskedChildContext;
    var y = {}, S;
    for (S in u)
      y[S] = i[S];
    return d && (r = r.stateNode, r.__reactInternalMemoizedUnmaskedChildContext = i, r.__reactInternalMemoizedMaskedChildContext = y), y;
  }
  function _n(r) {
    return r = r.childContextTypes, r != null;
  }
  function di() {
    Yt(Un), Yt(rt);
  }
  function ys(r, i, u) {
    if (rt.current !== to)
      throw Error(s(168));
    Qt(rt, i), Qt(Un, u);
  }
  function Nc(r, i, u) {
    var d = r.stateNode;
    if (i = i.childContextTypes, typeof d.getChildContext != "function")
      return u;
    d = d.getChildContext();
    for (var y in d)
      if (!(y in i))
        throw Error(s(108, yn(r) || "Unknown", y));
    return ve({}, u, d);
  }
  function cd(r) {
    return r = (r = r.stateNode) && r.__reactInternalMemoizedMergedChildContext || to, _a = rt.current, Qt(rt, r), Qt(Un, Un.current), !0;
  }
  function Zy(r, i, u) {
    var d = r.stateNode;
    if (!d)
      throw Error(s(169));
    u ? (r = Nc(r, i, _a), d.__reactInternalMemoizedMergedChildContext = r, Yt(Un), Yt(rt), Qt(rt, r)) : Yt(Un), Qt(Un, u);
  }
  var Ga = null, gr = !1, Fc = !1;
  function Bh(r) {
    Ga === null ? Ga = [r] : Ga.push(r);
  }
  function Uh(r) {
    gr = !0, Bh(r);
  }
  function Da() {
    if (!Fc && Ga !== null) {
      Fc = !0;
      var r = 0, i = It;
      try {
        var u = Ga;
        for (It = 1; r < u.length; r++) {
          var d = u[r];
          do
            d = d(!0);
          while (d !== null);
        }
        Ga = null, gr = !1;
      } catch (y) {
        throw Ga !== null && (Ga = Ga.slice(r + 1)), vn(Pi, Da), y;
      } finally {
        It = i, Fc = !1;
      }
    }
    return null;
  }
  var gs = [], Aa = 0, fl = null, yu = 0, Ma = [], Gr = 0, pi = null, Dr = 1, Lo = "";
  function qa(r, i) {
    gs[Aa++] = yu, gs[Aa++] = fl, fl = r, yu = i;
  }
  function Ih(r, i, u) {
    Ma[Gr++] = Dr, Ma[Gr++] = Lo, Ma[Gr++] = pi, pi = r;
    var d = Dr;
    r = Lo;
    var y = 32 - wa(d) - 1;
    d &= ~(1 << y), u += 1;
    var S = 32 - wa(i) + y;
    if (30 < S) {
      var R = y - y % 5;
      S = (d & (1 << R) - 1).toString(32), d >>= R, y -= R, Dr = 1 << 32 - wa(i) + y | u << y | d, Lo = S + r;
    } else
      Dr = 1 << S | u << y | d, Lo = r;
  }
  function fd(r) {
    r.return !== null && (qa(r, 1), Ih(r, 1, 0));
  }
  function Hh(r) {
    for (; r === fl; )
      fl = gs[--Aa], gs[Aa] = null, yu = gs[--Aa], gs[Aa] = null;
    for (; r === pi; )
      pi = Ma[--Gr], Ma[Gr] = null, Lo = Ma[--Gr], Ma[Gr] = null, Dr = Ma[--Gr], Ma[Gr] = null;
  }
  var Qa = null, Oa = null, Cn = !1, hi = null;
  function Wh(r, i) {
    var u = xi(5, null, null, 0);
    u.elementType = "DELETED", u.stateNode = i, u.return = r, i = r.deletions, i === null ? (r.deletions = [u], r.flags |= 16) : i.push(u);
  }
  function Jy(r, i) {
    switch (r.tag) {
      case 5:
        var u = r.type;
        return i = i.nodeType !== 1 || u.toLowerCase() !== i.nodeName.toLowerCase() ? null : i, i !== null ? (r.stateNode = i, Qa = r, Oa = ji(i.firstChild), !0) : !1;
      case 6:
        return i = r.pendingProps === "" || i.nodeType !== 3 ? null : i, i !== null ? (r.stateNode = i, Qa = r, Oa = null, !0) : !1;
      case 13:
        return i = i.nodeType !== 8 ? null : i, i !== null ? (u = pi !== null ? { id: Dr, overflow: Lo } : null, r.memoizedState = { dehydrated: i, treeContext: u, retryLane: 1073741824 }, u = xi(18, null, null, 0), u.stateNode = i, u.return = r, r.child = u, Qa = r, Oa = null, !0) : !1;
      default:
        return !1;
    }
  }
  function dd(r) {
    return (r.mode & 1) !== 0 && (r.flags & 128) === 0;
  }
  function pd(r) {
    if (Cn) {
      var i = Oa;
      if (i) {
        var u = i;
        if (!Jy(r, i)) {
          if (dd(r))
            throw Error(s(418));
          i = ji(u.nextSibling);
          var d = Qa;
          i && Jy(r, i) ? Wh(d, u) : (r.flags = r.flags & -4097 | 2, Cn = !1, Qa = r);
        }
      } else {
        if (dd(r))
          throw Error(s(418));
        r.flags = r.flags & -4097 | 2, Cn = !1, Qa = r;
      }
    }
  }
  function eg(r) {
    for (r = r.return; r !== null && r.tag !== 5 && r.tag !== 3 && r.tag !== 13; )
      r = r.return;
    Qa = r;
  }
  function hd(r) {
    if (r !== Qa)
      return !1;
    if (!Cn)
      return eg(r), Cn = !0, !1;
    var i;
    if ((i = r.tag !== 3) && !(i = r.tag !== 5) && (i = r.type, i = i !== "head" && i !== "body" && !Pc(r.type, r.memoizedProps)), i && (i = Oa)) {
      if (dd(r))
        throw tg(), Error(s(418));
      for (; i; )
        Wh(r, i), i = ji(i.nextSibling);
    }
    if (eg(r), r.tag === 13) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r)
        throw Error(s(317));
      e: {
        for (r = r.nextSibling, i = 0; r; ) {
          if (r.nodeType === 8) {
            var u = r.data;
            if (u === "/$") {
              if (i === 0) {
                Oa = ji(r.nextSibling);
                break e;
              }
              i--;
            } else
              u !== "$" && u !== "$!" && u !== "$?" || i++;
          }
          r = r.nextSibling;
        }
        Oa = null;
      }
    } else
      Oa = Qa ? ji(r.stateNode.nextSibling) : null;
    return !0;
  }
  function tg() {
    for (var r = Oa; r; )
      r = ji(r.nextSibling);
  }
  function zn() {
    Oa = Qa = null, Cn = !1;
  }
  function Yh(r) {
    hi === null ? hi = [r] : hi.push(r);
  }
  var md = ne.ReactCurrentBatchConfig;
  function Ka(r, i) {
    if (r && r.defaultProps) {
      i = ve({}, i), r = r.defaultProps;
      for (var u in r)
        i[u] === void 0 && (i[u] = r[u]);
      return i;
    }
    return i;
  }
  var no = dt(null), vd = null, bs = null, Gh = null;
  function qh() {
    Gh = bs = vd = null;
  }
  function Ss(r) {
    var i = no.current;
    Yt(no), r._currentValue = i;
  }
  function br(r, i, u) {
    for (; r !== null; ) {
      var d = r.alternate;
      if ((r.childLanes & i) !== i ? (r.childLanes |= i, d !== null && (d.childLanes |= i)) : d !== null && (d.childLanes & i) !== i && (d.childLanes |= i), r === u)
        break;
      r = r.return;
    }
  }
  function Se(r, i) {
    vd = r, Gh = bs = null, r = r.dependencies, r !== null && r.firstContext !== null && (r.lanes & i && (er = !0), r.firstContext = null);
  }
  function Gn(r) {
    var i = r._currentValue;
    if (Gh !== r)
      if (r = { context: r, memoizedValue: i, next: null }, bs === null) {
        if (vd === null)
          throw Error(s(308));
        bs = r, vd.dependencies = { lanes: 0, firstContext: r };
      } else
        bs = bs.next = r;
    return i;
  }
  var Ar = null;
  function Qh(r) {
    Ar === null ? Ar = [r] : Ar.push(r);
  }
  function ng(r, i, u, d) {
    var y = i.interleaved;
    return y === null ? (u.next = u, Qh(i)) : (u.next = y.next, y.next = u), i.interleaved = u, $o(r, d);
  }
  function $o(r, i) {
    r.lanes |= i;
    var u = r.alternate;
    for (u !== null && (u.lanes |= i), u = r, r = r.return; r !== null; )
      r.childLanes |= i, u = r.alternate, u !== null && (u.childLanes |= i), u = r, r = r.return;
    return u.tag === 3 ? u.stateNode : null;
  }
  var xs = !1;
  function Kh(r) {
    r.updateQueue = { baseState: r.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function ir(r, i) {
    r = r.updateQueue, i.updateQueue === r && (i.updateQueue = { baseState: r.baseState, firstBaseUpdate: r.firstBaseUpdate, lastBaseUpdate: r.lastBaseUpdate, shared: r.shared, effects: r.effects });
  }
  function No(r, i) {
    return { eventTime: r, lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Cs(r, i, u) {
    var d = r.updateQueue;
    if (d === null)
      return null;
    if (d = d.shared, wt & 2) {
      var y = d.pending;
      return y === null ? i.next = i : (i.next = y.next, y.next = i), d.pending = i, $o(r, u);
    }
    return y = d.interleaved, y === null ? (i.next = i, Qh(d)) : (i.next = y.next, y.next = i), d.interleaved = i, $o(r, u);
  }
  function yd(r, i, u) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (u & 4194240) !== 0)) {
      var d = i.lanes;
      d &= r.pendingLanes, u |= d, i.lanes = u, el(r, u);
    }
  }
  function Xh(r, i) {
    var u = r.updateQueue, d = r.alternate;
    if (d !== null && (d = d.updateQueue, u === d)) {
      var y = null, S = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var R = { eventTime: u.eventTime, lane: u.lane, tag: u.tag, payload: u.payload, callback: u.callback, next: null };
          S === null ? y = S = R : S = S.next = R, u = u.next;
        } while (u !== null);
        S === null ? y = S = i : S = S.next = i;
      } else
        y = S = i;
      u = { baseState: d.baseState, firstBaseUpdate: y, lastBaseUpdate: S, shared: d.shared, effects: d.effects }, r.updateQueue = u;
      return;
    }
    r = u.lastBaseUpdate, r === null ? u.firstBaseUpdate = i : r.next = i, u.lastBaseUpdate = i;
  }
  function Es(r, i, u, d) {
    var y = r.updateQueue;
    xs = !1;
    var S = y.firstBaseUpdate, R = y.lastBaseUpdate, z = y.shared.pending;
    if (z !== null) {
      y.shared.pending = null;
      var N = z, te = N.next;
      N.next = null, R === null ? S = te : R.next = te, R = N;
      var fe = r.alternate;
      fe !== null && (fe = fe.updateQueue, z = fe.lastBaseUpdate, z !== R && (z === null ? fe.firstBaseUpdate = te : z.next = te, fe.lastBaseUpdate = N));
    }
    if (S !== null) {
      var de = y.baseState;
      R = 0, fe = te = N = null, z = S;
      do {
        var ue = z.lane, Te = z.eventTime;
        if ((d & ue) === ue) {
          fe !== null && (fe = fe.next = {
            eventTime: Te,
            lane: 0,
            tag: z.tag,
            payload: z.payload,
            callback: z.callback,
            next: null
          });
          e: {
            var ze = r, Ne = z;
            switch (ue = i, Te = u, Ne.tag) {
              case 1:
                if (ze = Ne.payload, typeof ze == "function") {
                  de = ze.call(Te, de, ue);
                  break e;
                }
                de = ze;
                break e;
              case 3:
                ze.flags = ze.flags & -65537 | 128;
              case 0:
                if (ze = Ne.payload, ue = typeof ze == "function" ? ze.call(Te, de, ue) : ze, ue == null)
                  break e;
                de = ve({}, de, ue);
                break e;
              case 2:
                xs = !0;
            }
          }
          z.callback !== null && z.lane !== 0 && (r.flags |= 64, ue = y.effects, ue === null ? y.effects = [z] : ue.push(z));
        } else
          Te = { eventTime: Te, lane: ue, tag: z.tag, payload: z.payload, callback: z.callback, next: null }, fe === null ? (te = fe = Te, N = de) : fe = fe.next = Te, R |= ue;
        if (z = z.next, z === null) {
          if (z = y.shared.pending, z === null)
            break;
          ue = z, z = ue.next, ue.next = null, y.lastBaseUpdate = ue, y.shared.pending = null;
        }
      } while (!0);
      if (fe === null && (N = de), y.baseState = N, y.firstBaseUpdate = te, y.lastBaseUpdate = fe, i = y.shared.interleaved, i !== null) {
        y = i;
        do
          R |= y.lane, y = y.next;
        while (y !== i);
      } else
        S === null && (y.shared.lanes = 0);
      Bo |= R, r.lanes = R, r.memoizedState = de;
    }
  }
  function dl(r, i, u) {
    if (r = i.effects, i.effects = null, r !== null)
      for (i = 0; i < r.length; i++) {
        var d = r[i], y = d.callback;
        if (y !== null) {
          if (d.callback = null, d = u, typeof y != "function")
            throw Error(s(191, y));
          y.call(d);
        }
      }
  }
  var rg = new n.Component().refs;
  function Zh(r, i, u, d) {
    i = r.memoizedState, u = u(d, i), u = u == null ? i : ve({}, i, u), r.memoizedState = u, r.lanes === 0 && (r.updateQueue.baseState = u);
  }
  var gd = { isMounted: function(r) {
    return (r = r._reactInternals) ? ct(r) === r : !1;
  }, enqueueSetState: function(r, i, u) {
    r = r._reactInternals;
    var d = Xr(), y = tr(r), S = No(d, y);
    S.payload = i, u != null && (S.callback = u), i = Cs(r, S, y), i !== null && (Zr(i, r, y, d), yd(i, r, y));
  }, enqueueReplaceState: function(r, i, u) {
    r = r._reactInternals;
    var d = Xr(), y = tr(r), S = No(d, y);
    S.tag = 1, S.payload = i, u != null && (S.callback = u), i = Cs(r, S, y), i !== null && (Zr(i, r, y, d), yd(i, r, y));
  }, enqueueForceUpdate: function(r, i) {
    r = r._reactInternals;
    var u = Xr(), d = tr(r), y = No(u, d);
    y.tag = 2, i != null && (y.callback = i), i = Cs(r, y, d), i !== null && (Zr(i, r, d, u), yd(i, r, d));
  } };
  function ag(r, i, u, d, y, S, R) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(d, S, R) : i.prototype && i.prototype.isPureReactComponent ? !Rc(u, d) || !Rc(y, S) : !0;
  }
  function ig(r, i, u) {
    var d = !1, y = to, S = i.contextType;
    return typeof S == "object" && S !== null ? S = Gn(S) : (y = _n(i) ? _a : rt.current, d = i.contextTypes, S = (d = d != null) ? fi(r, y) : to), i = new i(u, S), r.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, i.updater = gd, r.stateNode = i, i._reactInternals = r, d && (r = r.stateNode, r.__reactInternalMemoizedUnmaskedChildContext = y, r.__reactInternalMemoizedMaskedChildContext = S), i;
  }
  function og(r, i, u, d) {
    r = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(u, d), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(u, d), i.state !== r && gd.enqueueReplaceState(i, i.state, null);
  }
  function bd(r, i, u, d) {
    var y = r.stateNode;
    y.props = u, y.state = r.memoizedState, y.refs = rg, Kh(r);
    var S = i.contextType;
    typeof S == "object" && S !== null ? y.context = Gn(S) : (S = _n(i) ? _a : rt.current, y.context = fi(r, S)), y.state = r.memoizedState, S = i.getDerivedStateFromProps, typeof S == "function" && (Zh(r, i, S, u), y.state = r.memoizedState), typeof i.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function" || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (i = y.state, typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount(), i !== y.state && gd.enqueueReplaceState(y, y.state, null), Es(r, u, y, d), y.state = r.memoizedState), typeof y.componentDidMount == "function" && (r.flags |= 4194308);
  }
  function gu(r, i, u) {
    if (r = u.ref, r !== null && typeof r != "function" && typeof r != "object") {
      if (u._owner) {
        if (u = u._owner, u) {
          if (u.tag !== 1)
            throw Error(s(309));
          var d = u.stateNode;
        }
        if (!d)
          throw Error(s(147, r));
        var y = d, S = "" + r;
        return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === S ? i.ref : (i = function(R) {
          var z = y.refs;
          z === rg && (z = y.refs = {}), R === null ? delete z[S] : z[S] = R;
        }, i._stringRef = S, i);
      }
      if (typeof r != "string")
        throw Error(s(284));
      if (!u._owner)
        throw Error(s(290, r));
    }
    return r;
  }
  function Sd(r, i) {
    throw r = Object.prototype.toString.call(i), Error(s(31, r === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : r));
  }
  function sg(r) {
    var i = r._init;
    return i(r._payload);
  }
  function lg(r) {
    function i(G, B) {
      if (r) {
        var X = G.deletions;
        X === null ? (G.deletions = [B], G.flags |= 16) : X.push(B);
      }
    }
    function u(G, B) {
      if (!r)
        return null;
      for (; B !== null; )
        i(G, B), B = B.sibling;
      return null;
    }
    function d(G, B) {
      for (G = /* @__PURE__ */ new Map(); B !== null; )
        B.key !== null ? G.set(B.key, B) : G.set(B.index, B), B = B.sibling;
      return G;
    }
    function y(G, B) {
      return G = Ms(G, B), G.index = 0, G.sibling = null, G;
    }
    function S(G, B, X) {
      return G.index = X, r ? (X = G.alternate, X !== null ? (X = X.index, X < B ? (G.flags |= 2, B) : X) : (G.flags |= 2, B)) : (G.flags |= 1048576, B);
    }
    function R(G) {
      return r && G.alternate === null && (G.flags |= 2), G;
    }
    function z(G, B, X, me) {
      return B === null || B.tag !== 6 ? (B = rf(X, G.mode, me), B.return = G, B) : (B = y(B, X), B.return = G, B);
    }
    function N(G, B, X, me) {
      var Ve = X.type;
      return Ve === re ? fe(G, B, X.props.children, me, X.key) : B !== null && (B.elementType === Ve || typeof Ve == "object" && Ve !== null && Ve.$$typeof === tt && sg(Ve) === B.type) ? (me = y(B, X.props), me.ref = gu(G, B, X), me.return = G, me) : (me = Zd(X.type, X.key, X.props, null, G.mode, me), me.ref = gu(G, B, X), me.return = G, me);
    }
    function te(G, B, X, me) {
      return B === null || B.tag !== 4 || B.stateNode.containerInfo !== X.containerInfo || B.stateNode.implementation !== X.implementation ? (B = Ml(X, G.mode, me), B.return = G, B) : (B = y(B, X.children || []), B.return = G, B);
    }
    function fe(G, B, X, me, Ve) {
      return B === null || B.tag !== 7 ? (B = Al(X, G.mode, me, Ve), B.return = G, B) : (B = y(B, X), B.return = G, B);
    }
    function de(G, B, X) {
      if (typeof B == "string" && B !== "" || typeof B == "number")
        return B = rf("" + B, G.mode, X), B.return = G, B;
      if (typeof B == "object" && B !== null) {
        switch (B.$$typeof) {
          case H:
            return X = Zd(B.type, B.key, B.props, null, G.mode, X), X.ref = gu(G, null, B), X.return = G, X;
          case le:
            return B = Ml(B, G.mode, X), B.return = G, B;
          case tt:
            var me = B._init;
            return de(G, me(B._payload), X);
        }
        if (Sa(B) || Ce(B))
          return B = Al(B, G.mode, X, null), B.return = G, B;
        Sd(G, B);
      }
      return null;
    }
    function ue(G, B, X, me) {
      var Ve = B !== null ? B.key : null;
      if (typeof X == "string" && X !== "" || typeof X == "number")
        return Ve !== null ? null : z(G, B, "" + X, me);
      if (typeof X == "object" && X !== null) {
        switch (X.$$typeof) {
          case H:
            return X.key === Ve ? N(G, B, X, me) : null;
          case le:
            return X.key === Ve ? te(G, B, X, me) : null;
          case tt:
            return Ve = X._init, ue(
              G,
              B,
              Ve(X._payload),
              me
            );
        }
        if (Sa(X) || Ce(X))
          return Ve !== null ? null : fe(G, B, X, me, null);
        Sd(G, X);
      }
      return null;
    }
    function Te(G, B, X, me, Ve) {
      if (typeof me == "string" && me !== "" || typeof me == "number")
        return G = G.get(X) || null, z(B, G, "" + me, Ve);
      if (typeof me == "object" && me !== null) {
        switch (me.$$typeof) {
          case H:
            return G = G.get(me.key === null ? X : me.key) || null, N(B, G, me, Ve);
          case le:
            return G = G.get(me.key === null ? X : me.key) || null, te(B, G, me, Ve);
          case tt:
            var Pe = me._init;
            return Te(G, B, X, Pe(me._payload), Ve);
        }
        if (Sa(me) || Ce(me))
          return G = G.get(X) || null, fe(B, G, me, Ve, null);
        Sd(B, me);
      }
      return null;
    }
    function ze(G, B, X, me) {
      for (var Ve = null, Pe = null, Ie = B, at = B = 0, Cr = null; Ie !== null && at < X.length; at++) {
        Ie.index > at ? (Cr = Ie, Ie = null) : Cr = Ie.sibling;
        var zt = ue(G, Ie, X[at], me);
        if (zt === null) {
          Ie === null && (Ie = Cr);
          break;
        }
        r && Ie && zt.alternate === null && i(G, Ie), B = S(zt, B, at), Pe === null ? Ve = zt : Pe.sibling = zt, Pe = zt, Ie = Cr;
      }
      if (at === X.length)
        return u(G, Ie), Cn && qa(G, at), Ve;
      if (Ie === null) {
        for (; at < X.length; at++)
          Ie = de(G, X[at], me), Ie !== null && (B = S(Ie, B, at), Pe === null ? Ve = Ie : Pe.sibling = Ie, Pe = Ie);
        return Cn && qa(G, at), Ve;
      }
      for (Ie = d(G, Ie); at < X.length; at++)
        Cr = Te(Ie, G, at, X[at], me), Cr !== null && (r && Cr.alternate !== null && Ie.delete(Cr.key === null ? at : Cr.key), B = S(Cr, B, at), Pe === null ? Ve = Cr : Pe.sibling = Cr, Pe = Cr);
      return r && Ie.forEach(function(Os) {
        return i(G, Os);
      }), Cn && qa(G, at), Ve;
    }
    function Ne(G, B, X, me) {
      var Ve = Ce(X);
      if (typeof Ve != "function")
        throw Error(s(150));
      if (X = Ve.call(X), X == null)
        throw Error(s(151));
      for (var Pe = Ve = null, Ie = B, at = B = 0, Cr = null, zt = X.next(); Ie !== null && !zt.done; at++, zt = X.next()) {
        Ie.index > at ? (Cr = Ie, Ie = null) : Cr = Ie.sibling;
        var Os = ue(G, Ie, zt.value, me);
        if (Os === null) {
          Ie === null && (Ie = Cr);
          break;
        }
        r && Ie && Os.alternate === null && i(G, Ie), B = S(Os, B, at), Pe === null ? Ve = Os : Pe.sibling = Os, Pe = Os, Ie = Cr;
      }
      if (zt.done)
        return u(
          G,
          Ie
        ), Cn && qa(G, at), Ve;
      if (Ie === null) {
        for (; !zt.done; at++, zt = X.next())
          zt = de(G, zt.value, me), zt !== null && (B = S(zt, B, at), Pe === null ? Ve = zt : Pe.sibling = zt, Pe = zt);
        return Cn && qa(G, at), Ve;
      }
      for (Ie = d(G, Ie); !zt.done; at++, zt = X.next())
        zt = Te(Ie, G, at, zt.value, me), zt !== null && (r && zt.alternate !== null && Ie.delete(zt.key === null ? at : zt.key), B = S(zt, B, at), Pe === null ? Ve = zt : Pe.sibling = zt, Pe = zt);
      return r && Ie.forEach(function(C1) {
        return i(G, C1);
      }), Cn && qa(G, at), Ve;
    }
    function qn(G, B, X, me) {
      if (typeof X == "object" && X !== null && X.type === re && X.key === null && (X = X.props.children), typeof X == "object" && X !== null) {
        switch (X.$$typeof) {
          case H:
            e: {
              for (var Ve = X.key, Pe = B; Pe !== null; ) {
                if (Pe.key === Ve) {
                  if (Ve = X.type, Ve === re) {
                    if (Pe.tag === 7) {
                      u(G, Pe.sibling), B = y(Pe, X.props.children), B.return = G, G = B;
                      break e;
                    }
                  } else if (Pe.elementType === Ve || typeof Ve == "object" && Ve !== null && Ve.$$typeof === tt && sg(Ve) === Pe.type) {
                    u(G, Pe.sibling), B = y(Pe, X.props), B.ref = gu(G, Pe, X), B.return = G, G = B;
                    break e;
                  }
                  u(G, Pe);
                  break;
                } else
                  i(G, Pe);
                Pe = Pe.sibling;
              }
              X.type === re ? (B = Al(X.props.children, G.mode, me, X.key), B.return = G, G = B) : (me = Zd(X.type, X.key, X.props, null, G.mode, me), me.ref = gu(G, B, X), me.return = G, G = me);
            }
            return R(G);
          case le:
            e: {
              for (Pe = X.key; B !== null; ) {
                if (B.key === Pe)
                  if (B.tag === 4 && B.stateNode.containerInfo === X.containerInfo && B.stateNode.implementation === X.implementation) {
                    u(G, B.sibling), B = y(B, X.children || []), B.return = G, G = B;
                    break e;
                  } else {
                    u(G, B);
                    break;
                  }
                else
                  i(G, B);
                B = B.sibling;
              }
              B = Ml(X, G.mode, me), B.return = G, G = B;
            }
            return R(G);
          case tt:
            return Pe = X._init, qn(G, B, Pe(X._payload), me);
        }
        if (Sa(X))
          return ze(G, B, X, me);
        if (Ce(X))
          return Ne(G, B, X, me);
        Sd(G, X);
      }
      return typeof X == "string" && X !== "" || typeof X == "number" ? (X = "" + X, B !== null && B.tag === 6 ? (u(G, B.sibling), B = y(B, X), B.return = G, G = B) : (u(G, B), B = rf(X, G.mode, me), B.return = G, G = B), R(G)) : u(G, B);
    }
    return qn;
  }
  var bu = lg(!0), ug = lg(!1), Vc = {}, Bi = dt(Vc), jc = dt(Vc), Su = dt(Vc);
  function pl(r) {
    if (r === Vc)
      throw Error(s(174));
    return r;
  }
  function Jh(r, i) {
    switch (Qt(Su, i), Qt(jc, r), Qt(Bi, Vc), r = i.nodeType, r) {
      case 9:
      case 11:
        i = (i = i.documentElement) ? i.namespaceURI : Bn(null, "");
        break;
      default:
        r = r === 8 ? i.parentNode : i, i = r.namespaceURI || null, r = r.tagName, i = Bn(i, r);
    }
    Yt(Bi), Qt(Bi, i);
  }
  function ws() {
    Yt(Bi), Yt(jc), Yt(Su);
  }
  function Qe(r) {
    pl(Su.current);
    var i = pl(Bi.current), u = Bn(i, r.type);
    i !== u && (Qt(jc, r), Qt(Bi, u));
  }
  function xt(r) {
    jc.current === r && (Yt(Bi), Yt(jc));
  }
  var Xe = dt(0);
  function Pn(r) {
    for (var i = r; i !== null; ) {
      if (i.tag === 13) {
        var u = i.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || u.data === "$?" || u.data === "$!"))
          return i;
      } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
        if (i.flags & 128)
          return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === r)
        break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === r)
          return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var mi = [];
  function xd() {
    for (var r = 0; r < mi.length; r++)
      mi[r]._workInProgressVersionPrimary = null;
    mi.length = 0;
  }
  var Cd = ne.ReactCurrentDispatcher, em = ne.ReactCurrentBatchConfig, hl = 0, En = null, oe = null, _t = null, Ze = !1, ro = !1, Xa = 0, ml = 0;
  function wn() {
    throw Error(s(321));
  }
  function vl(r, i) {
    if (i === null)
      return !1;
    for (var u = 0; u < i.length && u < r.length; u++)
      if (!ui(r[u], i[u]))
        return !1;
    return !0;
  }
  function Ts(r, i, u, d, y, S) {
    if (hl = S, En = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, Cd.current = r === null || r.memoizedState === null ? a1 : i1, r = u(d, y), ro) {
      S = 0;
      do {
        if (ro = !1, Xa = 0, 25 <= S)
          throw Error(s(301));
        S += 1, _t = oe = null, i.updateQueue = null, Cd.current = nm, r = u(d, y);
      } while (ro);
    }
    if (Cd.current = Fd, i = oe !== null && oe.next !== null, hl = 0, _t = oe = En = null, Ze = !1, i)
      throw Error(s(300));
    return r;
  }
  function yl() {
    var r = Xa !== 0;
    return Xa = 0, r;
  }
  function yi() {
    var r = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return _t === null ? En.memoizedState = _t = r : _t = _t.next = r, _t;
  }
  function za() {
    if (oe === null) {
      var r = En.alternate;
      r = r !== null ? r.memoizedState : null;
    } else
      r = oe.next;
    var i = _t === null ? En.memoizedState : _t.next;
    if (i !== null)
      _t = i, oe = r;
    else {
      if (r === null)
        throw Error(s(310));
      oe = r, r = { memoizedState: oe.memoizedState, baseState: oe.baseState, baseQueue: oe.baseQueue, queue: oe.queue, next: null }, _t === null ? En.memoizedState = _t = r : _t = _t.next = r;
    }
    return _t;
  }
  function gl(r, i) {
    return typeof i == "function" ? i(r) : i;
  }
  function Bc(r) {
    var i = za(), u = i.queue;
    if (u === null)
      throw Error(s(311));
    u.lastRenderedReducer = r;
    var d = oe, y = d.baseQueue, S = u.pending;
    if (S !== null) {
      if (y !== null) {
        var R = y.next;
        y.next = S.next, S.next = R;
      }
      d.baseQueue = y = S, u.pending = null;
    }
    if (y !== null) {
      S = y.next, d = d.baseState;
      var z = R = null, N = null, te = S;
      do {
        var fe = te.lane;
        if ((hl & fe) === fe)
          N !== null && (N = N.next = { lane: 0, action: te.action, hasEagerState: te.hasEagerState, eagerState: te.eagerState, next: null }), d = te.hasEagerState ? te.eagerState : r(d, te.action);
        else {
          var de = {
            lane: fe,
            action: te.action,
            hasEagerState: te.hasEagerState,
            eagerState: te.eagerState,
            next: null
          };
          N === null ? (z = N = de, R = d) : N = N.next = de, En.lanes |= fe, Bo |= fe;
        }
        te = te.next;
      } while (te !== null && te !== S);
      N === null ? R = d : N.next = z, ui(d, i.memoizedState) || (er = !0), i.memoizedState = d, i.baseState = R, i.baseQueue = N, u.lastRenderedState = d;
    }
    if (r = u.interleaved, r !== null) {
      y = r;
      do
        S = y.lane, En.lanes |= S, Bo |= S, y = y.next;
      while (y !== r);
    } else
      y === null && (u.lanes = 0);
    return [i.memoizedState, u.dispatch];
  }
  function Uc(r) {
    var i = za(), u = i.queue;
    if (u === null)
      throw Error(s(311));
    u.lastRenderedReducer = r;
    var d = u.dispatch, y = u.pending, S = i.memoizedState;
    if (y !== null) {
      u.pending = null;
      var R = y = y.next;
      do
        S = r(S, R.action), R = R.next;
      while (R !== y);
      ui(S, i.memoizedState) || (er = !0), i.memoizedState = S, i.baseQueue === null && (i.baseState = S), u.lastRenderedState = S;
    }
    return [S, d];
  }
  function Ed() {
  }
  function wd(r, i) {
    var u = En, d = za(), y = i(), S = !ui(d.memoizedState, y);
    if (S && (d.memoizedState = y, er = !0), d = d.queue, Ic(Rd.bind(null, u, d, r), [r]), d.getSnapshot !== i || S || _t !== null && _t.memoizedState.tag & 1) {
      if (u.flags |= 2048, bl(9, kd.bind(null, u, d, y, i), void 0, null), Ln === null)
        throw Error(s(349));
      hl & 30 || Td(u, i, y);
    }
    return y;
  }
  function Td(r, i, u) {
    r.flags |= 16384, r = { getSnapshot: i, value: u }, i = En.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, En.updateQueue = i, i.stores = [r]) : (u = i.stores, u === null ? i.stores = [r] : u.push(r));
  }
  function kd(r, i, u, d) {
    i.value = u, i.getSnapshot = d, _d(i) && Dd(r);
  }
  function Rd(r, i, u) {
    return u(function() {
      _d(i) && Dd(r);
    });
  }
  function _d(r) {
    var i = r.getSnapshot;
    r = r.value;
    try {
      var u = i();
      return !ui(r, u);
    } catch {
      return !0;
    }
  }
  function Dd(r) {
    var i = $o(r, 1);
    i !== null && Zr(i, r, 1, -1);
  }
  function Ad(r) {
    var i = yi();
    return typeof r == "function" && (r = r()), i.memoizedState = i.baseState = r, r = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: gl, lastRenderedState: r }, i.queue = r, r = r.dispatch = Nd.bind(null, En, r), [i.memoizedState, r];
  }
  function bl(r, i, u, d) {
    return r = { tag: r, create: i, destroy: u, deps: d, next: null }, i = En.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, En.updateQueue = i, i.lastEffect = r.next = r) : (u = i.lastEffect, u === null ? i.lastEffect = r.next = r : (d = u.next, u.next = r, r.next = d, i.lastEffect = r)), r;
  }
  function Md() {
    return za().memoizedState;
  }
  function Sl(r, i, u, d) {
    var y = yi();
    En.flags |= r, y.memoizedState = bl(1 | i, u, void 0, d === void 0 ? null : d);
  }
  function Fo(r, i, u, d) {
    var y = za();
    d = d === void 0 ? null : d;
    var S = void 0;
    if (oe !== null) {
      var R = oe.memoizedState;
      if (S = R.destroy, d !== null && vl(d, R.deps)) {
        y.memoizedState = bl(i, u, S, d);
        return;
      }
    }
    En.flags |= r, y.memoizedState = bl(1 | i, u, S, d);
  }
  function Od(r, i) {
    return Sl(8390656, 8, r, i);
  }
  function Ic(r, i) {
    return Fo(2048, 8, r, i);
  }
  function zd(r, i) {
    return Fo(4, 2, r, i);
  }
  function Pd(r, i) {
    return Fo(4, 4, r, i);
  }
  function tm(r, i) {
    if (typeof i == "function")
      return r = r(), i(r), function() {
        i(null);
      };
    if (i != null)
      return r = r(), i.current = r, function() {
        i.current = null;
      };
  }
  function xu(r, i, u) {
    return u = u != null ? u.concat([r]) : null, Fo(4, 4, tm.bind(null, i, r), u);
  }
  function Ld() {
  }
  function Cu(r, i) {
    var u = za();
    i = i === void 0 ? null : i;
    var d = u.memoizedState;
    return d !== null && i !== null && vl(i, d[1]) ? d[0] : (u.memoizedState = [r, i], r);
  }
  function ks(r, i) {
    var u = za();
    i = i === void 0 ? null : i;
    var d = u.memoizedState;
    return d !== null && i !== null && vl(i, d[1]) ? d[0] : (r = r(), u.memoizedState = [r, i], r);
  }
  function Pa(r, i, u) {
    return hl & 21 ? (ui(u, i) || (u = au(), En.lanes |= u, Bo |= u, r.baseState = !0), i) : (r.baseState && (r.baseState = !1, er = !0), r.memoizedState = u);
  }
  function r1(r, i) {
    var u = It;
    It = u !== 0 && 4 > u ? u : 4, r(!0);
    var d = em.transition;
    em.transition = {};
    try {
      r(!1), i();
    } finally {
      It = u, em.transition = d;
    }
  }
  function dn() {
    return za().memoizedState;
  }
  function $d(r, i, u) {
    var d = tr(r);
    if (u = { lane: d, action: u, hasEagerState: !1, eagerState: null, next: null }, Eu(r))
      Hc(i, u);
    else if (u = ng(r, i, u, d), u !== null) {
      var y = Xr();
      Zr(u, r, d, y), cg(u, i, d);
    }
  }
  function Nd(r, i, u) {
    var d = tr(r), y = { lane: d, action: u, hasEagerState: !1, eagerState: null, next: null };
    if (Eu(r))
      Hc(i, y);
    else {
      var S = r.alternate;
      if (r.lanes === 0 && (S === null || S.lanes === 0) && (S = i.lastRenderedReducer, S !== null))
        try {
          var R = i.lastRenderedState, z = S(R, u);
          if (y.hasEagerState = !0, y.eagerState = z, ui(z, R)) {
            var N = i.interleaved;
            N === null ? (y.next = y, Qh(i)) : (y.next = N.next, N.next = y), i.interleaved = y;
            return;
          }
        } catch {
        } finally {
        }
      u = ng(r, i, y, d), u !== null && (y = Xr(), Zr(u, r, d, y), cg(u, i, d));
    }
  }
  function Eu(r) {
    var i = r.alternate;
    return r === En || i !== null && i === En;
  }
  function Hc(r, i) {
    ro = Ze = !0;
    var u = r.pending;
    u === null ? i.next = i : (i.next = u.next, u.next = i), r.pending = i;
  }
  function cg(r, i, u) {
    if (u & 4194240) {
      var d = i.lanes;
      d &= r.pendingLanes, u |= d, i.lanes = u, el(r, u);
    }
  }
  var Fd = { readContext: Gn, useCallback: wn, useContext: wn, useEffect: wn, useImperativeHandle: wn, useInsertionEffect: wn, useLayoutEffect: wn, useMemo: wn, useReducer: wn, useRef: wn, useState: wn, useDebugValue: wn, useDeferredValue: wn, useTransition: wn, useMutableSource: wn, useSyncExternalStore: wn, useId: wn, unstable_isNewReconciler: !1 }, a1 = { readContext: Gn, useCallback: function(r, i) {
    return yi().memoizedState = [r, i === void 0 ? null : i], r;
  }, useContext: Gn, useEffect: Od, useImperativeHandle: function(r, i, u) {
    return u = u != null ? u.concat([r]) : null, Sl(
      4194308,
      4,
      tm.bind(null, i, r),
      u
    );
  }, useLayoutEffect: function(r, i) {
    return Sl(4194308, 4, r, i);
  }, useInsertionEffect: function(r, i) {
    return Sl(4, 2, r, i);
  }, useMemo: function(r, i) {
    var u = yi();
    return i = i === void 0 ? null : i, r = r(), u.memoizedState = [r, i], r;
  }, useReducer: function(r, i, u) {
    var d = yi();
    return i = u !== void 0 ? u(i) : i, d.memoizedState = d.baseState = i, r = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: r, lastRenderedState: i }, d.queue = r, r = r.dispatch = $d.bind(null, En, r), [d.memoizedState, r];
  }, useRef: function(r) {
    var i = yi();
    return r = { current: r }, i.memoizedState = r;
  }, useState: Ad, useDebugValue: Ld, useDeferredValue: function(r) {
    return yi().memoizedState = r;
  }, useTransition: function() {
    var r = Ad(!1), i = r[0];
    return r = r1.bind(null, r[1]), yi().memoizedState = r, [i, r];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(r, i, u) {
    var d = En, y = yi();
    if (Cn) {
      if (u === void 0)
        throw Error(s(407));
      u = u();
    } else {
      if (u = i(), Ln === null)
        throw Error(s(349));
      hl & 30 || Td(d, i, u);
    }
    y.memoizedState = u;
    var S = { value: u, getSnapshot: i };
    return y.queue = S, Od(Rd.bind(
      null,
      d,
      S,
      r
    ), [r]), d.flags |= 2048, bl(9, kd.bind(null, d, S, u, i), void 0, null), u;
  }, useId: function() {
    var r = yi(), i = Ln.identifierPrefix;
    if (Cn) {
      var u = Lo, d = Dr;
      u = (d & ~(1 << 32 - wa(d) - 1)).toString(32) + u, i = ":" + i + "R" + u, u = Xa++, 0 < u && (i += "H" + u.toString(32)), i += ":";
    } else
      u = ml++, i = ":" + i + "r" + u.toString(32) + ":";
    return r.memoizedState = i;
  }, unstable_isNewReconciler: !1 }, i1 = {
    readContext: Gn,
    useCallback: Cu,
    useContext: Gn,
    useEffect: Ic,
    useImperativeHandle: xu,
    useInsertionEffect: zd,
    useLayoutEffect: Pd,
    useMemo: ks,
    useReducer: Bc,
    useRef: Md,
    useState: function() {
      return Bc(gl);
    },
    useDebugValue: Ld,
    useDeferredValue: function(r) {
      var i = za();
      return Pa(i, oe.memoizedState, r);
    },
    useTransition: function() {
      var r = Bc(gl)[0], i = za().memoizedState;
      return [r, i];
    },
    useMutableSource: Ed,
    useSyncExternalStore: wd,
    useId: dn,
    unstable_isNewReconciler: !1
  }, nm = { readContext: Gn, useCallback: Cu, useContext: Gn, useEffect: Ic, useImperativeHandle: xu, useInsertionEffect: zd, useLayoutEffect: Pd, useMemo: ks, useReducer: Uc, useRef: Md, useState: function() {
    return Uc(gl);
  }, useDebugValue: Ld, useDeferredValue: function(r) {
    var i = za();
    return oe === null ? i.memoizedState = r : Pa(i, oe.memoizedState, r);
  }, useTransition: function() {
    var r = Uc(gl)[0], i = za().memoizedState;
    return [r, i];
  }, useMutableSource: Ed, useSyncExternalStore: wd, useId: dn, unstable_isNewReconciler: !1 };
  function wu(r, i) {
    try {
      var u = "", d = i;
      do
        u += Vn(d), d = d.return;
      while (d);
      var y = u;
    } catch (S) {
      y = `
Error generating stack: ` + S.message + `
` + S.stack;
    }
    return { value: r, source: i, stack: y, digest: null };
  }
  function Wc(r, i, u) {
    return { value: r, source: null, stack: u ?? null, digest: i ?? null };
  }
  function Vd(r, i) {
    try {
      console.error(i.value);
    } catch (u) {
      setTimeout(function() {
        throw u;
      });
    }
  }
  var o1 = typeof WeakMap == "function" ? WeakMap : Map;
  function fg(r, i, u) {
    u = No(-1, u), u.tag = 3, u.payload = { element: null };
    var d = i.value;
    return u.callback = function() {
      Yd || (Yd = !0, Tl = d), Vd(r, i);
    }, u;
  }
  function Yc(r, i, u) {
    u = No(-1, u), u.tag = 3;
    var d = r.type.getDerivedStateFromError;
    if (typeof d == "function") {
      var y = i.value;
      u.payload = function() {
        return d(y);
      }, u.callback = function() {
        Vd(r, i);
      };
    }
    var S = r.stateNode;
    return S !== null && typeof S.componentDidCatch == "function" && (u.callback = function() {
      Vd(r, i), typeof d != "function" && (oo === null ? oo = /* @__PURE__ */ new Set([this]) : oo.add(this));
      var R = i.stack;
      this.componentDidCatch(i.value, { componentStack: R !== null ? R : "" });
    }), u;
  }
  function dg(r, i, u) {
    var d = r.pingCache;
    if (d === null) {
      d = r.pingCache = new o1();
      var y = /* @__PURE__ */ new Set();
      d.set(i, y);
    } else
      y = d.get(i), y === void 0 && (y = /* @__PURE__ */ new Set(), d.set(i, y));
    y.has(u) || (y.add(u), r = p1.bind(null, r, i, u), i.then(r, r));
  }
  function rm(r) {
    do {
      var i;
      if ((i = r.tag === 13) && (i = r.memoizedState, i = i !== null ? i.dehydrated !== null : !0), i)
        return r;
      r = r.return;
    } while (r !== null);
    return null;
  }
  function am(r, i, u, d, y) {
    return r.mode & 1 ? (r.flags |= 65536, r.lanes = y, r) : (r === i ? r.flags |= 65536 : (r.flags |= 128, u.flags |= 131072, u.flags &= -52805, u.tag === 1 && (u.alternate === null ? u.tag = 17 : (i = No(-1, 1), i.tag = 2, Cs(u, i, 1))), u.lanes |= 1), r);
  }
  var s1 = ne.ReactCurrentOwner, er = !1;
  function or(r, i, u, d) {
    i.child = r === null ? ug(i, null, u, d) : bu(i, r.child, u, d);
  }
  function Rs(r, i, u, d, y) {
    u = u.render;
    var S = i.ref;
    return Se(i, y), d = Ts(r, i, u, d, S, y), u = yl(), r !== null && !er ? (i.updateQueue = r.updateQueue, i.flags &= -2053, r.lanes &= ~y, Mr(r, i, y)) : (Cn && u && fd(i), i.flags |= 1, or(r, i, d, y), i.child);
  }
  function jd(r, i, u, d, y) {
    if (r === null) {
      var S = u.type;
      return typeof S == "function" && !Em(S) && S.defaultProps === void 0 && u.compare === null && u.defaultProps === void 0 ? (i.tag = 15, i.type = S, La(r, i, S, d, y)) : (r = Zd(u.type, null, d, i, i.mode, y), r.ref = i.ref, r.return = i, i.child = r);
    }
    if (S = r.child, !(r.lanes & y)) {
      var R = S.memoizedProps;
      if (u = u.compare, u = u !== null ? u : Rc, u(R, d) && r.ref === i.ref)
        return Mr(r, i, y);
    }
    return i.flags |= 1, r = Ms(S, d), r.ref = i.ref, r.return = i, i.child = r;
  }
  function La(r, i, u, d, y) {
    if (r !== null) {
      var S = r.memoizedProps;
      if (Rc(S, d) && r.ref === i.ref)
        if (er = !1, i.pendingProps = d = S, (r.lanes & y) !== 0)
          r.flags & 131072 && (er = !0);
        else
          return i.lanes = r.lanes, Mr(r, i, y);
    }
    return Tu(r, i, u, d, y);
  }
  function xl(r, i, u) {
    var d = i.pendingProps, y = d.children, S = r !== null ? r.memoizedState : null;
    if (d.mode === "hidden")
      if (!(i.mode & 1))
        i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Qt(Mu, Za), Za |= u;
      else {
        if (!(u & 1073741824))
          return r = S !== null ? S.baseLanes | u : u, i.lanes = i.childLanes = 1073741824, i.memoizedState = { baseLanes: r, cachePool: null, transitions: null }, i.updateQueue = null, Qt(Mu, Za), Za |= r, null;
        i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = S !== null ? S.baseLanes : u, Qt(Mu, Za), Za |= d;
      }
    else
      S !== null ? (d = S.baseLanes | u, i.memoizedState = null) : d = u, Qt(Mu, Za), Za |= d;
    return or(r, i, y, u), i.child;
  }
  function pt(r, i) {
    var u = i.ref;
    (r === null && u !== null || r !== null && r.ref !== u) && (i.flags |= 512, i.flags |= 2097152);
  }
  function Tu(r, i, u, d, y) {
    var S = _n(u) ? _a : rt.current;
    return S = fi(i, S), Se(i, y), u = Ts(r, i, u, d, S, y), d = yl(), r !== null && !er ? (i.updateQueue = r.updateQueue, i.flags &= -2053, r.lanes &= ~y, Mr(r, i, y)) : (Cn && d && fd(i), i.flags |= 1, or(r, i, u, y), i.child);
  }
  function im(r, i, u, d, y) {
    if (_n(u)) {
      var S = !0;
      cd(i);
    } else
      S = !1;
    if (Se(i, y), i.stateNode === null)
      qr(r, i), ig(i, u, d), bd(i, u, d, y), d = !0;
    else if (r === null) {
      var R = i.stateNode, z = i.memoizedProps;
      R.props = z;
      var N = R.context, te = u.contextType;
      typeof te == "object" && te !== null ? te = Gn(te) : (te = _n(u) ? _a : rt.current, te = fi(i, te));
      var fe = u.getDerivedStateFromProps, de = typeof fe == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      de || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (z !== d || N !== te) && og(i, R, d, te), xs = !1;
      var ue = i.memoizedState;
      R.state = ue, Es(i, d, R, y), N = i.memoizedState, z !== d || ue !== N || Un.current || xs ? (typeof fe == "function" && (Zh(i, u, fe, d), N = i.memoizedState), (z = xs || ag(i, u, z, d, ue, N, te)) ? (de || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = d, i.memoizedState = N), R.props = d, R.state = N, R.context = te, d = z) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), d = !1);
    } else {
      R = i.stateNode, ir(r, i), z = i.memoizedProps, te = i.type === i.elementType ? z : Ka(i.type, z), R.props = te, de = i.pendingProps, ue = R.context, N = u.contextType, typeof N == "object" && N !== null ? N = Gn(N) : (N = _n(u) ? _a : rt.current, N = fi(i, N));
      var Te = u.getDerivedStateFromProps;
      (fe = typeof Te == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (z !== de || ue !== N) && og(i, R, d, N), xs = !1, ue = i.memoizedState, R.state = ue, Es(i, d, R, y);
      var ze = i.memoizedState;
      z !== de || ue !== ze || Un.current || xs ? (typeof Te == "function" && (Zh(i, u, Te, d), ze = i.memoizedState), (te = xs || ag(i, u, te, d, ue, ze, N) || !1) ? (fe || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(d, ze, N), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(d, ze, N)), typeof R.componentDidUpdate == "function" && (i.flags |= 4), typeof R.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || z === r.memoizedProps && ue === r.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || z === r.memoizedProps && ue === r.memoizedState || (i.flags |= 1024), i.memoizedProps = d, i.memoizedState = ze), R.props = d, R.state = ze, R.context = N, d = te) : (typeof R.componentDidUpdate != "function" || z === r.memoizedProps && ue === r.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || z === r.memoizedProps && ue === r.memoizedState || (i.flags |= 1024), d = !1);
    }
    return pg(r, i, u, d, S, y);
  }
  function pg(r, i, u, d, y, S) {
    pt(r, i);
    var R = (i.flags & 128) !== 0;
    if (!d && !R)
      return y && Zy(i, u, !1), Mr(r, i, S);
    d = i.stateNode, s1.current = i;
    var z = R && typeof u.getDerivedStateFromError != "function" ? null : d.render();
    return i.flags |= 1, r !== null && R ? (i.child = bu(i, r.child, null, S), i.child = bu(i, null, z, S)) : or(r, i, z, S), i.memoizedState = d.state, y && Zy(i, u, !0), i.child;
  }
  function hg(r) {
    var i = r.stateNode;
    i.pendingContext ? ys(r, i.pendingContext, i.pendingContext !== i.context) : i.context && ys(r, i.context, !1), Jh(r, i.containerInfo);
  }
  function Bd(r, i, u, d, y) {
    return zn(), Yh(y), i.flags |= 256, or(r, i, u, d), i.child;
  }
  var Cl = { dehydrated: null, treeContext: null, retryLane: 0 };
  function om(r) {
    return { baseLanes: r, cachePool: null, transitions: null };
  }
  function sm(r, i, u) {
    var d = i.pendingProps, y = Xe.current, S = !1, R = (i.flags & 128) !== 0, z;
    if ((z = R) || (z = r !== null && r.memoizedState === null ? !1 : (y & 2) !== 0), z ? (S = !0, i.flags &= -129) : (r === null || r.memoizedState !== null) && (y |= 1), Qt(Xe, y & 1), r === null)
      return pd(i), r = i.memoizedState, r !== null && (r = r.dehydrated, r !== null) ? (i.mode & 1 ? r.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824 : i.lanes = 1, null) : (R = d.children, r = d.fallback, S ? (d = i.mode, S = i.child, R = { mode: "hidden", children: R }, !(d & 1) && S !== null ? (S.childLanes = 0, S.pendingProps = R) : S = nf(R, d, 0, null), r = Al(r, d, u, null), S.return = i, r.return = i, S.sibling = r, i.child = S, i.child.memoizedState = om(u), i.memoizedState = Cl, r) : lm(i, R));
    if (y = r.memoizedState, y !== null && (z = y.dehydrated, z !== null))
      return l1(r, i, R, d, z, y, u);
    if (S) {
      S = d.fallback, R = i.mode, y = r.child, z = y.sibling;
      var N = { mode: "hidden", children: d.children };
      return !(R & 1) && i.child !== y ? (d = i.child, d.childLanes = 0, d.pendingProps = N, i.deletions = null) : (d = Ms(y, N), d.subtreeFlags = y.subtreeFlags & 14680064), z !== null ? S = Ms(z, S) : (S = Al(S, R, u, null), S.flags |= 2), S.return = i, d.return = i, d.sibling = S, i.child = d, d = S, S = i.child, R = r.child.memoizedState, R = R === null ? om(u) : { baseLanes: R.baseLanes | u, cachePool: null, transitions: R.transitions }, S.memoizedState = R, S.childLanes = r.childLanes & ~u, i.memoizedState = Cl, d;
    }
    return S = r.child, r = S.sibling, d = Ms(S, { mode: "visible", children: d.children }), !(i.mode & 1) && (d.lanes = u), d.return = i, d.sibling = null, r !== null && (u = i.deletions, u === null ? (i.deletions = [r], i.flags |= 16) : u.push(r)), i.child = d, i.memoizedState = null, d;
  }
  function lm(r, i) {
    return i = nf({ mode: "visible", children: i }, r.mode, 0, null), i.return = r, r.child = i;
  }
  function ku(r, i, u, d) {
    return d !== null && Yh(d), bu(i, r.child, null, u), r = lm(i, i.pendingProps.children), r.flags |= 2, i.memoizedState = null, r;
  }
  function l1(r, i, u, d, y, S, R) {
    if (u)
      return i.flags & 256 ? (i.flags &= -257, d = Wc(Error(s(422))), ku(r, i, R, d)) : i.memoizedState !== null ? (i.child = r.child, i.flags |= 128, null) : (S = d.fallback, y = i.mode, d = nf({ mode: "visible", children: d.children }, y, 0, null), S = Al(S, y, R, null), S.flags |= 2, d.return = i, S.return = i, d.sibling = S, i.child = d, i.mode & 1 && bu(i, r.child, null, R), i.child.memoizedState = om(R), i.memoizedState = Cl, S);
    if (!(i.mode & 1))
      return ku(r, i, R, null);
    if (y.data === "$!") {
      if (d = y.nextSibling && y.nextSibling.dataset, d)
        var z = d.dgst;
      return d = z, S = Error(s(419)), d = Wc(S, d, void 0), ku(r, i, R, d);
    }
    if (z = (R & r.childLanes) !== 0, er || z) {
      if (d = Ln, d !== null) {
        switch (R & -R) {
          case 4:
            y = 2;
            break;
          case 16:
            y = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            y = 32;
            break;
          case 536870912:
            y = 268435456;
            break;
          default:
            y = 0;
        }
        y = y & (d.suspendedLanes | R) ? 0 : y, y !== 0 && y !== S.retryLane && (S.retryLane = y, $o(r, y), Zr(d, r, y, -1));
      }
      return Sm(), d = Wc(Error(s(421))), ku(r, i, R, d);
    }
    return y.data === "$?" ? (i.flags |= 128, i.child = r.child, i = h1.bind(null, r), y._reactRetry = i, null) : (r = S.treeContext, Oa = ji(y.nextSibling), Qa = i, Cn = !0, hi = null, r !== null && (Ma[Gr++] = Dr, Ma[Gr++] = Lo, Ma[Gr++] = pi, Dr = r.id, Lo = r.overflow, pi = i), i = lm(i, d.children), i.flags |= 4096, i);
  }
  function um(r, i, u) {
    r.lanes |= i;
    var d = r.alternate;
    d !== null && (d.lanes |= i), br(r.return, i, u);
  }
  function Ud(r, i, u, d, y) {
    var S = r.memoizedState;
    S === null ? r.memoizedState = { isBackwards: i, rendering: null, renderingStartTime: 0, last: d, tail: u, tailMode: y } : (S.isBackwards = i, S.rendering = null, S.renderingStartTime = 0, S.last = d, S.tail = u, S.tailMode = y);
  }
  function cm(r, i, u) {
    var d = i.pendingProps, y = d.revealOrder, S = d.tail;
    if (or(r, i, d.children, u), d = Xe.current, d & 2)
      d = d & 1 | 2, i.flags |= 128;
    else {
      if (r !== null && r.flags & 128)
        e:
          for (r = i.child; r !== null; ) {
            if (r.tag === 13)
              r.memoizedState !== null && um(r, u, i);
            else if (r.tag === 19)
              um(r, u, i);
            else if (r.child !== null) {
              r.child.return = r, r = r.child;
              continue;
            }
            if (r === i)
              break e;
            for (; r.sibling === null; ) {
              if (r.return === null || r.return === i)
                break e;
              r = r.return;
            }
            r.sibling.return = r.return, r = r.sibling;
          }
      d &= 1;
    }
    if (Qt(Xe, d), !(i.mode & 1))
      i.memoizedState = null;
    else
      switch (y) {
        case "forwards":
          for (u = i.child, y = null; u !== null; )
            r = u.alternate, r !== null && Pn(r) === null && (y = u), u = u.sibling;
          u = y, u === null ? (y = i.child, i.child = null) : (y = u.sibling, u.sibling = null), Ud(i, !1, y, u, S);
          break;
        case "backwards":
          for (u = null, y = i.child, i.child = null; y !== null; ) {
            if (r = y.alternate, r !== null && Pn(r) === null) {
              i.child = y;
              break;
            }
            r = y.sibling, y.sibling = u, u = y, y = r;
          }
          Ud(i, !0, u, null, S);
          break;
        case "together":
          Ud(i, !1, null, null, void 0);
          break;
        default:
          i.memoizedState = null;
      }
    return i.child;
  }
  function qr(r, i) {
    !(i.mode & 1) && r !== null && (r.alternate = null, i.alternate = null, i.flags |= 2);
  }
  function Mr(r, i, u) {
    if (r !== null && (i.dependencies = r.dependencies), Bo |= i.lanes, !(u & i.childLanes))
      return null;
    if (r !== null && i.child !== r.child)
      throw Error(s(153));
    if (i.child !== null) {
      for (r = i.child, u = Ms(r, r.pendingProps), i.child = u, u.return = i; r.sibling !== null; )
        r = r.sibling, u = u.sibling = Ms(r, r.pendingProps), u.return = i;
      u.sibling = null;
    }
    return i.child;
  }
  function Vo(r, i, u) {
    switch (i.tag) {
      case 3:
        hg(i), zn();
        break;
      case 5:
        Qe(i);
        break;
      case 1:
        _n(i.type) && cd(i);
        break;
      case 4:
        Jh(i, i.stateNode.containerInfo);
        break;
      case 10:
        var d = i.type._context, y = i.memoizedProps.value;
        Qt(no, d._currentValue), d._currentValue = y;
        break;
      case 13:
        if (d = i.memoizedState, d !== null)
          return d.dehydrated !== null ? (Qt(Xe, Xe.current & 1), i.flags |= 128, null) : u & i.child.childLanes ? sm(r, i, u) : (Qt(Xe, Xe.current & 1), r = Mr(r, i, u), r !== null ? r.sibling : null);
        Qt(Xe, Xe.current & 1);
        break;
      case 19:
        if (d = (u & i.childLanes) !== 0, r.flags & 128) {
          if (d)
            return cm(r, i, u);
          i.flags |= 128;
        }
        if (y = i.memoizedState, y !== null && (y.rendering = null, y.tail = null, y.lastEffect = null), Qt(Xe, Xe.current), d)
          break;
        return null;
      case 22:
      case 23:
        return i.lanes = 0, xl(r, i, u);
    }
    return Mr(r, i, u);
  }
  var Gc, El, gi, sr;
  Gc = function(r, i) {
    for (var u = i.child; u !== null; ) {
      if (u.tag === 5 || u.tag === 6)
        r.appendChild(u.stateNode);
      else if (u.tag !== 4 && u.child !== null) {
        u.child.return = u, u = u.child;
        continue;
      }
      if (u === i)
        break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === i)
          return;
        u = u.return;
      }
      u.sibling.return = u.return, u = u.sibling;
    }
  }, El = function() {
  }, gi = function(r, i, u, d) {
    var y = r.memoizedProps;
    if (y !== d) {
      r = i.stateNode, pl(Bi.current);
      var S = null;
      switch (u) {
        case "input":
          y = Mn(r, y), d = Mn(r, d), S = [];
          break;
        case "select":
          y = ve({}, y, { value: void 0 }), d = ve({}, d, { value: void 0 }), S = [];
          break;
        case "textarea":
          y = Br(r, y), d = Br(r, d), S = [];
          break;
        default:
          typeof y.onClick != "function" && typeof d.onClick == "function" && (r.onclick = ud);
      }
      pn(u, d);
      var R;
      u = null;
      for (te in y)
        if (!d.hasOwnProperty(te) && y.hasOwnProperty(te) && y[te] != null)
          if (te === "style") {
            var z = y[te];
            for (R in z)
              z.hasOwnProperty(R) && (u || (u = {}), u[R] = "");
          } else
            te !== "dangerouslySetInnerHTML" && te !== "children" && te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && te !== "autoFocus" && (p.hasOwnProperty(te) ? S || (S = []) : (S = S || []).push(te, null));
      for (te in d) {
        var N = d[te];
        if (z = y != null ? y[te] : void 0, d.hasOwnProperty(te) && N !== z && (N != null || z != null))
          if (te === "style")
            if (z) {
              for (R in z)
                !z.hasOwnProperty(R) || N && N.hasOwnProperty(R) || (u || (u = {}), u[R] = "");
              for (R in N)
                N.hasOwnProperty(R) && z[R] !== N[R] && (u || (u = {}), u[R] = N[R]);
            } else
              u || (S || (S = []), S.push(
                te,
                u
              )), u = N;
          else
            te === "dangerouslySetInnerHTML" ? (N = N ? N.__html : void 0, z = z ? z.__html : void 0, N != null && z !== N && (S = S || []).push(te, N)) : te === "children" ? typeof N != "string" && typeof N != "number" || (S = S || []).push(te, "" + N) : te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && (p.hasOwnProperty(te) ? (N != null && te === "onScroll" && fn("scroll", r), S || z === N || (S = [])) : (S = S || []).push(te, N));
      }
      u && (S = S || []).push("style", u);
      var te = S;
      (i.updateQueue = te) && (i.flags |= 4);
    }
  }, sr = function(r, i, u, d) {
    u !== d && (i.flags |= 4);
  };
  function qc(r, i) {
    if (!Cn)
      switch (r.tailMode) {
        case "hidden":
          i = r.tail;
          for (var u = null; i !== null; )
            i.alternate !== null && (u = i), i = i.sibling;
          u === null ? r.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = r.tail;
          for (var d = null; u !== null; )
            u.alternate !== null && (d = u), u = u.sibling;
          d === null ? i || r.tail === null ? r.tail = null : r.tail.sibling = null : d.sibling = null;
      }
  }
  function Qr(r) {
    var i = r.alternate !== null && r.alternate.child === r.child, u = 0, d = 0;
    if (i)
      for (var y = r.child; y !== null; )
        u |= y.lanes | y.childLanes, d |= y.subtreeFlags & 14680064, d |= y.flags & 14680064, y.return = r, y = y.sibling;
    else
      for (y = r.child; y !== null; )
        u |= y.lanes | y.childLanes, d |= y.subtreeFlags, d |= y.flags, y.return = r, y = y.sibling;
    return r.subtreeFlags |= d, r.childLanes = u, i;
  }
  function u1(r, i, u) {
    var d = i.pendingProps;
    switch (Hh(i), i.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Qr(i), null;
      case 1:
        return _n(i.type) && di(), Qr(i), null;
      case 3:
        return d = i.stateNode, ws(), Yt(Un), Yt(rt), xd(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (r === null || r.child === null) && (hd(i) ? i.flags |= 4 : r === null || r.memoizedState.isDehydrated && !(i.flags & 256) || (i.flags |= 1024, hi !== null && (tf(hi), hi = null))), El(r, i), Qr(i), null;
      case 5:
        xt(i);
        var y = pl(Su.current);
        if (u = i.type, r !== null && i.stateNode != null)
          gi(r, i, u, d, y), r.ref !== i.ref && (i.flags |= 512, i.flags |= 2097152);
        else {
          if (!d) {
            if (i.stateNode === null)
              throw Error(s(166));
            return Qr(i), null;
          }
          if (r = pl(Bi.current), hd(i)) {
            d = i.stateNode, u = i.type;
            var S = i.memoizedProps;
            switch (d[eo] = i, d[cl] = S, r = (i.mode & 1) !== 0, u) {
              case "dialog":
                fn("cancel", d), fn("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                fn("load", d);
                break;
              case "video":
              case "audio":
                for (y = 0; y < Mc.length; y++)
                  fn(Mc[y], d);
                break;
              case "source":
                fn("error", d);
                break;
              case "img":
              case "image":
              case "link":
                fn(
                  "error",
                  d
                ), fn("load", d);
                break;
              case "details":
                fn("toggle", d);
                break;
              case "input":
                jn(d, S), fn("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!S.multiple }, fn("invalid", d);
                break;
              case "textarea":
                On(d, S), fn("invalid", d);
            }
            pn(u, S), y = null;
            for (var R in S)
              if (S.hasOwnProperty(R)) {
                var z = S[R];
                R === "children" ? typeof z == "string" ? d.textContent !== z && (S.suppressHydrationWarning !== !0 && ld(d.textContent, z, r), y = ["children", z]) : typeof z == "number" && d.textContent !== "" + z && (S.suppressHydrationWarning !== !0 && ld(
                  d.textContent,
                  z,
                  r
                ), y = ["children", "" + z]) : p.hasOwnProperty(R) && z != null && R === "onScroll" && fn("scroll", d);
              }
            switch (u) {
              case "input":
                $t(d), ba(d, S, !0);
                break;
              case "textarea":
                $t(d), Ur(d);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof S.onClick == "function" && (d.onclick = ud);
            }
            d = y, i.updateQueue = d, d !== null && (i.flags |= 4);
          } else {
            R = y.nodeType === 9 ? y : y.ownerDocument, r === "http://www.w3.org/1999/xhtml" && (r = Ha(u)), r === "http://www.w3.org/1999/xhtml" ? u === "script" ? (r = R.createElement("div"), r.innerHTML = "<script><\/script>", r = r.removeChild(r.firstChild)) : typeof d.is == "string" ? r = R.createElement(u, { is: d.is }) : (r = R.createElement(u), u === "select" && (R = r, d.multiple ? R.multiple = !0 : d.size && (R.size = d.size))) : r = R.createElementNS(r, u), r[eo] = i, r[cl] = d, Gc(r, i, !1, !1), i.stateNode = r;
            e: {
              switch (R = hn(u, d), u) {
                case "dialog":
                  fn("cancel", r), fn("close", r), y = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  fn("load", r), y = d;
                  break;
                case "video":
                case "audio":
                  for (y = 0; y < Mc.length; y++)
                    fn(Mc[y], r);
                  y = d;
                  break;
                case "source":
                  fn("error", r), y = d;
                  break;
                case "img":
                case "image":
                case "link":
                  fn(
                    "error",
                    r
                  ), fn("load", r), y = d;
                  break;
                case "details":
                  fn("toggle", r), y = d;
                  break;
                case "input":
                  jn(r, d), y = Mn(r, d), fn("invalid", r);
                  break;
                case "option":
                  y = d;
                  break;
                case "select":
                  r._wrapperState = { wasMultiple: !!d.multiple }, y = ve({}, d, { value: void 0 }), fn("invalid", r);
                  break;
                case "textarea":
                  On(r, d), y = Br(r, d), fn("invalid", r);
                  break;
                default:
                  y = d;
              }
              pn(u, y), z = y;
              for (S in z)
                if (z.hasOwnProperty(S)) {
                  var N = z[S];
                  S === "style" ? Ut(r, N) : S === "dangerouslySetInnerHTML" ? (N = N ? N.__html : void 0, N != null && zi(r, N)) : S === "children" ? typeof N == "string" ? (u !== "textarea" || N !== "") && Ca(r, N) : typeof N == "number" && Ca(r, "" + N) : S !== "suppressContentEditableWarning" && S !== "suppressHydrationWarning" && S !== "autoFocus" && (p.hasOwnProperty(S) ? N != null && S === "onScroll" && fn("scroll", r) : N != null && F(r, S, N, R));
                }
              switch (u) {
                case "input":
                  $t(r), ba(r, d, !1);
                  break;
                case "textarea":
                  $t(r), Ur(r);
                  break;
                case "option":
                  d.value != null && r.setAttribute("value", "" + Ot(d.value));
                  break;
                case "select":
                  r.multiple = !!d.multiple, S = d.value, S != null ? xa(r, !!d.multiple, S, !1) : d.defaultValue != null && xa(
                    r,
                    !!d.multiple,
                    d.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof y.onClick == "function" && (r.onclick = ud);
              }
              switch (u) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break e;
                case "img":
                  d = !0;
                  break e;
                default:
                  d = !1;
              }
            }
            d && (i.flags |= 4);
          }
          i.ref !== null && (i.flags |= 512, i.flags |= 2097152);
        }
        return Qr(i), null;
      case 6:
        if (r && i.stateNode != null)
          sr(r, i, r.memoizedProps, d);
        else {
          if (typeof d != "string" && i.stateNode === null)
            throw Error(s(166));
          if (u = pl(Su.current), pl(Bi.current), hd(i)) {
            if (d = i.stateNode, u = i.memoizedProps, d[eo] = i, (S = d.nodeValue !== u) && (r = Qa, r !== null))
              switch (r.tag) {
                case 3:
                  ld(d.nodeValue, u, (r.mode & 1) !== 0);
                  break;
                case 5:
                  r.memoizedProps.suppressHydrationWarning !== !0 && ld(d.nodeValue, u, (r.mode & 1) !== 0);
              }
            S && (i.flags |= 4);
          } else
            d = (u.nodeType === 9 ? u : u.ownerDocument).createTextNode(d), d[eo] = i, i.stateNode = d;
        }
        return Qr(i), null;
      case 13:
        if (Yt(Xe), d = i.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
          if (Cn && Oa !== null && i.mode & 1 && !(i.flags & 128))
            tg(), zn(), i.flags |= 98560, S = !1;
          else if (S = hd(i), d !== null && d.dehydrated !== null) {
            if (r === null) {
              if (!S)
                throw Error(s(318));
              if (S = i.memoizedState, S = S !== null ? S.dehydrated : null, !S)
                throw Error(s(317));
              S[eo] = i;
            } else
              zn(), !(i.flags & 128) && (i.memoizedState = null), i.flags |= 4;
            Qr(i), S = !1;
          } else
            hi !== null && (tf(hi), hi = null), S = !0;
          if (!S)
            return i.flags & 65536 ? i : null;
        }
        return i.flags & 128 ? (i.lanes = u, i) : (d = d !== null, d !== (r !== null && r.memoizedState !== null) && d && (i.child.flags |= 8192, i.mode & 1 && (r === null || Xe.current & 1 ? ur === 0 && (ur = 3) : Sm())), i.updateQueue !== null && (i.flags |= 4), Qr(i), null);
      case 4:
        return ws(), El(r, i), r === null && mu(i.stateNode.containerInfo), Qr(i), null;
      case 10:
        return Ss(i.type._context), Qr(i), null;
      case 17:
        return _n(i.type) && di(), Qr(i), null;
      case 19:
        if (Yt(Xe), S = i.memoizedState, S === null)
          return Qr(i), null;
        if (d = (i.flags & 128) !== 0, R = S.rendering, R === null)
          if (d)
            qc(S, !1);
          else {
            if (ur !== 0 || r !== null && r.flags & 128)
              for (r = i.child; r !== null; ) {
                if (R = Pn(r), R !== null) {
                  for (i.flags |= 128, qc(S, !1), d = R.updateQueue, d !== null && (i.updateQueue = d, i.flags |= 4), i.subtreeFlags = 0, d = u, u = i.child; u !== null; )
                    S = u, r = d, S.flags &= 14680066, R = S.alternate, R === null ? (S.childLanes = 0, S.lanes = r, S.child = null, S.subtreeFlags = 0, S.memoizedProps = null, S.memoizedState = null, S.updateQueue = null, S.dependencies = null, S.stateNode = null) : (S.childLanes = R.childLanes, S.lanes = R.lanes, S.child = R.child, S.subtreeFlags = 0, S.deletions = null, S.memoizedProps = R.memoizedProps, S.memoizedState = R.memoizedState, S.updateQueue = R.updateQueue, S.type = R.type, r = R.dependencies, S.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }), u = u.sibling;
                  return Qt(Xe, Xe.current & 1 | 2), i.child;
                }
                r = r.sibling;
              }
            S.tail !== null && Et() > zu && (i.flags |= 128, d = !0, qc(S, !1), i.lanes = 4194304);
          }
        else {
          if (!d)
            if (r = Pn(R), r !== null) {
              if (i.flags |= 128, d = !0, u = r.updateQueue, u !== null && (i.updateQueue = u, i.flags |= 4), qc(S, !0), S.tail === null && S.tailMode === "hidden" && !R.alternate && !Cn)
                return Qr(i), null;
            } else
              2 * Et() - S.renderingStartTime > zu && u !== 1073741824 && (i.flags |= 128, d = !0, qc(S, !1), i.lanes = 4194304);
          S.isBackwards ? (R.sibling = i.child, i.child = R) : (u = S.last, u !== null ? u.sibling = R : i.child = R, S.last = R);
        }
        return S.tail !== null ? (i = S.tail, S.rendering = i, S.tail = i.sibling, S.renderingStartTime = Et(), i.sibling = null, u = Xe.current, Qt(Xe, d ? u & 1 | 2 : u & 1), i) : (Qr(i), null);
      case 22:
      case 23:
        return bm(), d = i.memoizedState !== null, r !== null && r.memoizedState !== null !== d && (i.flags |= 8192), d && i.mode & 1 ? Za & 1073741824 && (Qr(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : Qr(i), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(s(156, i.tag));
  }
  function fm(r, i) {
    switch (Hh(i), i.tag) {
      case 1:
        return _n(i.type) && di(), r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 3:
        return ws(), Yt(Un), Yt(rt), xd(), r = i.flags, r & 65536 && !(r & 128) ? (i.flags = r & -65537 | 128, i) : null;
      case 5:
        return xt(i), null;
      case 13:
        if (Yt(Xe), r = i.memoizedState, r !== null && r.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(s(340));
          zn();
        }
        return r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 19:
        return Yt(Xe), null;
      case 4:
        return ws(), null;
      case 10:
        return Ss(i.type._context), null;
      case 22:
      case 23:
        return bm(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Qc = !1, lr = !1, mg = typeof WeakSet == "function" ? WeakSet : Set, Me = null;
  function Ru(r, i) {
    var u = r.ref;
    if (u !== null)
      if (typeof u == "function")
        try {
          u(null);
        } catch (d) {
          Hn(r, i, d);
        }
      else
        u.current = null;
  }
  function Kc(r, i, u) {
    try {
      u();
    } catch (d) {
      Hn(r, i, d);
    }
  }
  var vg = !1;
  function yg(r, i) {
    if ($h = _o, r = rd(), Mo(r)) {
      if ("selectionStart" in r)
        var u = { start: r.selectionStart, end: r.selectionEnd };
      else
        e: {
          u = (u = r.ownerDocument) && u.defaultView || window;
          var d = u.getSelection && u.getSelection();
          if (d && d.rangeCount !== 0) {
            u = d.anchorNode;
            var y = d.anchorOffset, S = d.focusNode;
            d = d.focusOffset;
            try {
              u.nodeType, S.nodeType;
            } catch {
              u = null;
              break e;
            }
            var R = 0, z = -1, N = -1, te = 0, fe = 0, de = r, ue = null;
            t:
              for (; ; ) {
                for (var Te; de !== u || y !== 0 && de.nodeType !== 3 || (z = R + y), de !== S || d !== 0 && de.nodeType !== 3 || (N = R + d), de.nodeType === 3 && (R += de.nodeValue.length), (Te = de.firstChild) !== null; )
                  ue = de, de = Te;
                for (; ; ) {
                  if (de === r)
                    break t;
                  if (ue === u && ++te === y && (z = R), ue === S && ++fe === d && (N = R), (Te = de.nextSibling) !== null)
                    break;
                  de = ue, ue = de.parentNode;
                }
                de = Te;
              }
            u = z === -1 || N === -1 ? null : { start: z, end: N };
          } else
            u = null;
        }
      u = u || { start: 0, end: 0 };
    } else
      u = null;
    for (ll = { focusedElem: r, selectionRange: u }, _o = !1, Me = i; Me !== null; )
      if (i = Me, r = i.child, (i.subtreeFlags & 1028) !== 0 && r !== null)
        r.return = i, Me = r;
      else
        for (; Me !== null; ) {
          i = Me;
          try {
            var ze = i.alternate;
            if (i.flags & 1024)
              switch (i.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (ze !== null) {
                    var Ne = ze.memoizedProps, qn = ze.memoizedState, G = i.stateNode, B = G.getSnapshotBeforeUpdate(i.elementType === i.type ? Ne : Ka(i.type, Ne), qn);
                    G.__reactInternalSnapshotBeforeUpdate = B;
                  }
                  break;
                case 3:
                  var X = i.stateNode.containerInfo;
                  X.nodeType === 1 ? X.textContent = "" : X.nodeType === 9 && X.documentElement && X.removeChild(X.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(s(163));
              }
          } catch (me) {
            Hn(i, i.return, me);
          }
          if (r = i.sibling, r !== null) {
            r.return = i.return, Me = r;
            break;
          }
          Me = i.return;
        }
    return ze = vg, vg = !1, ze;
  }
  function Xc(r, i, u) {
    var d = i.updateQueue;
    if (d = d !== null ? d.lastEffect : null, d !== null) {
      var y = d = d.next;
      do {
        if ((y.tag & r) === r) {
          var S = y.destroy;
          y.destroy = void 0, S !== void 0 && Kc(i, u, S);
        }
        y = y.next;
      } while (y !== d);
    }
  }
  function Zc(r, i) {
    if (i = i.updateQueue, i = i !== null ? i.lastEffect : null, i !== null) {
      var u = i = i.next;
      do {
        if ((u.tag & r) === r) {
          var d = u.create;
          u.destroy = d();
        }
        u = u.next;
      } while (u !== i);
    }
  }
  function dm(r) {
    var i = r.ref;
    if (i !== null) {
      var u = r.stateNode;
      switch (r.tag) {
        case 5:
          r = u;
          break;
        default:
          r = u;
      }
      typeof i == "function" ? i(r) : i.current = r;
    }
  }
  function pm(r) {
    var i = r.alternate;
    i !== null && (r.alternate = null, pm(i)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (i = r.stateNode, i !== null && (delete i[eo], delete i[cl], delete i[Vh], delete i[n1], delete i[jh])), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
  }
  function gg(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 4;
  }
  function Id(r) {
    e:
      for (; ; ) {
        for (; r.sibling === null; ) {
          if (r.return === null || gg(r.return))
            return null;
          r = r.return;
        }
        for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
          if (r.flags & 2 || r.child === null || r.tag === 4)
            continue e;
          r.child.return = r, r = r.child;
        }
        if (!(r.flags & 2))
          return r.stateNode;
      }
  }
  function _u(r, i, u) {
    var d = r.tag;
    if (d === 5 || d === 6)
      r = r.stateNode, i ? u.nodeType === 8 ? u.parentNode.insertBefore(r, i) : u.insertBefore(r, i) : (u.nodeType === 8 ? (i = u.parentNode, i.insertBefore(r, u)) : (i = u, i.appendChild(r)), u = u._reactRootContainer, u != null || i.onclick !== null || (i.onclick = ud));
    else if (d !== 4 && (r = r.child, r !== null))
      for (_u(r, i, u), r = r.sibling; r !== null; )
        _u(r, i, u), r = r.sibling;
  }
  function ao(r, i, u) {
    var d = r.tag;
    if (d === 5 || d === 6)
      r = r.stateNode, i ? u.insertBefore(r, i) : u.appendChild(r);
    else if (d !== 4 && (r = r.child, r !== null))
      for (ao(r, i, u), r = r.sibling; r !== null; )
        ao(r, i, u), r = r.sibling;
  }
  var Dn = null, Sr = !1;
  function bi(r, i, u) {
    for (u = u.child; u !== null; )
      Du(r, i, u), u = u.sibling;
  }
  function Du(r, i, u) {
    if (Ea && typeof Ea.onCommitFiberUnmount == "function")
      try {
        Ea.onCommitFiberUnmount(Zs, u);
      } catch {
      }
    switch (u.tag) {
      case 5:
        lr || Ru(u, i);
      case 6:
        var d = Dn, y = Sr;
        Dn = null, bi(r, i, u), Dn = d, Sr = y, Dn !== null && (Sr ? (r = Dn, u = u.stateNode, r.nodeType === 8 ? r.parentNode.removeChild(u) : r.removeChild(u)) : Dn.removeChild(u.stateNode));
        break;
      case 18:
        Dn !== null && (Sr ? (r = Dn, u = u.stateNode, r.nodeType === 8 ? hs(r.parentNode, u) : r.nodeType === 1 && hs(r, u), rl(r)) : hs(Dn, u.stateNode));
        break;
      case 4:
        d = Dn, y = Sr, Dn = u.stateNode.containerInfo, Sr = !0, bi(r, i, u), Dn = d, Sr = y;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!lr && (d = u.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
          y = d = d.next;
          do {
            var S = y, R = S.destroy;
            S = S.tag, R !== void 0 && (S & 2 || S & 4) && Kc(u, i, R), y = y.next;
          } while (y !== d);
        }
        bi(r, i, u);
        break;
      case 1:
        if (!lr && (Ru(u, i), d = u.stateNode, typeof d.componentWillUnmount == "function"))
          try {
            d.props = u.memoizedProps, d.state = u.memoizedState, d.componentWillUnmount();
          } catch (z) {
            Hn(u, i, z);
          }
        bi(r, i, u);
        break;
      case 21:
        bi(r, i, u);
        break;
      case 22:
        u.mode & 1 ? (lr = (d = lr) || u.memoizedState !== null, bi(r, i, u), lr = d) : bi(r, i, u);
        break;
      default:
        bi(r, i, u);
    }
  }
  function jo(r) {
    var i = r.updateQueue;
    if (i !== null) {
      r.updateQueue = null;
      var u = r.stateNode;
      u === null && (u = r.stateNode = new mg()), i.forEach(function(d) {
        var y = m1.bind(null, r, d);
        u.has(d) || (u.add(d), d.then(y, y));
      });
    }
  }
  function Ui(r, i) {
    var u = i.deletions;
    if (u !== null)
      for (var d = 0; d < u.length; d++) {
        var y = u[d];
        try {
          var S = r, R = i, z = R;
          e:
            for (; z !== null; ) {
              switch (z.tag) {
                case 5:
                  Dn = z.stateNode, Sr = !1;
                  break e;
                case 3:
                  Dn = z.stateNode.containerInfo, Sr = !0;
                  break e;
                case 4:
                  Dn = z.stateNode.containerInfo, Sr = !0;
                  break e;
              }
              z = z.return;
            }
          if (Dn === null)
            throw Error(s(160));
          Du(S, R, y), Dn = null, Sr = !1;
          var N = y.alternate;
          N !== null && (N.return = null), y.return = null;
        } catch (te) {
          Hn(y, i, te);
        }
      }
    if (i.subtreeFlags & 12854)
      for (i = i.child; i !== null; )
        bg(i, r), i = i.sibling;
  }
  function bg(r, i) {
    var u = r.alternate, d = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Ui(i, r), io(r), d & 4) {
          try {
            Xc(3, r, r.return), Zc(3, r);
          } catch (Ne) {
            Hn(r, r.return, Ne);
          }
          try {
            Xc(5, r, r.return);
          } catch (Ne) {
            Hn(r, r.return, Ne);
          }
        }
        break;
      case 1:
        Ui(i, r), io(r), d & 512 && u !== null && Ru(u, u.return);
        break;
      case 5:
        if (Ui(i, r), io(r), d & 512 && u !== null && Ru(u, u.return), r.flags & 32) {
          var y = r.stateNode;
          try {
            Ca(y, "");
          } catch (Ne) {
            Hn(r, r.return, Ne);
          }
        }
        if (d & 4 && (y = r.stateNode, y != null)) {
          var S = r.memoizedProps, R = u !== null ? u.memoizedProps : S, z = r.type, N = r.updateQueue;
          if (r.updateQueue = null, N !== null)
            try {
              z === "input" && S.type === "radio" && S.name != null && pr(y, S), hn(z, R);
              var te = hn(z, S);
              for (R = 0; R < N.length; R += 2) {
                var fe = N[R], de = N[R + 1];
                fe === "style" ? Ut(y, de) : fe === "dangerouslySetInnerHTML" ? zi(y, de) : fe === "children" ? Ca(y, de) : F(y, fe, de, te);
              }
              switch (z) {
                case "input":
                  hr(y, S);
                  break;
                case "textarea":
                  Ia(y, S);
                  break;
                case "select":
                  var ue = y._wrapperState.wasMultiple;
                  y._wrapperState.wasMultiple = !!S.multiple;
                  var Te = S.value;
                  Te != null ? xa(y, !!S.multiple, Te, !1) : ue !== !!S.multiple && (S.defaultValue != null ? xa(
                    y,
                    !!S.multiple,
                    S.defaultValue,
                    !0
                  ) : xa(y, !!S.multiple, S.multiple ? [] : "", !1));
              }
              y[cl] = S;
            } catch (Ne) {
              Hn(r, r.return, Ne);
            }
        }
        break;
      case 6:
        if (Ui(i, r), io(r), d & 4) {
          if (r.stateNode === null)
            throw Error(s(162));
          y = r.stateNode, S = r.memoizedProps;
          try {
            y.nodeValue = S;
          } catch (Ne) {
            Hn(r, r.return, Ne);
          }
        }
        break;
      case 3:
        if (Ui(i, r), io(r), d & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            rl(i.containerInfo);
          } catch (Ne) {
            Hn(r, r.return, Ne);
          }
        break;
      case 4:
        Ui(i, r), io(r);
        break;
      case 13:
        Ui(i, r), io(r), y = r.child, y.flags & 8192 && (S = y.memoizedState !== null, y.stateNode.isHidden = S, !S || y.alternate !== null && y.alternate.memoizedState !== null || (vm = Et())), d & 4 && jo(r);
        break;
      case 22:
        if (fe = u !== null && u.memoizedState !== null, r.mode & 1 ? (lr = (te = lr) || fe, Ui(i, r), lr = te) : Ui(i, r), io(r), d & 8192) {
          if (te = r.memoizedState !== null, (r.stateNode.isHidden = te) && !fe && r.mode & 1)
            for (Me = r, fe = r.child; fe !== null; ) {
              for (de = Me = fe; Me !== null; ) {
                switch (ue = Me, Te = ue.child, ue.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Xc(4, ue, ue.return);
                    break;
                  case 1:
                    Ru(ue, ue.return);
                    var ze = ue.stateNode;
                    if (typeof ze.componentWillUnmount == "function") {
                      d = ue, u = ue.return;
                      try {
                        i = d, ze.props = i.memoizedProps, ze.state = i.memoizedState, ze.componentWillUnmount();
                      } catch (Ne) {
                        Hn(d, u, Ne);
                      }
                    }
                    break;
                  case 5:
                    Ru(ue, ue.return);
                    break;
                  case 22:
                    if (ue.memoizedState !== null) {
                      hm(de);
                      continue;
                    }
                }
                Te !== null ? (Te.return = ue, Me = Te) : hm(de);
              }
              fe = fe.sibling;
            }
          e:
            for (fe = null, de = r; ; ) {
              if (de.tag === 5) {
                if (fe === null) {
                  fe = de;
                  try {
                    y = de.stateNode, te ? (S = y.style, typeof S.setProperty == "function" ? S.setProperty("display", "none", "important") : S.display = "none") : (z = de.stateNode, N = de.memoizedProps.style, R = N != null && N.hasOwnProperty("display") ? N.display : null, z.style.display = ht("display", R));
                  } catch (Ne) {
                    Hn(r, r.return, Ne);
                  }
                }
              } else if (de.tag === 6) {
                if (fe === null)
                  try {
                    de.stateNode.nodeValue = te ? "" : de.memoizedProps;
                  } catch (Ne) {
                    Hn(r, r.return, Ne);
                  }
              } else if ((de.tag !== 22 && de.tag !== 23 || de.memoizedState === null || de === r) && de.child !== null) {
                de.child.return = de, de = de.child;
                continue;
              }
              if (de === r)
                break e;
              for (; de.sibling === null; ) {
                if (de.return === null || de.return === r)
                  break e;
                fe === de && (fe = null), de = de.return;
              }
              fe === de && (fe = null), de.sibling.return = de.return, de = de.sibling;
            }
        }
        break;
      case 19:
        Ui(i, r), io(r), d & 4 && jo(r);
        break;
      case 21:
        break;
      default:
        Ui(
          i,
          r
        ), io(r);
    }
  }
  function io(r) {
    var i = r.flags;
    if (i & 2) {
      try {
        e: {
          for (var u = r.return; u !== null; ) {
            if (gg(u)) {
              var d = u;
              break e;
            }
            u = u.return;
          }
          throw Error(s(160));
        }
        switch (d.tag) {
          case 5:
            var y = d.stateNode;
            d.flags & 32 && (Ca(y, ""), d.flags &= -33);
            var S = Id(r);
            ao(r, S, y);
            break;
          case 3:
          case 4:
            var R = d.stateNode.containerInfo, z = Id(r);
            _u(r, z, R);
            break;
          default:
            throw Error(s(161));
        }
      } catch (N) {
        Hn(r, r.return, N);
      }
      r.flags &= -3;
    }
    i & 4096 && (r.flags &= -4097);
  }
  function Sg(r, i, u) {
    Me = r, Au(r);
  }
  function Au(r, i, u) {
    for (var d = (r.mode & 1) !== 0; Me !== null; ) {
      var y = Me, S = y.child;
      if (y.tag === 22 && d) {
        var R = y.memoizedState !== null || Qc;
        if (!R) {
          var z = y.alternate, N = z !== null && z.memoizedState !== null || lr;
          z = Qc;
          var te = lr;
          if (Qc = R, (lr = N) && !te)
            for (Me = y; Me !== null; )
              R = Me, N = R.child, R.tag === 22 && R.memoizedState !== null ? Cg(y) : N !== null ? (N.return = R, Me = N) : Cg(y);
          for (; S !== null; )
            Me = S, Au(S), S = S.sibling;
          Me = y, Qc = z, lr = te;
        }
        xg(r);
      } else
        y.subtreeFlags & 8772 && S !== null ? (S.return = y, Me = S) : xg(r);
    }
  }
  function xg(r) {
    for (; Me !== null; ) {
      var i = Me;
      if (i.flags & 8772) {
        var u = i.alternate;
        try {
          if (i.flags & 8772)
            switch (i.tag) {
              case 0:
              case 11:
              case 15:
                lr || Zc(5, i);
                break;
              case 1:
                var d = i.stateNode;
                if (i.flags & 4 && !lr)
                  if (u === null)
                    d.componentDidMount();
                  else {
                    var y = i.elementType === i.type ? u.memoizedProps : Ka(i.type, u.memoizedProps);
                    d.componentDidUpdate(y, u.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                var S = i.updateQueue;
                S !== null && dl(i, S, d);
                break;
              case 3:
                var R = i.updateQueue;
                if (R !== null) {
                  if (u = null, i.child !== null)
                    switch (i.child.tag) {
                      case 5:
                        u = i.child.stateNode;
                        break;
                      case 1:
                        u = i.child.stateNode;
                    }
                  dl(i, R, u);
                }
                break;
              case 5:
                var z = i.stateNode;
                if (u === null && i.flags & 4) {
                  u = z;
                  var N = i.memoizedProps;
                  switch (i.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      N.autoFocus && u.focus();
                      break;
                    case "img":
                      N.src && (u.src = N.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (i.memoizedState === null) {
                  var te = i.alternate;
                  if (te !== null) {
                    var fe = te.memoizedState;
                    if (fe !== null) {
                      var de = fe.dehydrated;
                      de !== null && rl(de);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(s(163));
            }
          lr || i.flags & 512 && dm(i);
        } catch (ue) {
          Hn(i, i.return, ue);
        }
      }
      if (i === r) {
        Me = null;
        break;
      }
      if (u = i.sibling, u !== null) {
        u.return = i.return, Me = u;
        break;
      }
      Me = i.return;
    }
  }
  function hm(r) {
    for (; Me !== null; ) {
      var i = Me;
      if (i === r) {
        Me = null;
        break;
      }
      var u = i.sibling;
      if (u !== null) {
        u.return = i.return, Me = u;
        break;
      }
      Me = i.return;
    }
  }
  function Cg(r) {
    for (; Me !== null; ) {
      var i = Me;
      try {
        switch (i.tag) {
          case 0:
          case 11:
          case 15:
            var u = i.return;
            try {
              Zc(4, i);
            } catch (N) {
              Hn(i, u, N);
            }
            break;
          case 1:
            var d = i.stateNode;
            if (typeof d.componentDidMount == "function") {
              var y = i.return;
              try {
                d.componentDidMount();
              } catch (N) {
                Hn(i, y, N);
              }
            }
            var S = i.return;
            try {
              dm(i);
            } catch (N) {
              Hn(i, S, N);
            }
            break;
          case 5:
            var R = i.return;
            try {
              dm(i);
            } catch (N) {
              Hn(i, R, N);
            }
        }
      } catch (N) {
        Hn(i, i.return, N);
      }
      if (i === r) {
        Me = null;
        break;
      }
      var z = i.sibling;
      if (z !== null) {
        z.return = i.return, Me = z;
        break;
      }
      Me = i.return;
    }
  }
  var Hd = Math.ceil, Jc = ne.ReactCurrentDispatcher, mm = ne.ReactCurrentOwner, Kr = ne.ReactCurrentBatchConfig, wt = 0, Ln = null, In = null, xr = 0, Za = 0, Mu = dt(0), ur = 0, ef = null, Bo = 0, Wd = 0, Ou = 0, wl = null, ia = null, vm = 0, zu = 1 / 0, Uo = null, Yd = !1, Tl = null, oo = null, _s = !1, Ds = null, Gd = 0, Pu = 0, qd = null, kl = -1, Rl = 0;
  function Xr() {
    return wt & 6 ? Et() : kl !== -1 ? kl : kl = Et();
  }
  function tr(r) {
    return r.mode & 1 ? wt & 2 && xr !== 0 ? xr & -xr : md.transition !== null ? (Rl === 0 && (Rl = au()), Rl) : (r = It, r !== 0 || (r = window.event, r = r === void 0 ? 16 : Wt(r.type)), r) : 1;
  }
  function Zr(r, i, u, d) {
    if (50 < Pu)
      throw Pu = 0, qd = null, Error(s(185));
    Ji(r, u, d), (!(wt & 2) || r !== Ln) && (r === Ln && (!(wt & 2) && (Wd |= u), ur === 4 && Si(r, xr)), Jr(r, d), u === 1 && wt === 0 && !(i.mode & 1) && (zu = Et() + 500, gr && Da()));
  }
  function Jr(r, i) {
    var u = r.callbackNode;
    wo(r, i);
    var d = Ya(r, r === Ln ? xr : 0);
    if (d === 0)
      u !== null && Rr(u), r.callbackNode = null, r.callbackPriority = 0;
    else if (i = d & -d, r.callbackPriority !== i) {
      if (u != null && Rr(u), i === 1)
        r.tag === 0 ? Uh(Eg.bind(null, r)) : Bh(Eg.bind(null, r)), Fh(function() {
          !(wt & 6) && Da();
        }), u = null;
      else {
        switch (iu(d)) {
          case 1:
            u = Pi;
            break;
          case 4:
            u = mt;
            break;
          case 16:
            u = Li;
            break;
          case 536870912:
            u = gc;
            break;
          default:
            u = Li;
        }
        u = Cm(u, Lu.bind(null, r));
      }
      r.callbackPriority = i, r.callbackNode = u;
    }
  }
  function Lu(r, i) {
    if (kl = -1, Rl = 0, wt & 6)
      throw Error(s(327));
    var u = r.callbackNode;
    if (Nu() && r.callbackNode !== u)
      return null;
    var d = Ya(r, r === Ln ? xr : 0);
    if (d === 0)
      return null;
    if (d & 30 || d & r.expiredLanes || i)
      i = Kd(r, d);
    else {
      i = d;
      var y = wt;
      wt |= 2;
      var S = Qd();
      (Ln !== r || xr !== i) && (Uo = null, zu = Et() + 500, _l(r, i));
      do
        try {
          f1();
          break;
        } catch (z) {
          wg(r, z);
        }
      while (!0);
      qh(), Jc.current = S, wt = y, In !== null ? i = 0 : (Ln = null, xr = 0, i = ur);
    }
    if (i !== 0) {
      if (i === 2 && (y = Js(r), y !== 0 && (d = y, i = ym(r, y))), i === 1)
        throw u = ef, _l(r, 0), Si(r, d), Jr(r, Et()), u;
      if (i === 6)
        Si(r, d);
      else {
        if (y = r.current.alternate, !(d & 30) && !gm(y) && (i = Kd(r, d), i === 2 && (S = Js(r), S !== 0 && (d = S, i = ym(r, S))), i === 1))
          throw u = ef, _l(r, 0), Si(r, d), Jr(r, Et()), u;
        switch (r.finishedWork = y, r.finishedLanes = d, i) {
          case 0:
          case 1:
            throw Error(s(345));
          case 2:
            Dl(r, ia, Uo);
            break;
          case 3:
            if (Si(r, d), (d & 130023424) === d && (i = vm + 500 - Et(), 10 < i)) {
              if (Ya(r, 0) !== 0)
                break;
              if (y = r.suspendedLanes, (y & d) !== d) {
                Xr(), r.pingedLanes |= r.suspendedLanes & y;
                break;
              }
              r.timeoutHandle = ul(Dl.bind(null, r, ia, Uo), i);
              break;
            }
            Dl(r, ia, Uo);
            break;
          case 4:
            if (Si(r, d), (d & 4194240) === d)
              break;
            for (i = r.eventTimes, y = -1; 0 < d; ) {
              var R = 31 - wa(d);
              S = 1 << R, R = i[R], R > y && (y = R), d &= ~S;
            }
            if (d = y, d = Et() - d, d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * Hd(d / 1960)) - d, 10 < d) {
              r.timeoutHandle = ul(Dl.bind(null, r, ia, Uo), d);
              break;
            }
            Dl(r, ia, Uo);
            break;
          case 5:
            Dl(r, ia, Uo);
            break;
          default:
            throw Error(s(329));
        }
      }
    }
    return Jr(r, Et()), r.callbackNode === u ? Lu.bind(null, r) : null;
  }
  function ym(r, i) {
    var u = wl;
    return r.current.memoizedState.isDehydrated && (_l(r, i).flags |= 256), r = Kd(r, i), r !== 2 && (i = ia, ia = u, i !== null && tf(i)), r;
  }
  function tf(r) {
    ia === null ? ia = r : ia.push.apply(ia, r);
  }
  function gm(r) {
    for (var i = r; ; ) {
      if (i.flags & 16384) {
        var u = i.updateQueue;
        if (u !== null && (u = u.stores, u !== null))
          for (var d = 0; d < u.length; d++) {
            var y = u[d], S = y.getSnapshot;
            y = y.value;
            try {
              if (!ui(S(), y))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (u = i.child, i.subtreeFlags & 16384 && u !== null)
        u.return = i, i = u;
      else {
        if (i === r)
          break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === r)
            return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Si(r, i) {
    for (i &= ~Ou, i &= ~Wd, r.suspendedLanes |= i, r.pingedLanes &= ~i, r = r.expirationTimes; 0 < i; ) {
      var u = 31 - wa(i), d = 1 << u;
      r[u] = -1, i &= ~d;
    }
  }
  function Eg(r) {
    if (wt & 6)
      throw Error(s(327));
    Nu();
    var i = Ya(r, 0);
    if (!(i & 1))
      return Jr(r, Et()), null;
    var u = Kd(r, i);
    if (r.tag !== 0 && u === 2) {
      var d = Js(r);
      d !== 0 && (i = d, u = ym(r, d));
    }
    if (u === 1)
      throw u = ef, _l(r, 0), Si(r, i), Jr(r, Et()), u;
    if (u === 6)
      throw Error(s(345));
    return r.finishedWork = r.current.alternate, r.finishedLanes = i, Dl(r, ia, Uo), Jr(r, Et()), null;
  }
  function $u(r, i) {
    var u = wt;
    wt |= 1;
    try {
      return r(i);
    } finally {
      wt = u, wt === 0 && (zu = Et() + 500, gr && Da());
    }
  }
  function As(r) {
    Ds !== null && Ds.tag === 0 && !(wt & 6) && Nu();
    var i = wt;
    wt |= 1;
    var u = Kr.transition, d = It;
    try {
      if (Kr.transition = null, It = 1, r)
        return r();
    } finally {
      It = d, Kr.transition = u, wt = i, !(wt & 6) && Da();
    }
  }
  function bm() {
    Za = Mu.current, Yt(Mu);
  }
  function _l(r, i) {
    r.finishedWork = null, r.finishedLanes = 0;
    var u = r.timeoutHandle;
    if (u !== -1 && (r.timeoutHandle = -1, Xy(u)), In !== null)
      for (u = In.return; u !== null; ) {
        var d = u;
        switch (Hh(d), d.tag) {
          case 1:
            d = d.type.childContextTypes, d != null && di();
            break;
          case 3:
            ws(), Yt(Un), Yt(rt), xd();
            break;
          case 5:
            xt(d);
            break;
          case 4:
            ws();
            break;
          case 13:
            Yt(Xe);
            break;
          case 19:
            Yt(Xe);
            break;
          case 10:
            Ss(d.type._context);
            break;
          case 22:
          case 23:
            bm();
        }
        u = u.return;
      }
    if (Ln = r, In = r = Ms(r.current, null), xr = Za = i, ur = 0, ef = null, Ou = Wd = Bo = 0, ia = wl = null, Ar !== null) {
      for (i = 0; i < Ar.length; i++)
        if (u = Ar[i], d = u.interleaved, d !== null) {
          u.interleaved = null;
          var y = d.next, S = u.pending;
          if (S !== null) {
            var R = S.next;
            S.next = y, d.next = R;
          }
          u.pending = d;
        }
      Ar = null;
    }
    return r;
  }
  function wg(r, i) {
    do {
      var u = In;
      try {
        if (qh(), Cd.current = Fd, Ze) {
          for (var d = En.memoizedState; d !== null; ) {
            var y = d.queue;
            y !== null && (y.pending = null), d = d.next;
          }
          Ze = !1;
        }
        if (hl = 0, _t = oe = En = null, ro = !1, Xa = 0, mm.current = null, u === null || u.return === null) {
          ur = 1, ef = i, In = null;
          break;
        }
        e: {
          var S = r, R = u.return, z = u, N = i;
          if (i = xr, z.flags |= 32768, N !== null && typeof N == "object" && typeof N.then == "function") {
            var te = N, fe = z, de = fe.tag;
            if (!(fe.mode & 1) && (de === 0 || de === 11 || de === 15)) {
              var ue = fe.alternate;
              ue ? (fe.updateQueue = ue.updateQueue, fe.memoizedState = ue.memoizedState, fe.lanes = ue.lanes) : (fe.updateQueue = null, fe.memoizedState = null);
            }
            var Te = rm(R);
            if (Te !== null) {
              Te.flags &= -257, am(Te, R, z, S, i), Te.mode & 1 && dg(S, te, i), i = Te, N = te;
              var ze = i.updateQueue;
              if (ze === null) {
                var Ne = /* @__PURE__ */ new Set();
                Ne.add(N), i.updateQueue = Ne;
              } else
                ze.add(N);
              break e;
            } else {
              if (!(i & 1)) {
                dg(S, te, i), Sm();
                break e;
              }
              N = Error(s(426));
            }
          } else if (Cn && z.mode & 1) {
            var qn = rm(R);
            if (qn !== null) {
              !(qn.flags & 65536) && (qn.flags |= 256), am(qn, R, z, S, i), Yh(wu(N, z));
              break e;
            }
          }
          S = N = wu(N, z), ur !== 4 && (ur = 2), wl === null ? wl = [S] : wl.push(S), S = R;
          do {
            switch (S.tag) {
              case 3:
                S.flags |= 65536, i &= -i, S.lanes |= i;
                var G = fg(S, N, i);
                Xh(S, G);
                break e;
              case 1:
                z = N;
                var B = S.type, X = S.stateNode;
                if (!(S.flags & 128) && (typeof B.getDerivedStateFromError == "function" || X !== null && typeof X.componentDidCatch == "function" && (oo === null || !oo.has(X)))) {
                  S.flags |= 65536, i &= -i, S.lanes |= i;
                  var me = Yc(S, z, i);
                  Xh(S, me);
                  break e;
                }
            }
            S = S.return;
          } while (S !== null);
        }
        xm(u);
      } catch (Ve) {
        i = Ve, In === u && u !== null && (In = u = u.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Qd() {
    var r = Jc.current;
    return Jc.current = Fd, r === null ? Fd : r;
  }
  function Sm() {
    (ur === 0 || ur === 3 || ur === 2) && (ur = 4), Ln === null || !(Bo & 268435455) && !(Wd & 268435455) || Si(Ln, xr);
  }
  function Kd(r, i) {
    var u = wt;
    wt |= 2;
    var d = Qd();
    (Ln !== r || xr !== i) && (Uo = null, _l(r, i));
    do
      try {
        c1();
        break;
      } catch (y) {
        wg(r, y);
      }
    while (!0);
    if (qh(), wt = u, Jc.current = d, In !== null)
      throw Error(s(261));
    return Ln = null, xr = 0, ur;
  }
  function c1() {
    for (; In !== null; )
      Tg(In);
  }
  function f1() {
    for (; In !== null && !li(); )
      Tg(In);
  }
  function Tg(r) {
    var i = Rg(r.alternate, r, Za);
    r.memoizedProps = r.pendingProps, i === null ? xm(r) : In = i, mm.current = null;
  }
  function xm(r) {
    var i = r;
    do {
      var u = i.alternate;
      if (r = i.return, i.flags & 32768) {
        if (u = fm(u, i), u !== null) {
          u.flags &= 32767, In = u;
          return;
        }
        if (r !== null)
          r.flags |= 32768, r.subtreeFlags = 0, r.deletions = null;
        else {
          ur = 6, In = null;
          return;
        }
      } else if (u = u1(u, i, Za), u !== null) {
        In = u;
        return;
      }
      if (i = i.sibling, i !== null) {
        In = i;
        return;
      }
      In = i = r;
    } while (i !== null);
    ur === 0 && (ur = 5);
  }
  function Dl(r, i, u) {
    var d = It, y = Kr.transition;
    try {
      Kr.transition = null, It = 1, d1(r, i, u, d);
    } finally {
      Kr.transition = y, It = d;
    }
    return null;
  }
  function d1(r, i, u, d) {
    do
      Nu();
    while (Ds !== null);
    if (wt & 6)
      throw Error(s(327));
    u = r.finishedWork;
    var y = r.finishedLanes;
    if (u === null)
      return null;
    if (r.finishedWork = null, r.finishedLanes = 0, u === r.current)
      throw Error(s(177));
    r.callbackNode = null, r.callbackPriority = 0;
    var S = u.lanes | u.childLanes;
    if (yh(r, S), r === Ln && (In = Ln = null, xr = 0), !(u.subtreeFlags & 2064) && !(u.flags & 2064) || _s || (_s = !0, Cm(Li, function() {
      return Nu(), null;
    })), S = (u.flags & 15990) !== 0, u.subtreeFlags & 15990 || S) {
      S = Kr.transition, Kr.transition = null;
      var R = It;
      It = 1;
      var z = wt;
      wt |= 4, mm.current = null, yg(r, u), bg(u, r), ad(ll), _o = !!$h, ll = $h = null, r.current = u, Sg(u), nu(), wt = z, It = R, Kr.transition = S;
    } else
      r.current = u;
    if (_s && (_s = !1, Ds = r, Gd = y), S = r.pendingLanes, S === 0 && (oo = null), Wf(u.stateNode), Jr(r, Et()), i !== null)
      for (d = r.onRecoverableError, u = 0; u < i.length; u++)
        y = i[u], d(y.value, { componentStack: y.stack, digest: y.digest });
    if (Yd)
      throw Yd = !1, r = Tl, Tl = null, r;
    return Gd & 1 && r.tag !== 0 && Nu(), S = r.pendingLanes, S & 1 ? r === qd ? Pu++ : (Pu = 0, qd = r) : Pu = 0, Da(), null;
  }
  function Nu() {
    if (Ds !== null) {
      var r = iu(Gd), i = Kr.transition, u = It;
      try {
        if (Kr.transition = null, It = 16 > r ? 16 : r, Ds === null)
          var d = !1;
        else {
          if (r = Ds, Ds = null, Gd = 0, wt & 6)
            throw Error(s(331));
          var y = wt;
          for (wt |= 4, Me = r.current; Me !== null; ) {
            var S = Me, R = S.child;
            if (Me.flags & 16) {
              var z = S.deletions;
              if (z !== null) {
                for (var N = 0; N < z.length; N++) {
                  var te = z[N];
                  for (Me = te; Me !== null; ) {
                    var fe = Me;
                    switch (fe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Xc(8, fe, S);
                    }
                    var de = fe.child;
                    if (de !== null)
                      de.return = fe, Me = de;
                    else
                      for (; Me !== null; ) {
                        fe = Me;
                        var ue = fe.sibling, Te = fe.return;
                        if (pm(fe), fe === te) {
                          Me = null;
                          break;
                        }
                        if (ue !== null) {
                          ue.return = Te, Me = ue;
                          break;
                        }
                        Me = Te;
                      }
                  }
                }
                var ze = S.alternate;
                if (ze !== null) {
                  var Ne = ze.child;
                  if (Ne !== null) {
                    ze.child = null;
                    do {
                      var qn = Ne.sibling;
                      Ne.sibling = null, Ne = qn;
                    } while (Ne !== null);
                  }
                }
                Me = S;
              }
            }
            if (S.subtreeFlags & 2064 && R !== null)
              R.return = S, Me = R;
            else
              e:
                for (; Me !== null; ) {
                  if (S = Me, S.flags & 2048)
                    switch (S.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Xc(9, S, S.return);
                    }
                  var G = S.sibling;
                  if (G !== null) {
                    G.return = S.return, Me = G;
                    break e;
                  }
                  Me = S.return;
                }
          }
          var B = r.current;
          for (Me = B; Me !== null; ) {
            R = Me;
            var X = R.child;
            if (R.subtreeFlags & 2064 && X !== null)
              X.return = R, Me = X;
            else
              e:
                for (R = B; Me !== null; ) {
                  if (z = Me, z.flags & 2048)
                    try {
                      switch (z.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Zc(9, z);
                      }
                    } catch (Ve) {
                      Hn(z, z.return, Ve);
                    }
                  if (z === R) {
                    Me = null;
                    break e;
                  }
                  var me = z.sibling;
                  if (me !== null) {
                    me.return = z.return, Me = me;
                    break e;
                  }
                  Me = z.return;
                }
          }
          if (wt = y, Da(), Ea && typeof Ea.onPostCommitFiberRoot == "function")
            try {
              Ea.onPostCommitFiberRoot(Zs, r);
            } catch {
            }
          d = !0;
        }
        return d;
      } finally {
        It = u, Kr.transition = i;
      }
    }
    return !1;
  }
  function kg(r, i, u) {
    i = wu(u, i), i = fg(r, i, 1), r = Cs(r, i, 1), i = Xr(), r !== null && (Ji(r, 1, i), Jr(r, i));
  }
  function Hn(r, i, u) {
    if (r.tag === 3)
      kg(r, r, u);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          kg(i, r, u);
          break;
        } else if (i.tag === 1) {
          var d = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (oo === null || !oo.has(d))) {
            r = wu(u, r), r = Yc(i, r, 1), i = Cs(i, r, 1), r = Xr(), i !== null && (Ji(i, 1, r), Jr(i, r));
            break;
          }
        }
        i = i.return;
      }
  }
  function p1(r, i, u) {
    var d = r.pingCache;
    d !== null && d.delete(i), i = Xr(), r.pingedLanes |= r.suspendedLanes & u, Ln === r && (xr & u) === u && (ur === 4 || ur === 3 && (xr & 130023424) === xr && 500 > Et() - vm ? _l(r, 0) : Ou |= u), Jr(r, i);
  }
  function Xd(r, i) {
    i === 0 && (r.mode & 1 ? (i = fs, fs <<= 1, !(fs & 130023424) && (fs = 4194304)) : i = 1);
    var u = Xr();
    r = $o(r, i), r !== null && (Ji(r, i, u), Jr(r, u));
  }
  function h1(r) {
    var i = r.memoizedState, u = 0;
    i !== null && (u = i.retryLane), Xd(r, u);
  }
  function m1(r, i) {
    var u = 0;
    switch (r.tag) {
      case 13:
        var d = r.stateNode, y = r.memoizedState;
        y !== null && (u = y.retryLane);
        break;
      case 19:
        d = r.stateNode;
        break;
      default:
        throw Error(s(314));
    }
    d !== null && d.delete(i), Xd(r, u);
  }
  var Rg;
  Rg = function(r, i, u) {
    if (r !== null)
      if (r.memoizedProps !== i.pendingProps || Un.current)
        er = !0;
      else {
        if (!(r.lanes & u) && !(i.flags & 128))
          return er = !1, Vo(r, i, u);
        er = !!(r.flags & 131072);
      }
    else
      er = !1, Cn && i.flags & 1048576 && Ih(i, yu, i.index);
    switch (i.lanes = 0, i.tag) {
      case 2:
        var d = i.type;
        qr(r, i), r = i.pendingProps;
        var y = fi(i, rt.current);
        Se(i, u), y = Ts(null, i, d, r, y, u);
        var S = yl();
        return i.flags |= 1, typeof y == "object" && y !== null && typeof y.render == "function" && y.$$typeof === void 0 ? (i.tag = 1, i.memoizedState = null, i.updateQueue = null, _n(d) ? (S = !0, cd(i)) : S = !1, i.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, Kh(i), y.updater = gd, i.stateNode = y, y._reactInternals = i, bd(i, d, r, u), i = pg(null, i, d, !0, S, u)) : (i.tag = 0, Cn && S && fd(i), or(null, i, y, u), i = i.child), i;
      case 16:
        d = i.elementType;
        e: {
          switch (qr(r, i), r = i.pendingProps, y = d._init, d = y(d._payload), i.type = d, y = i.tag = y1(d), r = Ka(d, r), y) {
            case 0:
              i = Tu(null, i, d, r, u);
              break e;
            case 1:
              i = im(null, i, d, r, u);
              break e;
            case 11:
              i = Rs(null, i, d, r, u);
              break e;
            case 14:
              i = jd(null, i, d, Ka(d.type, r), u);
              break e;
          }
          throw Error(s(
            306,
            d,
            ""
          ));
        }
        return i;
      case 0:
        return d = i.type, y = i.pendingProps, y = i.elementType === d ? y : Ka(d, y), Tu(r, i, d, y, u);
      case 1:
        return d = i.type, y = i.pendingProps, y = i.elementType === d ? y : Ka(d, y), im(r, i, d, y, u);
      case 3:
        e: {
          if (hg(i), r === null)
            throw Error(s(387));
          d = i.pendingProps, S = i.memoizedState, y = S.element, ir(r, i), Es(i, d, null, u);
          var R = i.memoizedState;
          if (d = R.element, S.isDehydrated)
            if (S = { element: d, isDehydrated: !1, cache: R.cache, pendingSuspenseBoundaries: R.pendingSuspenseBoundaries, transitions: R.transitions }, i.updateQueue.baseState = S, i.memoizedState = S, i.flags & 256) {
              y = wu(Error(s(423)), i), i = Bd(r, i, d, u, y);
              break e;
            } else if (d !== y) {
              y = wu(Error(s(424)), i), i = Bd(r, i, d, u, y);
              break e;
            } else
              for (Oa = ji(i.stateNode.containerInfo.firstChild), Qa = i, Cn = !0, hi = null, u = ug(i, null, d, u), i.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
          else {
            if (zn(), d === y) {
              i = Mr(r, i, u);
              break e;
            }
            or(r, i, d, u);
          }
          i = i.child;
        }
        return i;
      case 5:
        return Qe(i), r === null && pd(i), d = i.type, y = i.pendingProps, S = r !== null ? r.memoizedProps : null, R = y.children, Pc(d, y) ? R = null : S !== null && Pc(d, S) && (i.flags |= 32), pt(r, i), or(r, i, R, u), i.child;
      case 6:
        return r === null && pd(i), null;
      case 13:
        return sm(r, i, u);
      case 4:
        return Jh(i, i.stateNode.containerInfo), d = i.pendingProps, r === null ? i.child = bu(i, null, d, u) : or(r, i, d, u), i.child;
      case 11:
        return d = i.type, y = i.pendingProps, y = i.elementType === d ? y : Ka(d, y), Rs(r, i, d, y, u);
      case 7:
        return or(r, i, i.pendingProps, u), i.child;
      case 8:
        return or(r, i, i.pendingProps.children, u), i.child;
      case 12:
        return or(r, i, i.pendingProps.children, u), i.child;
      case 10:
        e: {
          if (d = i.type._context, y = i.pendingProps, S = i.memoizedProps, R = y.value, Qt(no, d._currentValue), d._currentValue = R, S !== null)
            if (ui(S.value, R)) {
              if (S.children === y.children && !Un.current) {
                i = Mr(r, i, u);
                break e;
              }
            } else
              for (S = i.child, S !== null && (S.return = i); S !== null; ) {
                var z = S.dependencies;
                if (z !== null) {
                  R = S.child;
                  for (var N = z.firstContext; N !== null; ) {
                    if (N.context === d) {
                      if (S.tag === 1) {
                        N = No(-1, u & -u), N.tag = 2;
                        var te = S.updateQueue;
                        if (te !== null) {
                          te = te.shared;
                          var fe = te.pending;
                          fe === null ? N.next = N : (N.next = fe.next, fe.next = N), te.pending = N;
                        }
                      }
                      S.lanes |= u, N = S.alternate, N !== null && (N.lanes |= u), br(
                        S.return,
                        u,
                        i
                      ), z.lanes |= u;
                      break;
                    }
                    N = N.next;
                  }
                } else if (S.tag === 10)
                  R = S.type === i.type ? null : S.child;
                else if (S.tag === 18) {
                  if (R = S.return, R === null)
                    throw Error(s(341));
                  R.lanes |= u, z = R.alternate, z !== null && (z.lanes |= u), br(R, u, i), R = S.sibling;
                } else
                  R = S.child;
                if (R !== null)
                  R.return = S;
                else
                  for (R = S; R !== null; ) {
                    if (R === i) {
                      R = null;
                      break;
                    }
                    if (S = R.sibling, S !== null) {
                      S.return = R.return, R = S;
                      break;
                    }
                    R = R.return;
                  }
                S = R;
              }
          or(r, i, y.children, u), i = i.child;
        }
        return i;
      case 9:
        return y = i.type, d = i.pendingProps.children, Se(i, u), y = Gn(y), d = d(y), i.flags |= 1, or(r, i, d, u), i.child;
      case 14:
        return d = i.type, y = Ka(d, i.pendingProps), y = Ka(d.type, y), jd(r, i, d, y, u);
      case 15:
        return La(r, i, i.type, i.pendingProps, u);
      case 17:
        return d = i.type, y = i.pendingProps, y = i.elementType === d ? y : Ka(d, y), qr(r, i), i.tag = 1, _n(d) ? (r = !0, cd(i)) : r = !1, Se(i, u), ig(i, d, y), bd(i, d, y, u), pg(null, i, d, !0, r, u);
      case 19:
        return cm(r, i, u);
      case 22:
        return xl(r, i, u);
    }
    throw Error(s(156, i.tag));
  };
  function Cm(r, i) {
    return vn(r, i);
  }
  function v1(r, i, u, d) {
    this.tag = r, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function xi(r, i, u, d) {
    return new v1(r, i, u, d);
  }
  function Em(r) {
    return r = r.prototype, !(!r || !r.isReactComponent);
  }
  function y1(r) {
    if (typeof r == "function")
      return Em(r) ? 1 : 0;
    if (r != null) {
      if (r = r.$$typeof, r === Rt)
        return 11;
      if (r === jt)
        return 14;
    }
    return 2;
  }
  function Ms(r, i) {
    var u = r.alternate;
    return u === null ? (u = xi(r.tag, i, r.key, r.mode), u.elementType = r.elementType, u.type = r.type, u.stateNode = r.stateNode, u.alternate = r, r.alternate = u) : (u.pendingProps = i, u.type = r.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = r.flags & 14680064, u.childLanes = r.childLanes, u.lanes = r.lanes, u.child = r.child, u.memoizedProps = r.memoizedProps, u.memoizedState = r.memoizedState, u.updateQueue = r.updateQueue, i = r.dependencies, u.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, u.sibling = r.sibling, u.index = r.index, u.ref = r.ref, u;
  }
  function Zd(r, i, u, d, y, S) {
    var R = 2;
    if (d = r, typeof r == "function")
      Em(r) && (R = 1);
    else if (typeof r == "string")
      R = 5;
    else
      e:
        switch (r) {
          case re:
            return Al(u.children, y, S, i);
          case De:
            R = 8, y |= 8;
            break;
          case Fe:
            return r = xi(12, u, i, y | 2), r.elementType = Fe, r.lanes = S, r;
          case $e:
            return r = xi(13, u, i, y), r.elementType = $e, r.lanes = S, r;
          case Be:
            return r = xi(19, u, i, y), r.elementType = Be, r.lanes = S, r;
          case Lt:
            return nf(u, y, S, i);
          default:
            if (typeof r == "object" && r !== null)
              switch (r.$$typeof) {
                case ot:
                  R = 10;
                  break e;
                case vt:
                  R = 9;
                  break e;
                case Rt:
                  R = 11;
                  break e;
                case jt:
                  R = 14;
                  break e;
                case tt:
                  R = 16, d = null;
                  break e;
              }
            throw Error(s(130, r == null ? r : typeof r, ""));
        }
    return i = xi(R, u, i, y), i.elementType = r, i.type = d, i.lanes = S, i;
  }
  function Al(r, i, u, d) {
    return r = xi(7, r, d, i), r.lanes = u, r;
  }
  function nf(r, i, u, d) {
    return r = xi(22, r, d, i), r.elementType = Lt, r.lanes = u, r.stateNode = { isHidden: !1 }, r;
  }
  function rf(r, i, u) {
    return r = xi(6, r, null, i), r.lanes = u, r;
  }
  function Ml(r, i, u) {
    return i = xi(4, r.children !== null ? r.children : [], r.key, i), i.lanes = u, i.stateNode = { containerInfo: r.containerInfo, pendingChildren: null, implementation: r.implementation }, i;
  }
  function g1(r, i, u, d, y) {
    this.tag = i, this.containerInfo = r, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Sc(0), this.expirationTimes = Sc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Sc(0), this.identifierPrefix = d, this.onRecoverableError = y, this.mutableSourceEagerHydrationData = null;
  }
  function Jd(r, i, u, d, y, S, R, z, N) {
    return r = new g1(r, i, u, z, N), i === 1 ? (i = 1, S === !0 && (i |= 8)) : i = 0, S = xi(3, null, null, i), r.current = S, S.stateNode = r, S.memoizedState = { element: d, isDehydrated: u, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Kh(S), r;
  }
  function _g(r, i, u) {
    var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: le, key: d == null ? null : "" + d, children: r, containerInfo: i, implementation: u };
  }
  function wm(r) {
    if (!r)
      return to;
    r = r._reactInternals;
    e: {
      if (ct(r) !== r || r.tag !== 1)
        throw Error(s(170));
      var i = r;
      do {
        switch (i.tag) {
          case 3:
            i = i.stateNode.context;
            break e;
          case 1:
            if (_n(i.type)) {
              i = i.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        i = i.return;
      } while (i !== null);
      throw Error(s(171));
    }
    if (r.tag === 1) {
      var u = r.type;
      if (_n(u))
        return Nc(r, u, i);
    }
    return i;
  }
  function Dg(r, i, u, d, y, S, R, z, N) {
    return r = Jd(u, d, !0, r, y, S, R, z, N), r.context = wm(null), u = r.current, d = Xr(), y = tr(u), S = No(d, y), S.callback = i ?? null, Cs(u, S, y), r.current.lanes = y, Ji(r, y, d), Jr(r, d), r;
  }
  function af(r, i, u, d) {
    var y = i.current, S = Xr(), R = tr(y);
    return u = wm(u), i.context === null ? i.context = u : i.pendingContext = u, i = No(S, R), i.payload = { element: r }, d = d === void 0 ? null : d, d !== null && (i.callback = d), r = Cs(y, i, R), r !== null && (Zr(r, y, R, S), yd(r, y, R)), R;
  }
  function ep(r) {
    if (r = r.current, !r.child)
      return null;
    switch (r.child.tag) {
      case 5:
        return r.child.stateNode;
      default:
        return r.child.stateNode;
    }
  }
  function Ag(r, i) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
      var u = r.retryLane;
      r.retryLane = u !== 0 && u < i ? u : i;
    }
  }
  function Tm(r, i) {
    Ag(r, i), (r = r.alternate) && Ag(r, i);
  }
  function Mg() {
    return null;
  }
  var km = typeof reportError == "function" ? reportError : function(r) {
    console.error(r);
  };
  function tp(r) {
    this._internalRoot = r;
  }
  Io.prototype.render = tp.prototype.render = function(r) {
    var i = this._internalRoot;
    if (i === null)
      throw Error(s(409));
    af(r, i, null, null);
  }, Io.prototype.unmount = tp.prototype.unmount = function() {
    var r = this._internalRoot;
    if (r !== null) {
      this._internalRoot = null;
      var i = r.containerInfo;
      As(function() {
        af(null, r, null, null);
      }), i[Po] = null;
    }
  };
  function Io(r) {
    this._internalRoot = r;
  }
  Io.prototype.unstable_scheduleHydration = function(r) {
    if (r) {
      var i = su();
      r = { blockedOn: null, target: r, priority: i };
      for (var u = 0; u < Ht.length && i !== 0 && i < Ht[u].priority; u++)
        ;
      Ht.splice(u, 0, r), u === 0 && Qf(r);
    }
  };
  function Rm(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
  }
  function np(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11 && (r.nodeType !== 8 || r.nodeValue !== " react-mount-point-unstable "));
  }
  function Og() {
  }
  function b1(r, i, u, d, y) {
    if (y) {
      if (typeof d == "function") {
        var S = d;
        d = function() {
          var te = ep(R);
          S.call(te);
        };
      }
      var R = Dg(i, d, r, 0, null, !1, !1, "", Og);
      return r._reactRootContainer = R, r[Po] = R.current, mu(r.nodeType === 8 ? r.parentNode : r), As(), R;
    }
    for (; y = r.lastChild; )
      r.removeChild(y);
    if (typeof d == "function") {
      var z = d;
      d = function() {
        var te = ep(N);
        z.call(te);
      };
    }
    var N = Jd(r, 0, !1, null, null, !1, !1, "", Og);
    return r._reactRootContainer = N, r[Po] = N.current, mu(r.nodeType === 8 ? r.parentNode : r), As(function() {
      af(i, N, u, d);
    }), N;
  }
  function rp(r, i, u, d, y) {
    var S = u._reactRootContainer;
    if (S) {
      var R = S;
      if (typeof y == "function") {
        var z = y;
        y = function() {
          var N = ep(R);
          z.call(N);
        };
      }
      af(i, R, r, y);
    } else
      R = b1(u, i, r, y, d);
    return ep(R);
  }
  qf = function(r) {
    switch (r.tag) {
      case 3:
        var i = r.stateNode;
        if (i.current.memoizedState.isDehydrated) {
          var u = Eo(i.pendingLanes);
          u !== 0 && (el(i, u | 1), Jr(i, Et()), !(wt & 6) && (zu = Et() + 500, Da()));
        }
        break;
      case 13:
        As(function() {
          var d = $o(r, 1);
          if (d !== null) {
            var y = Xr();
            Zr(d, r, 1, y);
          }
        }), Tm(r, 1);
    }
  }, ou = function(r) {
    if (r.tag === 13) {
      var i = $o(r, 134217728);
      if (i !== null) {
        var u = Xr();
        Zr(i, r, 134217728, u);
      }
      Tm(r, 134217728);
    }
  }, Zt = function(r) {
    if (r.tag === 13) {
      var i = tr(r), u = $o(r, i);
      if (u !== null) {
        var d = Xr();
        Zr(u, r, i, d);
      }
      Tm(r, i);
    }
  }, su = function() {
    return It;
  }, xc = function(r, i) {
    var u = It;
    try {
      return It = r, i();
    } finally {
      It = u;
    }
  }, ta = function(r, i, u) {
    switch (i) {
      case "input":
        if (hr(r, u), i = u.name, u.type === "radio" && i != null) {
          for (u = r; u.parentNode; )
            u = u.parentNode;
          for (u = u.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'), i = 0; i < u.length; i++) {
            var d = u[i];
            if (d !== r && d.form === r.form) {
              var y = We(d);
              if (!y)
                throw Error(s(90));
              ge(d), hr(d, y);
            }
          }
        }
        break;
      case "textarea":
        Ia(r, u);
        break;
      case "select":
        i = u.value, i != null && xa(r, !!u.multiple, i, !1);
    }
  }, Xs = $u, tu = As;
  var S1 = { usingClientEntryPoint: !1, Events: [$c, vu, We, na, ls, $u] }, Fu = { findFiberByHostInstance: ci, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, x1 = { bundleType: Fu.bundleType, version: Fu.version, rendererPackageName: Fu.rendererPackageName, rendererConfig: Fu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ne.ReactCurrentDispatcher, findHostInstanceByFiber: function(r) {
    return r = Xn(r), r === null ? null : r.stateNode;
  }, findFiberByHostInstance: Fu.findFiberByHostInstance || Mg, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ap = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ap.isDisabled && ap.supportsFiber)
      try {
        Zs = ap.inject(x1), Ea = ap;
      } catch {
      }
  }
  return Ri.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = S1, Ri.createPortal = function(r, i) {
    var u = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Rm(i))
      throw Error(s(200));
    return _g(r, i, null, u);
  }, Ri.createRoot = function(r, i) {
    if (!Rm(r))
      throw Error(s(299));
    var u = !1, d = "", y = km;
    return i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (d = i.identifierPrefix), i.onRecoverableError !== void 0 && (y = i.onRecoverableError)), i = Jd(r, 1, !1, null, null, u, !1, d, y), r[Po] = i.current, mu(r.nodeType === 8 ? r.parentNode : r), new tp(i);
  }, Ri.findDOMNode = function(r) {
    if (r == null)
      return null;
    if (r.nodeType === 1)
      return r;
    var i = r._reactInternals;
    if (i === void 0)
      throw typeof r.render == "function" ? Error(s(188)) : (r = Object.keys(r).join(","), Error(s(268, r)));
    return r = Xn(i), r = r === null ? null : r.stateNode, r;
  }, Ri.flushSync = function(r) {
    return As(r);
  }, Ri.hydrate = function(r, i, u) {
    if (!np(i))
      throw Error(s(200));
    return rp(null, r, i, !0, u);
  }, Ri.hydrateRoot = function(r, i, u) {
    if (!Rm(r))
      throw Error(s(405));
    var d = u != null && u.hydratedSources || null, y = !1, S = "", R = km;
    if (u != null && (u.unstable_strictMode === !0 && (y = !0), u.identifierPrefix !== void 0 && (S = u.identifierPrefix), u.onRecoverableError !== void 0 && (R = u.onRecoverableError)), i = Dg(i, null, r, 1, u ?? null, y, !1, S, R), r[Po] = i.current, mu(r), d)
      for (r = 0; r < d.length; r++)
        u = d[r], y = u._getVersion, y = y(u._source), i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [u, y] : i.mutableSourceEagerHydrationData.push(
          u,
          y
        );
    return new Io(i);
  }, Ri.render = function(r, i, u) {
    if (!np(i))
      throw Error(s(200));
    return rp(null, r, i, !1, u);
  }, Ri.unmountComponentAtNode = function(r) {
    if (!np(r))
      throw Error(s(40));
    return r._reactRootContainer ? (As(function() {
      rp(null, null, r, !1, function() {
        r._reactRootContainer = null, r[Po] = null;
      });
    }), !0) : !1;
  }, Ri.unstable_batchedUpdates = $u, Ri.unstable_renderSubtreeIntoContainer = function(r, i, u, d) {
    if (!np(u))
      throw Error(s(200));
    if (r == null || r._reactInternals === void 0)
      throw Error(s(38));
    return rp(r, i, u, !1, d);
  }, Ri.version = "18.2.0-next-9e3b772b8-20220608", Ri;
}
var _i = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var t2;
function VV() {
  return t2 || (t2 = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = qi, a = tO(), s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, c = !1;
    function p(e) {
      c = e;
    }
    function v(e) {
      if (!c) {
        for (var t = arguments.length, o = new Array(t > 1 ? t - 1 : 0), l = 1; l < t; l++)
          o[l - 1] = arguments[l];
        b("warn", e, o);
      }
    }
    function h(e) {
      if (!c) {
        for (var t = arguments.length, o = new Array(t > 1 ? t - 1 : 0), l = 1; l < t; l++)
          o[l - 1] = arguments[l];
        b("error", e, o);
      }
    }
    function b(e, t, o) {
      {
        var l = s.ReactDebugCurrentFrame, f = l.getStackAddendum();
        f !== "" && (t += "%s", o = o.concat([f]));
        var m = o.map(function(g) {
          return String(g);
        });
        m.unshift("Warning: " + t), Function.prototype.apply.call(console[e], console, m);
      }
    }
    var x = 0, E = 1, w = 2, k = 3, _ = 4, A = 5, L = 6, $ = 7, Y = 8, K = 9, W = 10, F = 11, ne = 12, H = 13, le = 14, re = 15, De = 16, Fe = 17, ot = 18, vt = 19, Rt = 21, $e = 22, Be = 23, jt = 24, tt = 25, Lt = !0, he = !1, Ce = !1, ve = !1, Ae = !1, Ye = !0, Ke = !1, cn = !1, Vn = !0, bt = !0, yn = !0, Ot = /* @__PURE__ */ new Set(), Bt = {}, gn = {};
    function $t(e, t) {
      ge(e, t), ge(e + "Capture", t);
    }
    function ge(e, t) {
      Bt[e] && h("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), Bt[e] = t;
      {
        var o = e.toLowerCase();
        gn[o] = e, e === "onDoubleClick" && (gn.ondblclick = e);
      }
      for (var l = 0; l < t.length; l++)
        Ot.add(t[l]);
    }
    var kn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Mn = Object.prototype.hasOwnProperty;
    function jn(e) {
      {
        var t = typeof Symbol == "function" && Symbol.toStringTag, o = t && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return o;
      }
    }
    function pr(e) {
      try {
        return hr(e), !1;
      } catch {
        return !0;
      }
    }
    function hr(e) {
      return "" + e;
    }
    function ba(e, t) {
      if (pr(e))
        return h("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", t, jn(e)), hr(e);
    }
    function Ua(e) {
      if (pr(e))
        return h("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", jn(e)), hr(e);
    }
    function Sa(e, t) {
      if (pr(e))
        return h("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", t, jn(e)), hr(e);
    }
    function xa(e, t) {
      if (pr(e))
        return h("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", t, jn(e)), hr(e);
    }
    function Br(e) {
      if (pr(e))
        return h("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", jn(e)), hr(e);
    }
    function On(e) {
      if (pr(e))
        return h("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", jn(e)), hr(e);
    }
    var Ia = 0, Ur = 1, Ha = 2, Bn = 3, mr = 4, zi = 5, Ca = 6, ye = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ue = ye + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ht = new RegExp("^[" + ye + "][" + Ue + "]*$"), Ut = {}, bn = {};
    function pn(e) {
      return Mn.call(bn, e) ? !0 : Mn.call(Ut, e) ? !1 : ht.test(e) ? (bn[e] = !0, !0) : (Ut[e] = !0, h("Invalid attribute name: `%s`", e), !1);
    }
    function hn(e, t, o) {
      return t !== null ? t.type === Ia : o ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function Ir(e, t, o, l) {
      if (o !== null && o.type === Ia)
        return !1;
      switch (typeof t) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (l)
            return !1;
          if (o !== null)
            return !o.acceptsBooleans;
          var f = e.toLowerCase().slice(0, 5);
          return f !== "data-" && f !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Xt(e, t, o, l) {
      if (t === null || typeof t > "u" || Ir(e, t, o, l))
        return !0;
      if (l)
        return !1;
      if (o !== null)
        switch (o.type) {
          case Bn:
            return !t;
          case mr:
            return t === !1;
          case zi:
            return isNaN(t);
          case Ca:
            return isNaN(t) || t < 1;
        }
      return !1;
    }
    function ta(e) {
      return Nt.hasOwnProperty(e) ? Nt[e] : null;
    }
    function Gt(e, t, o, l, f, m, g) {
      this.acceptsBooleans = t === Ha || t === Bn || t === mr, this.attributeName = l, this.attributeNamespace = f, this.mustUseProperty = o, this.propertyName = e, this.type = t, this.sanitizeURL = m, this.removeEmptyString = g;
    }
    var Nt = {}, ss = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ss.forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Ia,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var t = e[0], o = e[1];
      Nt[t] = new Gt(
        t,
        Ur,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Ha,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Ha,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Bn,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Bn,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        mr,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Ca,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        zi,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var na = /[\-\:]([a-z])/g, ls = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(na, ls);
      Nt[t] = new Gt(
        t,
        Ur,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(na, ls);
      Nt[t] = new Gt(
        t,
        Ur,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(na, ls);
      Nt[t] = new Gt(
        t,
        Ur,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Ur,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Xs = "xlinkHref";
    Nt[Xs] = new Gt(
      "xlinkHref",
      Ur,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      Nt[e] = new Gt(
        e,
        Ur,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var tu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Co = !1;
    function us(e) {
      !Co && tu.test(e) && (Co = !0, h("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function kr(e, t, o, l) {
      if (l.mustUseProperty) {
        var f = l.propertyName;
        return e[f];
      } else {
        ba(o, t), l.sanitizeURL && us("" + o);
        var m = l.attributeName, g = null;
        if (l.type === mr) {
          if (e.hasAttribute(m)) {
            var C = e.getAttribute(m);
            return C === "" ? !0 : Xt(t, o, l, !1) ? C : C === "" + o ? o : C;
          }
        } else if (e.hasAttribute(m)) {
          if (Xt(t, o, l, !1))
            return e.getAttribute(m);
          if (l.type === Bn)
            return o;
          g = e.getAttribute(m);
        }
        return Xt(t, o, l, !1) ? g === null ? o : g : g === "" + o ? o : g;
      }
    }
    function cs(e, t, o, l) {
      {
        if (!pn(t))
          return;
        if (!e.hasAttribute(t))
          return o === void 0 ? void 0 : null;
        var f = e.getAttribute(t);
        return ba(o, t), f === "" + o ? o : f;
      }
    }
    function si(e, t, o, l) {
      var f = ta(t);
      if (!hn(t, f, l)) {
        if (Xt(t, o, f, l) && (o = null), l || f === null) {
          if (pn(t)) {
            var m = t;
            o === null ? e.removeAttribute(m) : (ba(o, t), e.setAttribute(m, "" + o));
          }
          return;
        }
        var g = f.mustUseProperty;
        if (g) {
          var C = f.propertyName;
          if (o === null) {
            var T = f.type;
            e[C] = T === Bn ? !1 : "";
          } else
            e[C] = o;
          return;
        }
        var D = f.attributeName, M = f.attributeNamespace;
        if (o === null)
          e.removeAttribute(D);
        else {
          var U = f.type, V;
          U === Bn || U === mr && o === !0 ? V = "" : (ba(o, D), V = "" + o, f.sanitizeURL && us(V.toString())), M ? e.setAttributeNS(M, D, V) : e.setAttribute(D, V);
        }
      }
    }
    var Zi = Symbol.for("react.element"), ra = Symbol.for("react.portal"), Wa = Symbol.for("react.fragment"), aa = Symbol.for("react.strict_mode"), P = Symbol.for("react.profiler"), ce = Symbol.for("react.provider"), be = Symbol.for("react.context"), He = Symbol.for("react.forward_ref"), ct = Symbol.for("react.suspense"), gt = Symbol.for("react.suspense_list"), ft = Symbol.for("react.memo"), Ge = Symbol.for("react.lazy"), Xn = Symbol.for("react.scope"), mn = Symbol.for("react.debug_trace_mode"), vn = Symbol.for("react.offscreen"), Rr = Symbol.for("react.legacy_hidden"), li = Symbol.for("react.cache"), nu = Symbol.for("react.tracing_marker"), Et = Symbol.iterator, yc = "@@iterator";
    function Pi(e) {
      if (e === null || typeof e != "object")
        return null;
      var t = Et && e[Et] || e[yc];
      return typeof t == "function" ? t : null;
    }
    var mt = Object.assign, Li = 0, Hf, gc, Zs, Ea, Wf, wa, Yf;
    function Gf() {
    }
    Gf.__reactDisabledLog = !0;
    function vh() {
      {
        if (Li === 0) {
          Hf = console.log, gc = console.info, Zs = console.warn, Ea = console.error, Wf = console.group, wa = console.groupCollapsed, Yf = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: Gf,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        Li++;
      }
    }
    function ru() {
      {
        if (Li--, Li === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: mt({}, e, {
              value: Hf
            }),
            info: mt({}, e, {
              value: gc
            }),
            warn: mt({}, e, {
              value: Zs
            }),
            error: mt({}, e, {
              value: Ea
            }),
            group: mt({}, e, {
              value: Wf
            }),
            groupCollapsed: mt({}, e, {
              value: wa
            }),
            groupEnd: mt({}, e, {
              value: Yf
            })
          });
        }
        Li < 0 && h("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var fs = s.ReactCurrentDispatcher, Eo;
    function Ya(e, t, o) {
      {
        if (Eo === void 0)
          try {
            throw Error();
          } catch (f) {
            var l = f.stack.trim().match(/\n( *(at )?)/);
            Eo = l && l[1] || "";
          }
        return `
` + Eo + e;
      }
    }
    var bc = !1, wo;
    {
      var Js = typeof WeakMap == "function" ? WeakMap : Map;
      wo = new Js();
    }
    function au(e, t) {
      if (!e || bc)
        return "";
      {
        var o = wo.get(e);
        if (o !== void 0)
          return o;
      }
      var l;
      bc = !0;
      var f = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var m;
      m = fs.current, fs.current = null, vh();
      try {
        if (t) {
          var g = function() {
            throw Error();
          };
          if (Object.defineProperty(g.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(g, []);
            } catch (J) {
              l = J;
            }
            Reflect.construct(e, [], g);
          } else {
            try {
              g.call();
            } catch (J) {
              l = J;
            }
            e.call(g.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (J) {
            l = J;
          }
          e();
        }
      } catch (J) {
        if (J && l && typeof J.stack == "string") {
          for (var C = J.stack.split(`
`), T = l.stack.split(`
`), D = C.length - 1, M = T.length - 1; D >= 1 && M >= 0 && C[D] !== T[M]; )
            M--;
          for (; D >= 1 && M >= 0; D--, M--)
            if (C[D] !== T[M]) {
              if (D !== 1 || M !== 1)
                do
                  if (D--, M--, M < 0 || C[D] !== T[M]) {
                    var U = `
` + C[D].replace(" at new ", " at ");
                    return e.displayName && U.includes("<anonymous>") && (U = U.replace("<anonymous>", e.displayName)), typeof e == "function" && wo.set(e, U), U;
                  }
                while (D >= 1 && M >= 0);
              break;
            }
        }
      } finally {
        bc = !1, fs.current = m, ru(), Error.prepareStackTrace = f;
      }
      var V = e ? e.displayName || e.name : "", Z = V ? Ya(V) : "";
      return typeof e == "function" && wo.set(e, Z), Z;
    }
    function Sc(e, t, o) {
      return au(e, !0);
    }
    function Ji(e, t, o) {
      return au(e, !1);
    }
    function yh(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function el(e, t, o) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return au(e, yh(e));
      if (typeof e == "string")
        return Ya(e);
      switch (e) {
        case ct:
          return Ya("Suspense");
        case gt:
          return Ya("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case He:
            return Ji(e.render);
          case ft:
            return el(e.type, t, o);
          case Ge: {
            var l = e, f = l._payload, m = l._init;
            try {
              return el(m(f), t, o);
            } catch {
            }
          }
        }
      return "";
    }
    function It(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case A:
          return Ya(e.type);
        case De:
          return Ya("Lazy");
        case H:
          return Ya("Suspense");
        case vt:
          return Ya("SuspenseList");
        case x:
        case w:
        case re:
          return Ji(e.type);
        case F:
          return Ji(e.type.render);
        case E:
          return Sc(e.type);
        default:
          return "";
      }
    }
    function iu(e) {
      try {
        var t = "", o = e;
        do
          t += It(o), o = o.return;
        while (o);
        return t;
      } catch (l) {
        return `
Error generating stack: ` + l.message + `
` + l.stack;
      }
    }
    function qf(e, t, o) {
      var l = e.displayName;
      if (l)
        return l;
      var f = t.displayName || t.name || "";
      return f !== "" ? o + "(" + f + ")" : o;
    }
    function ou(e) {
      return e.displayName || "Context";
    }
    function Zt(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && h("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case Wa:
          return "Fragment";
        case ra:
          return "Portal";
        case P:
          return "Profiler";
        case aa:
          return "StrictMode";
        case ct:
          return "Suspense";
        case gt:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case be:
            var t = e;
            return ou(t) + ".Consumer";
          case ce:
            var o = e;
            return ou(o._context) + ".Provider";
          case He:
            return qf(e, e.render, "ForwardRef");
          case ft:
            var l = e.displayName || null;
            return l !== null ? l : Zt(e.type) || "Memo";
          case Ge: {
            var f = e, m = f._payload, g = f._init;
            try {
              return Zt(g(m));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function su(e, t, o) {
      var l = t.displayName || t.name || "";
      return e.displayName || (l !== "" ? o + "(" + l + ")" : o);
    }
    function xc(e) {
      return e.displayName || "Context";
    }
    function st(e) {
      var t = e.tag, o = e.type;
      switch (t) {
        case jt:
          return "Cache";
        case K:
          var l = o;
          return xc(l) + ".Consumer";
        case W:
          var f = o;
          return xc(f._context) + ".Provider";
        case ot:
          return "DehydratedFragment";
        case F:
          return su(o, o.render, "ForwardRef");
        case $:
          return "Fragment";
        case A:
          return o;
        case _:
          return "Portal";
        case k:
          return "Root";
        case L:
          return "Text";
        case De:
          return Zt(o);
        case Y:
          return o === aa ? "StrictMode" : "Mode";
        case $e:
          return "Offscreen";
        case ne:
          return "Profiler";
        case Rt:
          return "Scope";
        case H:
          return "Suspense";
        case vt:
          return "SuspenseList";
        case tt:
          return "TracingMarker";
        case E:
        case x:
        case Fe:
        case w:
        case le:
        case re:
          if (typeof o == "function")
            return o.displayName || o.name || null;
          if (typeof o == "string")
            return o;
          break;
      }
      return null;
    }
    var tl = s.ReactDebugCurrentFrame, Sn = null, Hr = !1;
    function Wr() {
      {
        if (Sn === null)
          return null;
        var e = Sn._debugOwner;
        if (e !== null && typeof e < "u")
          return st(e);
      }
      return null;
    }
    function To() {
      return Sn === null ? "" : iu(Sn);
    }
    function Yn() {
      tl.getCurrentStack = null, Sn = null, Hr = !1;
    }
    function Ht(e) {
      tl.getCurrentStack = e === null ? null : To, Sn = e, Hr = !1;
    }
    function Cc() {
      return Sn;
    }
    function Ta(e) {
      Hr = e;
    }
    function Rn(e) {
      return "" + e;
    }
    function ka(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return On(e), e;
        default:
          return "";
      }
    }
    var Qf = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function ko(e, t) {
      Qf[t.type] || t.onChange || t.onInput || t.readOnly || t.disabled || t.value == null || h("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), t.onChange || t.readOnly || t.disabled || t.checked == null || h("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ec(e) {
      var t = e.type, o = e.nodeName;
      return o && o.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
    }
    function wc(e) {
      return e._valueTracker;
    }
    function nl(e) {
      e._valueTracker = null;
    }
    function rl(e) {
      var t = "";
      return e && (Ec(e) ? t = e.checked ? "true" : "false" : t = e.value), t;
    }
    function Ro(e) {
      var t = Ec(e) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
      On(e[t]);
      var l = "" + e[t];
      if (!(e.hasOwnProperty(t) || typeof o > "u" || typeof o.get != "function" || typeof o.set != "function")) {
        var f = o.get, m = o.set;
        Object.defineProperty(e, t, {
          configurable: !0,
          get: function() {
            return f.call(this);
          },
          set: function(C) {
            On(C), l = "" + C, m.call(this, C);
          }
        }), Object.defineProperty(e, t, {
          enumerable: o.enumerable
        });
        var g = {
          getValue: function() {
            return l;
          },
          setValue: function(C) {
            On(C), l = "" + C;
          },
          stopTracking: function() {
            nl(e), delete e[t];
          }
        };
        return g;
      }
    }
    function _o(e) {
      wc(e) || (e._valueTracker = Ro(e));
    }
    function O(e) {
      if (!e)
        return !1;
      var t = wc(e);
      if (!t)
        return !0;
      var o = t.getValue(), l = rl(e);
      return l !== o ? (t.setValue(l), !0) : !1;
    }
    function j(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var ee = !1, Ee = !1, St = !1, Wt = !1;
    function Mt(e) {
      var t = e.type === "checkbox" || e.type === "radio";
      return t ? e.checked != null : e.value != null;
    }
    function yt(e, t) {
      var o = e, l = t.checked, f = mt({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: l ?? o._wrapperState.initialChecked
      });
      return f;
    }
    function qt(e, t) {
      ko("input", t), t.checked !== void 0 && t.defaultChecked !== void 0 && !Ee && (h("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Wr() || "A component", t.type), Ee = !0), t.value !== void 0 && t.defaultValue !== void 0 && !ee && (h("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Wr() || "A component", t.type), ee = !0);
      var o = e, l = t.defaultValue == null ? "" : t.defaultValue;
      o._wrapperState = {
        initialChecked: t.checked != null ? t.checked : t.defaultChecked,
        initialValue: ka(t.value != null ? t.value : l),
        controlled: Mt(t)
      };
    }
    function Yr(e, t) {
      var o = e, l = t.checked;
      l != null && si(o, "checked", l, !1);
    }
    function Zn(e, t) {
      var o = e;
      {
        var l = Mt(t);
        !o._wrapperState.controlled && l && !Wt && (h("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Wt = !0), o._wrapperState.controlled && !l && !St && (h("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), St = !0);
      }
      Yr(e, t);
      var f = ka(t.value), m = t.type;
      if (f != null)
        m === "number" ? (f === 0 && o.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        o.value != f) && (o.value = Rn(f)) : o.value !== Rn(f) && (o.value = Rn(f));
      else if (m === "submit" || m === "reset") {
        o.removeAttribute("value");
        return;
      }
      t.hasOwnProperty("value") ? Ni(o, t.type, f) : t.hasOwnProperty("defaultValue") && Ni(o, t.type, ka(t.defaultValue)), t.checked == null && t.defaultChecked != null && (o.defaultChecked = !!t.defaultChecked);
    }
    function $i(e, t, o) {
      var l = e;
      if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var f = t.type, m = f === "submit" || f === "reset";
        if (m && (t.value === void 0 || t.value === null))
          return;
        var g = Rn(l._wrapperState.initialValue);
        o || g !== l.value && (l.value = g), l.defaultValue = g;
      }
      var C = l.name;
      C !== "" && (l.name = ""), l.defaultChecked = !l.defaultChecked, l.defaultChecked = !!l._wrapperState.initialChecked, C !== "" && (l.name = C);
    }
    function lu(e, t) {
      var o = e;
      Zn(o, t), _r(o, t);
    }
    function _r(e, t) {
      var o = t.name;
      if (t.type === "radio" && o != null) {
        for (var l = e; l.parentNode; )
          l = l.parentNode;
        ba(o, "name");
        for (var f = l.querySelectorAll("input[name=" + JSON.stringify("" + o) + '][type="radio"]'), m = 0; m < f.length; m++) {
          var g = f[m];
          if (!(g === e || g.form !== e.form)) {
            var C = Qg(g);
            if (!C)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            O(g), Zn(g, C);
          }
        }
      }
    }
    function Ni(e, t, o) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (t !== "number" || j(e.ownerDocument) !== e) && (o == null ? e.defaultValue = Rn(e._wrapperState.initialValue) : e.defaultValue !== Rn(o) && (e.defaultValue = Rn(o)));
    }
    var Kf = !1, uu = !1, Sy = !1;
    function Xf(e, t) {
      t.value == null && (typeof t.children == "object" && t.children !== null ? n.Children.forEach(t.children, function(o) {
        o != null && (typeof o == "string" || typeof o == "number" || uu || (uu = !0, h("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : t.dangerouslySetInnerHTML != null && (Sy || (Sy = !0, h("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), t.selected != null && !Kf && (h("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Kf = !0);
    }
    function gh(e, t) {
      t.value != null && e.setAttribute("value", Rn(ka(t.value)));
    }
    var Tc = Array.isArray;
    function vr(e) {
      return Tc(e);
    }
    var Zf;
    Zf = !1;
    function xy() {
      var e = Wr();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var Cy = ["value", "defaultValue"];
    function jS(e) {
      {
        ko("select", e);
        for (var t = 0; t < Cy.length; t++) {
          var o = Cy[t];
          if (e[o] != null) {
            var l = vr(e[o]);
            e.multiple && !l ? h("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", o, xy()) : !e.multiple && l && h("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", o, xy());
          }
        }
      }
    }
    function ds(e, t, o, l) {
      var f = e.options;
      if (t) {
        for (var m = o, g = {}, C = 0; C < m.length; C++)
          g["$" + m[C]] = !0;
        for (var T = 0; T < f.length; T++) {
          var D = g.hasOwnProperty("$" + f[T].value);
          f[T].selected !== D && (f[T].selected = D), D && l && (f[T].defaultSelected = !0);
        }
      } else {
        for (var M = Rn(ka(o)), U = null, V = 0; V < f.length; V++) {
          if (f[V].value === M) {
            f[V].selected = !0, l && (f[V].defaultSelected = !0);
            return;
          }
          U === null && !f[V].disabled && (U = f[V]);
        }
        U !== null && (U.selected = !0);
      }
    }
    function bh(e, t) {
      return mt({}, t, {
        value: void 0
      });
    }
    function Ey(e, t) {
      var o = e;
      jS(t), o._wrapperState = {
        wasMultiple: !!t.multiple
      }, t.value !== void 0 && t.defaultValue !== void 0 && !Zf && (h("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Zf = !0);
    }
    function BS(e, t) {
      var o = e;
      o.multiple = !!t.multiple;
      var l = t.value;
      l != null ? ds(o, !!t.multiple, l, !1) : t.defaultValue != null && ds(o, !!t.multiple, t.defaultValue, !0);
    }
    function US(e, t) {
      var o = e, l = o._wrapperState.wasMultiple;
      o._wrapperState.wasMultiple = !!t.multiple;
      var f = t.value;
      f != null ? ds(o, !!t.multiple, f, !1) : l !== !!t.multiple && (t.defaultValue != null ? ds(o, !!t.multiple, t.defaultValue, !0) : ds(o, !!t.multiple, t.multiple ? [] : "", !1));
    }
    function IS(e, t) {
      var o = e, l = t.value;
      l != null && ds(o, !!t.multiple, l, !1);
    }
    var Sh = !1;
    function xh(e, t) {
      var o = e;
      if (t.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var l = mt({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: Rn(o._wrapperState.initialValue)
      });
      return l;
    }
    function wy(e, t) {
      var o = e;
      ko("textarea", t), t.value !== void 0 && t.defaultValue !== void 0 && !Sh && (h("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Wr() || "A component"), Sh = !0);
      var l = t.value;
      if (l == null) {
        var f = t.children, m = t.defaultValue;
        if (f != null) {
          h("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (m != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (vr(f)) {
              if (f.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              f = f[0];
            }
            m = f;
          }
        }
        m == null && (m = ""), l = m;
      }
      o._wrapperState = {
        initialValue: ka(l)
      };
    }
    function Ty(e, t) {
      var o = e, l = ka(t.value), f = ka(t.defaultValue);
      if (l != null) {
        var m = Rn(l);
        m !== o.value && (o.value = m), t.defaultValue == null && o.defaultValue !== m && (o.defaultValue = m);
      }
      f != null && (o.defaultValue = Rn(f));
    }
    function ky(e, t) {
      var o = e, l = o.textContent;
      l === o._wrapperState.initialValue && l !== "" && l !== null && (o.value = l);
    }
    function Ch(e, t) {
      Ty(e, t);
    }
    var Do = "http://www.w3.org/1999/xhtml", HS = "http://www.w3.org/1998/Math/MathML", Eh = "http://www.w3.org/2000/svg";
    function Jf(e) {
      switch (e) {
        case "svg":
          return Eh;
        case "math":
          return HS;
        default:
          return Do;
      }
    }
    function wh(e, t) {
      return e == null || e === Do ? Jf(t) : e === Eh && t === "foreignObject" ? Do : e;
    }
    var WS = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, o, l, f) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(t, o, l, f);
        });
      } : e;
    }, ed, Ry = WS(function(e, t) {
      if (e.namespaceURI === Eh && !("innerHTML" in e)) {
        ed = ed || document.createElement("div"), ed.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
        for (var o = ed.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; o.firstChild; )
          e.appendChild(o.firstChild);
        return;
      }
      e.innerHTML = t;
    }), Ra = 1, Ao = 3, Jn = 8, Fi = 9, al = 11, td = function(e, t) {
      if (t) {
        var o = e.firstChild;
        if (o && o === e.lastChild && o.nodeType === Ao) {
          o.nodeValue = t;
          return;
        }
      }
      e.textContent = t;
    }, _y = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, cu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Dy(e, t) {
      return e + t.charAt(0).toUpperCase() + t.substring(1);
    }
    var Ay = ["Webkit", "ms", "Moz", "O"];
    Object.keys(cu).forEach(function(e) {
      Ay.forEach(function(t) {
        cu[Dy(t, e)] = cu[e];
      });
    });
    function nd(e, t, o) {
      var l = t == null || typeof t == "boolean" || t === "";
      return l ? "" : !o && typeof t == "number" && t !== 0 && !(cu.hasOwnProperty(e) && cu[e]) ? t + "px" : (xa(t, e), ("" + t).trim());
    }
    var fu = /([A-Z])/g, YS = /^ms-/;
    function GS(e) {
      return e.replace(fu, "-$1").toLowerCase().replace(YS, "-ms-");
    }
    var My = function() {
    };
    {
      var Oy = /^(?:webkit|moz|o)[A-Z]/, zy = /^-ms-/, kc = /-(.)/g, du = /;\s*$/, pu = {}, hu = {}, Py = !1, Th = !1, kh = function(e) {
        return e.replace(kc, function(t, o) {
          return o.toUpperCase();
        });
      }, Rh = function(e) {
        pu.hasOwnProperty(e) && pu[e] || (pu[e] = !0, h(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          kh(e.replace(zy, "ms-"))
        ));
      }, Ly = function(e) {
        pu.hasOwnProperty(e) && pu[e] || (pu[e] = !0, h("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, $y = function(e, t) {
        hu.hasOwnProperty(t) && hu[t] || (hu[t] = !0, h(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, t.replace(du, "")));
      }, Ny = function(e, t) {
        Py || (Py = !0, h("`NaN` is an invalid value for the `%s` css style property.", e));
      }, qS = function(e, t) {
        Th || (Th = !0, h("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      My = function(e, t) {
        e.indexOf("-") > -1 ? Rh(e) : Oy.test(e) ? Ly(e) : du.test(t) && $y(e, t), typeof t == "number" && (isNaN(t) ? Ny(e, t) : isFinite(t) || qS(e, t));
      };
    }
    var QS = My;
    function KS(e) {
      {
        var t = "", o = "";
        for (var l in e)
          if (e.hasOwnProperty(l)) {
            var f = e[l];
            if (f != null) {
              var m = l.indexOf("--") === 0;
              t += o + (m ? l : GS(l)) + ":", t += nd(l, f, m), o = ";";
            }
          }
        return t || null;
      }
    }
    function Fy(e, t) {
      var o = e.style;
      for (var l in t)
        if (t.hasOwnProperty(l)) {
          var f = l.indexOf("--") === 0;
          f || QS(l, t[l]);
          var m = nd(l, t[l], f);
          l === "float" && (l = "cssFloat"), f ? o.setProperty(l, m) : o[l] = m;
        }
    }
    function XS(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function ui(e) {
      var t = {};
      for (var o in e)
        for (var l = _y[o] || [o], f = 0; f < l.length; f++)
          t[l[f]] = o;
      return t;
    }
    function Rc(e, t) {
      {
        if (!t)
          return;
        var o = ui(e), l = ui(t), f = {};
        for (var m in o) {
          var g = o[m], C = l[m];
          if (C && g !== C) {
            var T = g + "," + C;
            if (f[T])
              continue;
            f[T] = !0, h("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", XS(e[g]) ? "Removing" : "Updating", g, C);
          }
        }
      }
    }
    var Vy = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, jy = mt({
      menuitem: !0
    }, Vy), By = "__html";
    function rd(e, t) {
      if (t) {
        if (jy[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (t.dangerouslySetInnerHTML != null) {
          if (t.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof t.dangerouslySetInnerHTML != "object" || !(By in t.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!t.suppressContentEditableWarning && t.contentEditable && t.children != null && h("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), t.style != null && typeof t.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Mo(e, t) {
      if (e.indexOf("-") === -1)
        return typeof t.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ad = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Uy = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Vi = {}, _h = new RegExp("^(aria)-[" + Ue + "]*$"), _c = new RegExp("^(aria)[A-Z][" + Ue + "]*$");
    function Dh(e, t) {
      {
        if (Mn.call(Vi, t) && Vi[t])
          return !0;
        if (_c.test(t)) {
          var o = "aria-" + t.slice(4).toLowerCase(), l = Uy.hasOwnProperty(o) ? o : null;
          if (l == null)
            return h("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", t), Vi[t] = !0, !0;
          if (t !== l)
            return h("Invalid ARIA attribute `%s`. Did you mean `%s`?", t, l), Vi[t] = !0, !0;
        }
        if (_h.test(t)) {
          var f = t.toLowerCase(), m = Uy.hasOwnProperty(f) ? f : null;
          if (m == null)
            return Vi[t] = !0, !1;
          if (t !== m)
            return h("Unknown ARIA attribute `%s`. Did you mean `%s`?", t, m), Vi[t] = !0, !0;
        }
      }
      return !0;
    }
    function Iy(e, t) {
      {
        var o = [];
        for (var l in t) {
          var f = Dh(e, l);
          f || o.push(l);
        }
        var m = o.map(function(g) {
          return "`" + g + "`";
        }).join(", ");
        o.length === 1 ? h("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", m, e) : o.length > 1 && h("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", m, e);
      }
    }
    function id(e, t) {
      Mo(e, t) || Iy(e, t);
    }
    var il = !1;
    function Ah(e, t) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        t != null && t.value === null && !il && (il = !0, e === "select" && t.multiple ? h("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : h("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var Mh = function() {
    };
    {
      var yr = {}, Oh = /^on./, Hy = /^on[^A-Z]/, Wy = new RegExp("^(aria)-[" + Ue + "]*$"), Yy = new RegExp("^(aria)[A-Z][" + Ue + "]*$");
      Mh = function(e, t, o, l) {
        if (Mn.call(yr, t) && yr[t])
          return !0;
        var f = t.toLowerCase();
        if (f === "onfocusin" || f === "onfocusout")
          return h("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), yr[t] = !0, !0;
        if (l != null) {
          var m = l.registrationNameDependencies, g = l.possibleRegistrationNames;
          if (m.hasOwnProperty(t))
            return !0;
          var C = g.hasOwnProperty(f) ? g[f] : null;
          if (C != null)
            return h("Invalid event handler property `%s`. Did you mean `%s`?", t, C), yr[t] = !0, !0;
          if (Oh.test(t))
            return h("Unknown event handler property `%s`. It will be ignored.", t), yr[t] = !0, !0;
        } else if (Oh.test(t))
          return Hy.test(t) && h("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", t), yr[t] = !0, !0;
        if (Wy.test(t) || Yy.test(t))
          return !0;
        if (f === "innerhtml")
          return h("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), yr[t] = !0, !0;
        if (f === "aria")
          return h("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), yr[t] = !0, !0;
        if (f === "is" && o !== null && o !== void 0 && typeof o != "string")
          return h("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof o), yr[t] = !0, !0;
        if (typeof o == "number" && isNaN(o))
          return h("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", t), yr[t] = !0, !0;
        var T = ta(t), D = T !== null && T.type === Ia;
        if (ad.hasOwnProperty(f)) {
          var M = ad[f];
          if (M !== t)
            return h("Invalid DOM property `%s`. Did you mean `%s`?", t, M), yr[t] = !0, !0;
        } else if (!D && t !== f)
          return h("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", t, f), yr[t] = !0, !0;
        return typeof o == "boolean" && Ir(t, o, T, !1) ? (o ? h('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', o, t, t, o, t) : h('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', o, t, t, o, t, t, t), yr[t] = !0, !0) : D ? !0 : Ir(t, o, T, !1) ? (yr[t] = !0, !1) : ((o === "false" || o === "true") && T !== null && T.type === Bn && (h("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", o, t, o === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', t, o), yr[t] = !0), !0);
      };
    }
    var Gy = function(e, t, o) {
      {
        var l = [];
        for (var f in t) {
          var m = Mh(e, f, t[f], o);
          m || l.push(f);
        }
        var g = l.map(function(C) {
          return "`" + C + "`";
        }).join(", ");
        l.length === 1 ? h("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", g, e) : l.length > 1 && h("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", g, e);
      }
    };
    function qy(e, t, o) {
      Mo(e, t) || Gy(e, t, o);
    }
    var Oo = 1, Dc = 2, ol = 4, ZS = Oo | Dc | ol, Ac = null;
    function Mc(e) {
      Ac !== null && h("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Ac = e;
    }
    function JS() {
      Ac === null && h("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Ac = null;
    }
    function Qy(e) {
      return e === Ac;
    }
    function od(e) {
      var t = e.target || e.srcElement || window;
      return t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === Ao ? t.parentNode : t;
    }
    var fn = null, ps = null, zo = null;
    function mu(e) {
      var t = Bu(e);
      if (t) {
        if (typeof fn != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var o = t.stateNode;
        if (o) {
          var l = Qg(o);
          fn(t.stateNode, t.type, l);
        }
      }
    }
    function Ky(e) {
      fn = e;
    }
    function sd(e) {
      ps ? zo ? zo.push(e) : zo = [e] : ps = e;
    }
    function Oc() {
      return ps !== null || zo !== null;
    }
    function zc() {
      if (ps) {
        var e = ps, t = zo;
        if (ps = null, zo = null, mu(e), t)
          for (var o = 0; o < t.length; o++)
            mu(t[o]);
      }
    }
    var sl = function(e, t) {
      return e(t);
    }, zh = function() {
    }, Ph = !1;
    function e1() {
      var e = Oc();
      e && (zh(), zc());
    }
    function Lh(e, t, o) {
      if (Ph)
        return e(t, o);
      Ph = !0;
      try {
        return sl(e, t, o);
      } finally {
        Ph = !1, e1();
      }
    }
    function ld(e, t, o) {
      sl = e, zh = o;
    }
    function ud(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function $h(e, t, o) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(o.disabled && ud(t));
        default:
          return !1;
      }
    }
    function ll(e, t) {
      var o = e.stateNode;
      if (o === null)
        return null;
      var l = Qg(o);
      if (l === null)
        return null;
      var f = l[t];
      if ($h(t, e.type, l))
        return null;
      if (f && typeof f != "function")
        throw new Error("Expected `" + t + "` listener to be a function, instead got a value of `" + typeof f + "` type.");
      return f;
    }
    var Pc = !1;
    if (kn)
      try {
        var ul = {};
        Object.defineProperty(ul, "passive", {
          get: function() {
            Pc = !0;
          }
        }), window.addEventListener("test", ul, ul), window.removeEventListener("test", ul, ul);
      } catch {
        Pc = !1;
      }
    function Xy(e, t, o, l, f, m, g, C, T) {
      var D = Array.prototype.slice.call(arguments, 3);
      try {
        t.apply(o, D);
      } catch (M) {
        this.onError(M);
      }
    }
    var Nh = Xy;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Fh = document.createElement("react");
      Nh = function(t, o, l, f, m, g, C, T, D) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var M = document.createEvent("Event"), U = !1, V = !0, Z = window.event, J = Object.getOwnPropertyDescriptor(window, "event");
        function ae() {
          Fh.removeEventListener(ie, qe, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Z);
        }
        var Re = Array.prototype.slice.call(arguments, 3);
        function qe() {
          U = !0, ae(), o.apply(l, Re), V = !1;
        }
        var je, At = !1, Tt = !1;
        function q(Q) {
          if (je = Q.error, At = !0, je === null && Q.colno === 0 && Q.lineno === 0 && (Tt = !0), Q.defaultPrevented && je != null && typeof je == "object")
            try {
              je._suppressLogging = !0;
            } catch {
            }
        }
        var ie = "react-" + (t || "invokeguardedcallback");
        if (window.addEventListener("error", q), Fh.addEventListener(ie, qe, !1), M.initEvent(ie, !1, !1), Fh.dispatchEvent(M), J && Object.defineProperty(window, "event", J), U && V && (At ? Tt && (je = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : je = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(je)), window.removeEventListener("error", q), !U)
          return ae(), Xy.apply(this, arguments);
      };
    }
    var t1 = Nh, hs = !1, ji = null, Lc = !1, ms = null, eo = {
      onError: function(e) {
        hs = !0, ji = e;
      }
    };
    function cl(e, t, o, l, f, m, g, C, T) {
      hs = !1, ji = null, t1.apply(eo, arguments);
    }
    function Po(e, t, o, l, f, m, g, C, T) {
      if (cl.apply(this, arguments), hs) {
        var D = jh();
        Lc || (Lc = !0, ms = D);
      }
    }
    function Vh() {
      if (Lc) {
        var e = ms;
        throw Lc = !1, ms = null, e;
      }
    }
    function n1() {
      return hs;
    }
    function jh() {
      if (hs) {
        var e = ji;
        return hs = !1, ji = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ci(e) {
      return e._reactInternals;
    }
    function $c(e) {
      return e._reactInternals !== void 0;
    }
    function vu(e, t) {
      e._reactInternals = t;
    }
    var We = (
      /*                      */
      0
    ), vs = (
      /*                */
      1
    ), xn = (
      /*                    */
      2
    ), dt = (
      /*                       */
      4
    ), Yt = (
      /*                */
      16
    ), Qt = (
      /*                 */
      32
    ), to = (
      /*                     */
      64
    ), rt = (
      /*                   */
      128
    ), Un = (
      /*            */
      256
    ), _a = (
      /*                          */
      512
    ), fi = (
      /*                     */
      1024
    ), _n = (
      /*                      */
      2048
    ), di = (
      /*                    */
      4096
    ), ys = (
      /*                   */
      8192
    ), Nc = (
      /*             */
      16384
    ), cd = _n | dt | to | _a | fi | Nc, Zy = (
      /*               */
      32767
    ), Ga = (
      /*                   */
      32768
    ), gr = (
      /*                */
      65536
    ), Fc = (
      /* */
      131072
    ), Bh = (
      /*                       */
      1048576
    ), Uh = (
      /*                    */
      2097152
    ), Da = (
      /*                 */
      4194304
    ), gs = (
      /*                */
      8388608
    ), Aa = (
      /*               */
      16777216
    ), fl = (
      /*              */
      33554432
    ), yu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      dt | fi | 0
    ), Ma = xn | dt | Yt | Qt | _a | di | ys, Gr = dt | to | _a | ys, pi = _n | Yt, Dr = Da | gs | Uh, Lo = s.ReactCurrentOwner;
    function qa(e) {
      var t = e, o = e;
      if (e.alternate)
        for (; t.return; )
          t = t.return;
      else {
        var l = t;
        do
          t = l, (t.flags & (xn | di)) !== We && (o = t.return), l = t.return;
        while (l);
      }
      return t.tag === k ? o : null;
    }
    function Ih(e) {
      if (e.tag === H) {
        var t = e.memoizedState;
        if (t === null) {
          var o = e.alternate;
          o !== null && (t = o.memoizedState);
        }
        if (t !== null)
          return t.dehydrated;
      }
      return null;
    }
    function fd(e) {
      return e.tag === k ? e.stateNode.containerInfo : null;
    }
    function Hh(e) {
      return qa(e) === e;
    }
    function Qa(e) {
      {
        var t = Lo.current;
        if (t !== null && t.tag === E) {
          var o = t, l = o.stateNode;
          l._warnedAboutRefsInRender || h("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", st(o) || "A component"), l._warnedAboutRefsInRender = !0;
        }
      }
      var f = ci(e);
      return f ? qa(f) === f : !1;
    }
    function Oa(e) {
      if (qa(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Cn(e) {
      var t = e.alternate;
      if (!t) {
        var o = qa(e);
        if (o === null)
          throw new Error("Unable to find node on an unmounted component.");
        return o !== e ? null : e;
      }
      for (var l = e, f = t; ; ) {
        var m = l.return;
        if (m === null)
          break;
        var g = m.alternate;
        if (g === null) {
          var C = m.return;
          if (C !== null) {
            l = f = C;
            continue;
          }
          break;
        }
        if (m.child === g.child) {
          for (var T = m.child; T; ) {
            if (T === l)
              return Oa(m), e;
            if (T === f)
              return Oa(m), t;
            T = T.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (l.return !== f.return)
          l = m, f = g;
        else {
          for (var D = !1, M = m.child; M; ) {
            if (M === l) {
              D = !0, l = m, f = g;
              break;
            }
            if (M === f) {
              D = !0, f = m, l = g;
              break;
            }
            M = M.sibling;
          }
          if (!D) {
            for (M = g.child; M; ) {
              if (M === l) {
                D = !0, l = g, f = m;
                break;
              }
              if (M === f) {
                D = !0, f = g, l = m;
                break;
              }
              M = M.sibling;
            }
            if (!D)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (l.alternate !== f)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (l.tag !== k)
        throw new Error("Unable to find node on an unmounted component.");
      return l.stateNode.current === l ? e : t;
    }
    function hi(e) {
      var t = Cn(e);
      return t !== null ? Wh(t) : null;
    }
    function Wh(e) {
      if (e.tag === A || e.tag === L)
        return e;
      for (var t = e.child; t !== null; ) {
        var o = Wh(t);
        if (o !== null)
          return o;
        t = t.sibling;
      }
      return null;
    }
    function Jy(e) {
      var t = Cn(e);
      return t !== null ? dd(t) : null;
    }
    function dd(e) {
      if (e.tag === A || e.tag === L)
        return e;
      for (var t = e.child; t !== null; ) {
        if (t.tag !== _) {
          var o = dd(t);
          if (o !== null)
            return o;
        }
        t = t.sibling;
      }
      return null;
    }
    var pd = a.unstable_scheduleCallback, eg = a.unstable_cancelCallback, hd = a.unstable_shouldYield, tg = a.unstable_requestPaint, zn = a.unstable_now, Yh = a.unstable_getCurrentPriorityLevel, md = a.unstable_ImmediatePriority, Ka = a.unstable_UserBlockingPriority, no = a.unstable_NormalPriority, vd = a.unstable_LowPriority, bs = a.unstable_IdlePriority, Gh = a.unstable_yieldValue, qh = a.unstable_setDisableYieldValue, Ss = null, br = null, Se = null, Gn = !1, Ar = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Qh(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t.isDisabled)
        return !0;
      if (!t.supportsFiber)
        return h("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Vn && (e = mt({}, e, {
          getLaneLabelMap: Cs,
          injectProfilingHooks: No
        })), Ss = t.inject(e), br = t;
      } catch (o) {
        h("React instrumentation encountered an error: %s.", o);
      }
      return !!t.checkDCE;
    }
    function ng(e, t) {
      if (br && typeof br.onScheduleFiberRoot == "function")
        try {
          br.onScheduleFiberRoot(Ss, e, t);
        } catch (o) {
          Gn || (Gn = !0, h("React instrumentation encountered an error: %s", o));
        }
    }
    function $o(e, t) {
      if (br && typeof br.onCommitFiberRoot == "function")
        try {
          var o = (e.current.flags & rt) === rt;
          if (bt) {
            var l;
            switch (t) {
              case qr:
                l = md;
                break;
              case Mr:
                l = Ka;
                break;
              case Vo:
                l = no;
                break;
              case Gc:
                l = bs;
                break;
              default:
                l = no;
                break;
            }
            br.onCommitFiberRoot(Ss, e, l, o);
          }
        } catch (f) {
          Gn || (Gn = !0, h("React instrumentation encountered an error: %s", f));
        }
    }
    function xs(e) {
      if (br && typeof br.onPostCommitFiberRoot == "function")
        try {
          br.onPostCommitFiberRoot(Ss, e);
        } catch (t) {
          Gn || (Gn = !0, h("React instrumentation encountered an error: %s", t));
        }
    }
    function Kh(e) {
      if (br && typeof br.onCommitFiberUnmount == "function")
        try {
          br.onCommitFiberUnmount(Ss, e);
        } catch (t) {
          Gn || (Gn = !0, h("React instrumentation encountered an error: %s", t));
        }
    }
    function ir(e) {
      if (typeof Gh == "function" && (qh(e), p(e)), br && typeof br.setStrictMode == "function")
        try {
          br.setStrictMode(Ss, e);
        } catch (t) {
          Gn || (Gn = !0, h("React instrumentation encountered an error: %s", t));
        }
    }
    function No(e) {
      Se = e;
    }
    function Cs() {
      {
        for (var e = /* @__PURE__ */ new Map(), t = 1, o = 0; o < En; o++) {
          var l = r1(t);
          e.set(t, l), t *= 2;
        }
        return e;
      }
    }
    function yd(e) {
      Se !== null && typeof Se.markCommitStarted == "function" && Se.markCommitStarted(e);
    }
    function Xh() {
      Se !== null && typeof Se.markCommitStopped == "function" && Se.markCommitStopped();
    }
    function Es(e) {
      Se !== null && typeof Se.markComponentRenderStarted == "function" && Se.markComponentRenderStarted(e);
    }
    function dl() {
      Se !== null && typeof Se.markComponentRenderStopped == "function" && Se.markComponentRenderStopped();
    }
    function rg(e) {
      Se !== null && typeof Se.markComponentPassiveEffectMountStarted == "function" && Se.markComponentPassiveEffectMountStarted(e);
    }
    function Zh() {
      Se !== null && typeof Se.markComponentPassiveEffectMountStopped == "function" && Se.markComponentPassiveEffectMountStopped();
    }
    function gd(e) {
      Se !== null && typeof Se.markComponentPassiveEffectUnmountStarted == "function" && Se.markComponentPassiveEffectUnmountStarted(e);
    }
    function ag() {
      Se !== null && typeof Se.markComponentPassiveEffectUnmountStopped == "function" && Se.markComponentPassiveEffectUnmountStopped();
    }
    function ig(e) {
      Se !== null && typeof Se.markComponentLayoutEffectMountStarted == "function" && Se.markComponentLayoutEffectMountStarted(e);
    }
    function og() {
      Se !== null && typeof Se.markComponentLayoutEffectMountStopped == "function" && Se.markComponentLayoutEffectMountStopped();
    }
    function bd(e) {
      Se !== null && typeof Se.markComponentLayoutEffectUnmountStarted == "function" && Se.markComponentLayoutEffectUnmountStarted(e);
    }
    function gu() {
      Se !== null && typeof Se.markComponentLayoutEffectUnmountStopped == "function" && Se.markComponentLayoutEffectUnmountStopped();
    }
    function Sd(e, t, o) {
      Se !== null && typeof Se.markComponentErrored == "function" && Se.markComponentErrored(e, t, o);
    }
    function sg(e, t, o) {
      Se !== null && typeof Se.markComponentSuspended == "function" && Se.markComponentSuspended(e, t, o);
    }
    function lg(e) {
      Se !== null && typeof Se.markLayoutEffectsStarted == "function" && Se.markLayoutEffectsStarted(e);
    }
    function bu() {
      Se !== null && typeof Se.markLayoutEffectsStopped == "function" && Se.markLayoutEffectsStopped();
    }
    function ug(e) {
      Se !== null && typeof Se.markPassiveEffectsStarted == "function" && Se.markPassiveEffectsStarted(e);
    }
    function Vc() {
      Se !== null && typeof Se.markPassiveEffectsStopped == "function" && Se.markPassiveEffectsStopped();
    }
    function Bi(e) {
      Se !== null && typeof Se.markRenderStarted == "function" && Se.markRenderStarted(e);
    }
    function jc() {
      Se !== null && typeof Se.markRenderYielded == "function" && Se.markRenderYielded();
    }
    function Su() {
      Se !== null && typeof Se.markRenderStopped == "function" && Se.markRenderStopped();
    }
    function pl(e) {
      Se !== null && typeof Se.markRenderScheduled == "function" && Se.markRenderScheduled(e);
    }
    function Jh(e, t) {
      Se !== null && typeof Se.markForceUpdateScheduled == "function" && Se.markForceUpdateScheduled(e, t);
    }
    function ws(e, t) {
      Se !== null && typeof Se.markStateUpdateScheduled == "function" && Se.markStateUpdateScheduled(e, t);
    }
    var Qe = (
      /*                         */
      0
    ), xt = (
      /*                 */
      1
    ), Xe = (
      /*                    */
      2
    ), Pn = (
      /*               */
      8
    ), mi = (
      /*              */
      16
    ), xd = Math.clz32 ? Math.clz32 : hl, Cd = Math.log, em = Math.LN2;
    function hl(e) {
      var t = e >>> 0;
      return t === 0 ? 32 : 31 - (Cd(t) / em | 0) | 0;
    }
    var En = 31, oe = (
      /*                        */
      0
    ), _t = (
      /*                          */
      0
    ), Ze = (
      /*                        */
      1
    ), ro = (
      /*    */
      2
    ), Xa = (
      /*             */
      4
    ), ml = (
      /*            */
      8
    ), wn = (
      /*                     */
      16
    ), vl = (
      /*                */
      32
    ), Ts = (
      /*                       */
      4194240
    ), yl = (
      /*                        */
      64
    ), yi = (
      /*                        */
      128
    ), za = (
      /*                        */
      256
    ), gl = (
      /*                        */
      512
    ), Bc = (
      /*                        */
      1024
    ), Uc = (
      /*                        */
      2048
    ), Ed = (
      /*                        */
      4096
    ), wd = (
      /*                        */
      8192
    ), Td = (
      /*                        */
      16384
    ), kd = (
      /*                       */
      32768
    ), Rd = (
      /*                       */
      65536
    ), _d = (
      /*                       */
      131072
    ), Dd = (
      /*                       */
      262144
    ), Ad = (
      /*                       */
      524288
    ), bl = (
      /*                       */
      1048576
    ), Md = (
      /*                       */
      2097152
    ), Sl = (
      /*                            */
      130023424
    ), Fo = (
      /*                             */
      4194304
    ), Od = (
      /*                             */
      8388608
    ), Ic = (
      /*                             */
      16777216
    ), zd = (
      /*                             */
      33554432
    ), Pd = (
      /*                             */
      67108864
    ), tm = Fo, xu = (
      /*          */
      134217728
    ), Ld = (
      /*                          */
      268435455
    ), Cu = (
      /*               */
      268435456
    ), ks = (
      /*                        */
      536870912
    ), Pa = (
      /*                   */
      1073741824
    );
    function r1(e) {
      {
        if (e & Ze)
          return "Sync";
        if (e & ro)
          return "InputContinuousHydration";
        if (e & Xa)
          return "InputContinuous";
        if (e & ml)
          return "DefaultHydration";
        if (e & wn)
          return "Default";
        if (e & vl)
          return "TransitionHydration";
        if (e & Ts)
          return "Transition";
        if (e & Sl)
          return "Retry";
        if (e & xu)
          return "SelectiveHydration";
        if (e & Cu)
          return "IdleHydration";
        if (e & ks)
          return "Idle";
        if (e & Pa)
          return "Offscreen";
      }
    }
    var dn = -1, $d = yl, Nd = Fo;
    function Eu(e) {
      switch (er(e)) {
        case Ze:
          return Ze;
        case ro:
          return ro;
        case Xa:
          return Xa;
        case ml:
          return ml;
        case wn:
          return wn;
        case vl:
          return vl;
        case yl:
        case yi:
        case za:
        case gl:
        case Bc:
        case Uc:
        case Ed:
        case wd:
        case Td:
        case kd:
        case Rd:
        case _d:
        case Dd:
        case Ad:
        case bl:
        case Md:
          return e & Ts;
        case Fo:
        case Od:
        case Ic:
        case zd:
        case Pd:
          return e & Sl;
        case xu:
          return xu;
        case Cu:
          return Cu;
        case ks:
          return ks;
        case Pa:
          return Pa;
        default:
          return h("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function Hc(e, t) {
      var o = e.pendingLanes;
      if (o === oe)
        return oe;
      var l = oe, f = e.suspendedLanes, m = e.pingedLanes, g = o & Ld;
      if (g !== oe) {
        var C = g & ~f;
        if (C !== oe)
          l = Eu(C);
        else {
          var T = g & m;
          T !== oe && (l = Eu(T));
        }
      } else {
        var D = o & ~f;
        D !== oe ? l = Eu(D) : m !== oe && (l = Eu(m));
      }
      if (l === oe)
        return oe;
      if (t !== oe && t !== l && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (t & f) === oe) {
        var M = er(l), U = er(t);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          M >= U || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          M === wn && (U & Ts) !== oe
        )
          return t;
      }
      (l & Xa) !== oe && (l |= o & wn);
      var V = e.entangledLanes;
      if (V !== oe)
        for (var Z = e.entanglements, J = l & V; J > 0; ) {
          var ae = Rs(J), Re = 1 << ae;
          l |= Z[ae], J &= ~Re;
        }
      return l;
    }
    function cg(e, t) {
      for (var o = e.eventTimes, l = dn; t > 0; ) {
        var f = Rs(t), m = 1 << f, g = o[f];
        g > l && (l = g), t &= ~m;
      }
      return l;
    }
    function Fd(e, t) {
      switch (e) {
        case Ze:
        case ro:
        case Xa:
          return t + 250;
        case ml:
        case wn:
        case vl:
        case yl:
        case yi:
        case za:
        case gl:
        case Bc:
        case Uc:
        case Ed:
        case wd:
        case Td:
        case kd:
        case Rd:
        case _d:
        case Dd:
        case Ad:
        case bl:
        case Md:
          return t + 5e3;
        case Fo:
        case Od:
        case Ic:
        case zd:
        case Pd:
          return dn;
        case xu:
        case Cu:
        case ks:
        case Pa:
          return dn;
        default:
          return h("Should have found matching lanes. This is a bug in React."), dn;
      }
    }
    function a1(e, t) {
      for (var o = e.pendingLanes, l = e.suspendedLanes, f = e.pingedLanes, m = e.expirationTimes, g = o; g > 0; ) {
        var C = Rs(g), T = 1 << C, D = m[C];
        D === dn ? ((T & l) === oe || (T & f) !== oe) && (m[C] = Fd(T, t)) : D <= t && (e.expiredLanes |= T), g &= ~T;
      }
    }
    function i1(e) {
      return Eu(e.pendingLanes);
    }
    function nm(e) {
      var t = e.pendingLanes & ~Pa;
      return t !== oe ? t : t & Pa ? Pa : oe;
    }
    function wu(e) {
      return (e & Ze) !== oe;
    }
    function Wc(e) {
      return (e & Ld) !== oe;
    }
    function Vd(e) {
      return (e & Sl) === e;
    }
    function o1(e) {
      var t = Ze | Xa | wn;
      return (e & t) === oe;
    }
    function fg(e) {
      return (e & Ts) === e;
    }
    function Yc(e, t) {
      var o = ro | Xa | ml | wn;
      return (t & o) !== oe;
    }
    function dg(e, t) {
      return (t & e.expiredLanes) !== oe;
    }
    function rm(e) {
      return (e & Ts) !== oe;
    }
    function am() {
      var e = $d;
      return $d <<= 1, ($d & Ts) === oe && ($d = yl), e;
    }
    function s1() {
      var e = Nd;
      return Nd <<= 1, (Nd & Sl) === oe && (Nd = Fo), e;
    }
    function er(e) {
      return e & -e;
    }
    function or(e) {
      return er(e);
    }
    function Rs(e) {
      return 31 - xd(e);
    }
    function jd(e) {
      return Rs(e);
    }
    function La(e, t) {
      return (e & t) !== oe;
    }
    function xl(e, t) {
      return (e & t) === t;
    }
    function pt(e, t) {
      return e | t;
    }
    function Tu(e, t) {
      return e & ~t;
    }
    function im(e, t) {
      return e & t;
    }
    function pg(e) {
      return e;
    }
    function hg(e, t) {
      return e !== _t && e < t ? e : t;
    }
    function Bd(e) {
      for (var t = [], o = 0; o < En; o++)
        t.push(e);
      return t;
    }
    function Cl(e, t, o) {
      e.pendingLanes |= t, t !== ks && (e.suspendedLanes = oe, e.pingedLanes = oe);
      var l = e.eventTimes, f = jd(t);
      l[f] = o;
    }
    function om(e, t) {
      e.suspendedLanes |= t, e.pingedLanes &= ~t;
      for (var o = e.expirationTimes, l = t; l > 0; ) {
        var f = Rs(l), m = 1 << f;
        o[f] = dn, l &= ~m;
      }
    }
    function sm(e, t, o) {
      e.pingedLanes |= e.suspendedLanes & t;
    }
    function lm(e, t) {
      var o = e.pendingLanes & ~t;
      e.pendingLanes = t, e.suspendedLanes = oe, e.pingedLanes = oe, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t;
      for (var l = e.entanglements, f = e.eventTimes, m = e.expirationTimes, g = o; g > 0; ) {
        var C = Rs(g), T = 1 << C;
        l[C] = oe, f[C] = dn, m[C] = dn, g &= ~T;
      }
    }
    function ku(e, t) {
      for (var o = e.entangledLanes |= t, l = e.entanglements, f = o; f; ) {
        var m = Rs(f), g = 1 << m;
        // Is this one of the newly entangled lanes?
        g & t | // Is this lane transitively entangled with the newly entangled lanes?
        l[m] & t && (l[m] |= t), f &= ~g;
      }
    }
    function l1(e, t) {
      var o = er(t), l;
      switch (o) {
        case Xa:
          l = ro;
          break;
        case wn:
          l = ml;
          break;
        case yl:
        case yi:
        case za:
        case gl:
        case Bc:
        case Uc:
        case Ed:
        case wd:
        case Td:
        case kd:
        case Rd:
        case _d:
        case Dd:
        case Ad:
        case bl:
        case Md:
        case Fo:
        case Od:
        case Ic:
        case zd:
        case Pd:
          l = vl;
          break;
        case ks:
          l = Cu;
          break;
        default:
          l = _t;
          break;
      }
      return (l & (e.suspendedLanes | t)) !== _t ? _t : l;
    }
    function um(e, t, o) {
      if (Ar)
        for (var l = e.pendingUpdatersLaneMap; o > 0; ) {
          var f = jd(o), m = 1 << f, g = l[f];
          g.add(t), o &= ~m;
        }
    }
    function Ud(e, t) {
      if (Ar)
        for (var o = e.pendingUpdatersLaneMap, l = e.memoizedUpdaters; t > 0; ) {
          var f = jd(t), m = 1 << f, g = o[f];
          g.size > 0 && (g.forEach(function(C) {
            var T = C.alternate;
            (T === null || !l.has(T)) && l.add(C);
          }), g.clear()), t &= ~m;
        }
    }
    function cm(e, t) {
      return null;
    }
    var qr = Ze, Mr = Xa, Vo = wn, Gc = ks, El = _t;
    function gi() {
      return El;
    }
    function sr(e) {
      El = e;
    }
    function qc(e, t) {
      var o = El;
      try {
        return El = e, t();
      } finally {
        El = o;
      }
    }
    function Qr(e, t) {
      return e !== 0 && e < t ? e : t;
    }
    function u1(e, t) {
      return e === 0 || e > t ? e : t;
    }
    function fm(e, t) {
      return e !== 0 && e < t;
    }
    function Qc(e) {
      var t = er(e);
      return fm(qr, t) ? fm(Mr, t) ? Wc(t) ? Vo : Gc : Mr : qr;
    }
    function lr(e) {
      var t = e.current.memoizedState;
      return t.isDehydrated;
    }
    var mg;
    function Me(e) {
      mg = e;
    }
    function Ru(e) {
      mg(e);
    }
    var Kc;
    function vg(e) {
      Kc = e;
    }
    var yg;
    function Xc(e) {
      yg = e;
    }
    var Zc;
    function dm(e) {
      Zc = e;
    }
    var pm;
    function gg(e) {
      pm = e;
    }
    var Id = !1, _u = [], ao = null, Dn = null, Sr = null, bi = /* @__PURE__ */ new Map(), Du = /* @__PURE__ */ new Map(), jo = [], Ui = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function bg(e) {
      return Ui.indexOf(e) > -1;
    }
    function io(e, t, o, l, f) {
      return {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: o,
        nativeEvent: f,
        targetContainers: [l]
      };
    }
    function Sg(e, t) {
      switch (e) {
        case "focusin":
        case "focusout":
          ao = null;
          break;
        case "dragenter":
        case "dragleave":
          Dn = null;
          break;
        case "mouseover":
        case "mouseout":
          Sr = null;
          break;
        case "pointerover":
        case "pointerout": {
          var o = t.pointerId;
          bi.delete(o);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var l = t.pointerId;
          Du.delete(l);
          break;
        }
      }
    }
    function Au(e, t, o, l, f, m) {
      if (e === null || e.nativeEvent !== m) {
        var g = io(t, o, l, f, m);
        if (t !== null) {
          var C = Bu(t);
          C !== null && Kc(C);
        }
        return g;
      }
      e.eventSystemFlags |= l;
      var T = e.targetContainers;
      return f !== null && T.indexOf(f) === -1 && T.push(f), e;
    }
    function xg(e, t, o, l, f) {
      switch (t) {
        case "focusin": {
          var m = f;
          return ao = Au(ao, e, t, o, l, m), !0;
        }
        case "dragenter": {
          var g = f;
          return Dn = Au(Dn, e, t, o, l, g), !0;
        }
        case "mouseover": {
          var C = f;
          return Sr = Au(Sr, e, t, o, l, C), !0;
        }
        case "pointerover": {
          var T = f, D = T.pointerId;
          return bi.set(D, Au(bi.get(D) || null, e, t, o, l, T)), !0;
        }
        case "gotpointercapture": {
          var M = f, U = M.pointerId;
          return Du.set(U, Au(Du.get(U) || null, e, t, o, l, M)), !0;
        }
      }
      return !1;
    }
    function hm(e) {
      var t = lf(e.target);
      if (t !== null) {
        var o = qa(t);
        if (o !== null) {
          var l = o.tag;
          if (l === H) {
            var f = Ih(o);
            if (f !== null) {
              e.blockedOn = f, pm(e.priority, function() {
                yg(o);
              });
              return;
            }
          } else if (l === k) {
            var m = o.stateNode;
            if (lr(m)) {
              e.blockedOn = fd(o);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Cg(e) {
      for (var t = Zc(), o = {
        blockedOn: null,
        target: e,
        priority: t
      }, l = 0; l < jo.length && fm(t, jo[l].priority); l++)
        ;
      jo.splice(l, 0, o), l === 0 && hm(o);
    }
    function Hd(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var t = e.targetContainers; t.length > 0; ) {
        var o = t[0], l = wl(e.domEventName, e.eventSystemFlags, o, e.nativeEvent);
        if (l === null) {
          var f = e.nativeEvent, m = new f.constructor(f.type, f);
          Mc(m), f.target.dispatchEvent(m), JS();
        } else {
          var g = Bu(l);
          return g !== null && Kc(g), e.blockedOn = l, !1;
        }
        t.shift();
      }
      return !0;
    }
    function Jc(e, t, o) {
      Hd(e) && o.delete(t);
    }
    function mm() {
      Id = !1, ao !== null && Hd(ao) && (ao = null), Dn !== null && Hd(Dn) && (Dn = null), Sr !== null && Hd(Sr) && (Sr = null), bi.forEach(Jc), Du.forEach(Jc);
    }
    function Kr(e, t) {
      e.blockedOn === t && (e.blockedOn = null, Id || (Id = !0, a.unstable_scheduleCallback(a.unstable_NormalPriority, mm)));
    }
    function wt(e) {
      if (_u.length > 0) {
        Kr(_u[0], e);
        for (var t = 1; t < _u.length; t++) {
          var o = _u[t];
          o.blockedOn === e && (o.blockedOn = null);
        }
      }
      ao !== null && Kr(ao, e), Dn !== null && Kr(Dn, e), Sr !== null && Kr(Sr, e);
      var l = function(C) {
        return Kr(C, e);
      };
      bi.forEach(l), Du.forEach(l);
      for (var f = 0; f < jo.length; f++) {
        var m = jo[f];
        m.blockedOn === e && (m.blockedOn = null);
      }
      for (; jo.length > 0; ) {
        var g = jo[0];
        if (g.blockedOn !== null)
          break;
        hm(g), g.blockedOn === null && jo.shift();
      }
    }
    var Ln = s.ReactCurrentBatchConfig, In = !0;
    function xr(e) {
      In = !!e;
    }
    function Za() {
      return In;
    }
    function Mu(e, t, o) {
      var l = ia(t), f;
      switch (l) {
        case qr:
          f = ur;
          break;
        case Mr:
          f = ef;
          break;
        case Vo:
        default:
          f = Bo;
          break;
      }
      return f.bind(null, t, o, e);
    }
    function ur(e, t, o, l) {
      var f = gi(), m = Ln.transition;
      Ln.transition = null;
      try {
        sr(qr), Bo(e, t, o, l);
      } finally {
        sr(f), Ln.transition = m;
      }
    }
    function ef(e, t, o, l) {
      var f = gi(), m = Ln.transition;
      Ln.transition = null;
      try {
        sr(Mr), Bo(e, t, o, l);
      } finally {
        sr(f), Ln.transition = m;
      }
    }
    function Bo(e, t, o, l) {
      In && Wd(e, t, o, l);
    }
    function Wd(e, t, o, l) {
      var f = wl(e, t, o, l);
      if (f === null) {
        D1(e, t, l, Ou, o), Sg(e, l);
        return;
      }
      if (xg(f, e, t, o, l)) {
        l.stopPropagation();
        return;
      }
      if (Sg(e, l), t & ol && bg(e)) {
        for (; f !== null; ) {
          var m = Bu(f);
          m !== null && Ru(m);
          var g = wl(e, t, o, l);
          if (g === null && D1(e, t, l, Ou, o), g === f)
            break;
          f = g;
        }
        f !== null && l.stopPropagation();
        return;
      }
      D1(e, t, l, null, o);
    }
    var Ou = null;
    function wl(e, t, o, l) {
      Ou = null;
      var f = od(l), m = lf(f);
      if (m !== null) {
        var g = qa(m);
        if (g === null)
          m = null;
        else {
          var C = g.tag;
          if (C === H) {
            var T = Ih(g);
            if (T !== null)
              return T;
            m = null;
          } else if (C === k) {
            var D = g.stateNode;
            if (lr(D))
              return fd(g);
            m = null;
          } else
            g !== m && (m = null);
        }
      }
      return Ou = m, null;
    }
    function ia(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return qr;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Mr;
        case "message": {
          var t = Yh();
          switch (t) {
            case md:
              return qr;
            case Ka:
              return Mr;
            case no:
            case vd:
              return Vo;
            case bs:
              return Gc;
            default:
              return Vo;
          }
        }
        default:
          return Vo;
      }
    }
    function vm(e, t, o) {
      return e.addEventListener(t, o, !1), o;
    }
    function zu(e, t, o) {
      return e.addEventListener(t, o, !0), o;
    }
    function Uo(e, t, o, l) {
      return e.addEventListener(t, o, {
        capture: !0,
        passive: l
      }), o;
    }
    function Yd(e, t, o, l) {
      return e.addEventListener(t, o, {
        passive: l
      }), o;
    }
    var Tl = null, oo = null, _s = null;
    function Ds(e) {
      return Tl = e, oo = qd(), !0;
    }
    function Gd() {
      Tl = null, oo = null, _s = null;
    }
    function Pu() {
      if (_s)
        return _s;
      var e, t = oo, o = t.length, l, f = qd(), m = f.length;
      for (e = 0; e < o && t[e] === f[e]; e++)
        ;
      var g = o - e;
      for (l = 1; l <= g && t[o - l] === f[m - l]; l++)
        ;
      var C = l > 1 ? 1 - l : void 0;
      return _s = f.slice(e, C), _s;
    }
    function qd() {
      return "value" in Tl ? Tl.value : Tl.textContent;
    }
    function kl(e) {
      var t, o = e.keyCode;
      return "charCode" in e ? (t = e.charCode, t === 0 && o === 13 && (t = 13)) : t = o, t === 10 && (t = 13), t >= 32 || t === 13 ? t : 0;
    }
    function Rl() {
      return !0;
    }
    function Xr() {
      return !1;
    }
    function tr(e) {
      function t(o, l, f, m, g) {
        this._reactName = o, this._targetInst = f, this.type = l, this.nativeEvent = m, this.target = g, this.currentTarget = null;
        for (var C in e)
          if (e.hasOwnProperty(C)) {
            var T = e[C];
            T ? this[C] = T(m) : this[C] = m[C];
          }
        var D = m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1;
        return D ? this.isDefaultPrevented = Rl : this.isDefaultPrevented = Xr, this.isPropagationStopped = Xr, this;
      }
      return mt(t.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var o = this.nativeEvent;
          o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = Rl);
        },
        stopPropagation: function() {
          var o = this.nativeEvent;
          o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = Rl);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Rl
      }), t;
    }
    var Zr = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Jr = tr(Zr), Lu = mt({}, Zr, {
      view: 0,
      detail: 0
    }), ym = tr(Lu), tf, gm, Si;
    function Eg(e) {
      e !== Si && (Si && e.type === "mousemove" ? (tf = e.screenX - Si.screenX, gm = e.screenY - Si.screenY) : (tf = 0, gm = 0), Si = e);
    }
    var $u = mt({}, Lu, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Xd,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (Eg(e), tf);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : gm;
      }
    }), As = tr($u), bm = mt({}, $u, {
      dataTransfer: 0
    }), _l = tr(bm), wg = mt({}, Lu, {
      relatedTarget: 0
    }), Qd = tr(wg), Sm = mt({}, Zr, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Kd = tr(Sm), c1 = mt({}, Zr, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), f1 = tr(c1), Tg = mt({}, Zr, {
      data: 0
    }), xm = tr(Tg), Dl = xm, d1 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nu = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function kg(e) {
      if (e.key) {
        var t = d1[e.key] || e.key;
        if (t !== "Unidentified")
          return t;
      }
      if (e.type === "keypress") {
        var o = kl(e);
        return o === 13 ? "Enter" : String.fromCharCode(o);
      }
      return e.type === "keydown" || e.type === "keyup" ? Nu[e.keyCode] || "Unidentified" : "";
    }
    var Hn = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function p1(e) {
      var t = this, o = t.nativeEvent;
      if (o.getModifierState)
        return o.getModifierState(e);
      var l = Hn[e];
      return l ? !!o[l] : !1;
    }
    function Xd(e) {
      return p1;
    }
    var h1 = mt({}, Lu, {
      key: kg,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Xd,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? kl(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? kl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), m1 = tr(h1), Rg = mt({}, $u, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Cm = tr(Rg), v1 = mt({}, Lu, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Xd
    }), xi = tr(v1), Em = mt({}, Zr, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), y1 = tr(Em), Ms = mt({}, $u, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Zd = tr(Ms), Al = [9, 13, 27, 32], nf = 229, rf = kn && "CompositionEvent" in window, Ml = null;
    kn && "documentMode" in document && (Ml = document.documentMode);
    var g1 = kn && "TextEvent" in window && !Ml, Jd = kn && (!rf || Ml && Ml > 8 && Ml <= 11), _g = 32, wm = String.fromCharCode(_g);
    function Dg() {
      $t("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), $t("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), $t("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), $t("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var af = !1;
    function ep(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function Ag(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Tm(e, t) {
      return e === "keydown" && t.keyCode === nf;
    }
    function Mg(e, t) {
      switch (e) {
        case "keyup":
          return Al.indexOf(t.keyCode) !== -1;
        case "keydown":
          return t.keyCode !== nf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function km(e) {
      var t = e.detail;
      return typeof t == "object" && "data" in t ? t.data : null;
    }
    function tp(e) {
      return e.locale === "ko";
    }
    var Io = !1;
    function Rm(e, t, o, l, f) {
      var m, g;
      if (rf ? m = Ag(t) : Io ? Mg(t, l) && (m = "onCompositionEnd") : Tm(t, l) && (m = "onCompositionStart"), !m)
        return null;
      Jd && !tp(l) && (!Io && m === "onCompositionStart" ? Io = Ds(f) : m === "onCompositionEnd" && Io && (g = Pu()));
      var C = $g(o, m);
      if (C.length > 0) {
        var T = new xm(m, t, null, l, f);
        if (e.push({
          event: T,
          listeners: C
        }), g)
          T.data = g;
        else {
          var D = km(l);
          D !== null && (T.data = D);
        }
      }
    }
    function np(e, t) {
      switch (e) {
        case "compositionend":
          return km(t);
        case "keypress":
          var o = t.which;
          return o !== _g ? null : (af = !0, wm);
        case "textInput":
          var l = t.data;
          return l === wm && af ? null : l;
        default:
          return null;
      }
    }
    function Og(e, t) {
      if (Io) {
        if (e === "compositionend" || !rf && Mg(e, t)) {
          var o = Pu();
          return Gd(), Io = !1, o;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!ep(t)) {
            if (t.char && t.char.length > 1)
              return t.char;
            if (t.which)
              return String.fromCharCode(t.which);
          }
          return null;
        case "compositionend":
          return Jd && !tp(t) ? null : t.data;
        default:
          return null;
      }
    }
    function b1(e, t, o, l, f) {
      var m;
      if (g1 ? m = np(t, l) : m = Og(t, l), !m)
        return null;
      var g = $g(o, "onBeforeInput");
      if (g.length > 0) {
        var C = new Dl("onBeforeInput", "beforeinput", null, l, f);
        e.push({
          event: C,
          listeners: g
        }), C.data = m;
      }
    }
    function rp(e, t, o, l, f, m, g) {
      Rm(e, t, o, l, f), b1(e, t, o, l, f);
    }
    var S1 = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Fu(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t === "input" ? !!S1[e.type] : t === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function x1(e) {
      if (!kn)
        return !1;
      var t = "on" + e, o = t in document;
      if (!o) {
        var l = document.createElement("div");
        l.setAttribute(t, "return;"), o = typeof l[t] == "function";
      }
      return o;
    }
    function ap() {
      $t("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function r(e, t, o, l) {
      sd(l);
      var f = $g(t, "onChange");
      if (f.length > 0) {
        var m = new Jr("onChange", "change", null, o, l);
        e.push({
          event: m,
          listeners: f
        });
      }
    }
    var i = null, u = null;
    function d(e) {
      var t = e.nodeName && e.nodeName.toLowerCase();
      return t === "select" || t === "input" && e.type === "file";
    }
    function y(e) {
      var t = [];
      r(t, u, e, od(e)), Lh(S, t);
    }
    function S(e) {
      WT(e, 0);
    }
    function R(e) {
      var t = cp(e);
      if (O(t))
        return e;
    }
    function z(e, t) {
      if (e === "change")
        return t;
    }
    var N = !1;
    kn && (N = x1("input") && (!document.documentMode || document.documentMode > 9));
    function te(e, t) {
      i = e, u = t, i.attachEvent("onpropertychange", de);
    }
    function fe() {
      i && (i.detachEvent("onpropertychange", de), i = null, u = null);
    }
    function de(e) {
      e.propertyName === "value" && R(u) && y(e);
    }
    function ue(e, t, o) {
      e === "focusin" ? (fe(), te(t, o)) : e === "focusout" && fe();
    }
    function Te(e, t) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return R(u);
    }
    function ze(e) {
      var t = e.nodeName;
      return t && t.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function Ne(e, t) {
      if (e === "click")
        return R(t);
    }
    function qn(e, t) {
      if (e === "input" || e === "change")
        return R(t);
    }
    function G(e) {
      var t = e._wrapperState;
      !t || !t.controlled || e.type !== "number" || Ni(e, "number", e.value);
    }
    function B(e, t, o, l, f, m, g) {
      var C = o ? cp(o) : window, T, D;
      if (d(C) ? T = z : Fu(C) ? N ? T = qn : (T = Te, D = ue) : ze(C) && (T = Ne), T) {
        var M = T(t, o);
        if (M) {
          r(e, M, l, f);
          return;
        }
      }
      D && D(t, C, o), t === "focusout" && G(C);
    }
    function X() {
      ge("onMouseEnter", ["mouseout", "mouseover"]), ge("onMouseLeave", ["mouseout", "mouseover"]), ge("onPointerEnter", ["pointerout", "pointerover"]), ge("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function me(e, t, o, l, f, m, g) {
      var C = t === "mouseover" || t === "pointerover", T = t === "mouseout" || t === "pointerout";
      if (C && !Qy(l)) {
        var D = l.relatedTarget || l.fromElement;
        if (D && (lf(D) || Bm(D)))
          return;
      }
      if (!(!T && !C)) {
        var M;
        if (f.window === f)
          M = f;
        else {
          var U = f.ownerDocument;
          U ? M = U.defaultView || U.parentWindow : M = window;
        }
        var V, Z;
        if (T) {
          var J = l.relatedTarget || l.toElement;
          if (V = o, Z = J ? lf(J) : null, Z !== null) {
            var ae = qa(Z);
            (Z !== ae || Z.tag !== A && Z.tag !== L) && (Z = null);
          }
        } else
          V = null, Z = o;
        if (V !== Z) {
          var Re = As, qe = "onMouseLeave", je = "onMouseEnter", At = "mouse";
          (t === "pointerout" || t === "pointerover") && (Re = Cm, qe = "onPointerLeave", je = "onPointerEnter", At = "pointer");
          var Tt = V == null ? M : cp(V), q = Z == null ? M : cp(Z), ie = new Re(qe, At + "leave", V, l, f);
          ie.target = Tt, ie.relatedTarget = q;
          var Q = null, pe = lf(f);
          if (pe === o) {
            var _e = new Re(je, At + "enter", Z, l, f);
            _e.target = q, _e.relatedTarget = Tt, Q = _e;
          }
          NP(e, ie, Q, V, Z);
        }
      }
    }
    function Ve(e, t) {
      return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
    }
    var Pe = typeof Object.is == "function" ? Object.is : Ve;
    function Ie(e, t) {
      if (Pe(e, t))
        return !0;
      if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
      var o = Object.keys(e), l = Object.keys(t);
      if (o.length !== l.length)
        return !1;
      for (var f = 0; f < o.length; f++) {
        var m = o[f];
        if (!Mn.call(t, m) || !Pe(e[m], t[m]))
          return !1;
      }
      return !0;
    }
    function at(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Cr(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function zt(e, t) {
      for (var o = at(e), l = 0, f = 0; o; ) {
        if (o.nodeType === Ao) {
          if (f = l + o.textContent.length, l <= t && f >= t)
            return {
              node: o,
              offset: t - l
            };
          l = f;
        }
        o = at(Cr(o));
      }
    }
    function Os(e) {
      var t = e.ownerDocument, o = t && t.defaultView || window, l = o.getSelection && o.getSelection();
      if (!l || l.rangeCount === 0)
        return null;
      var f = l.anchorNode, m = l.anchorOffset, g = l.focusNode, C = l.focusOffset;
      try {
        f.nodeType, g.nodeType;
      } catch {
        return null;
      }
      return C1(e, f, m, g, C);
    }
    function C1(e, t, o, l, f) {
      var m = 0, g = -1, C = -1, T = 0, D = 0, M = e, U = null;
      e:
        for (; ; ) {
          for (var V = null; M === t && (o === 0 || M.nodeType === Ao) && (g = m + o), M === l && (f === 0 || M.nodeType === Ao) && (C = m + f), M.nodeType === Ao && (m += M.nodeValue.length), (V = M.firstChild) !== null; )
            U = M, M = V;
          for (; ; ) {
            if (M === e)
              break e;
            if (U === t && ++T === o && (g = m), U === l && ++D === f && (C = m), (V = M.nextSibling) !== null)
              break;
            M = U, U = M.parentNode;
          }
          M = V;
        }
      return g === -1 || C === -1 ? null : {
        start: g,
        end: C
      };
    }
    function gP(e, t) {
      var o = e.ownerDocument || document, l = o && o.defaultView || window;
      if (l.getSelection) {
        var f = l.getSelection(), m = e.textContent.length, g = Math.min(t.start, m), C = t.end === void 0 ? g : Math.min(t.end, m);
        if (!f.extend && g > C) {
          var T = C;
          C = g, g = T;
        }
        var D = zt(e, g), M = zt(e, C);
        if (D && M) {
          if (f.rangeCount === 1 && f.anchorNode === D.node && f.anchorOffset === D.offset && f.focusNode === M.node && f.focusOffset === M.offset)
            return;
          var U = o.createRange();
          U.setStart(D.node, D.offset), f.removeAllRanges(), g > C ? (f.addRange(U), f.extend(M.node, M.offset)) : (U.setEnd(M.node, M.offset), f.addRange(U));
        }
      }
    }
    function zT(e) {
      return e && e.nodeType === Ao;
    }
    function PT(e, t) {
      return !e || !t ? !1 : e === t ? !0 : zT(e) ? !1 : zT(t) ? PT(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1;
    }
    function bP(e) {
      return e && e.ownerDocument && PT(e.ownerDocument.documentElement, e);
    }
    function SP(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function LT() {
      for (var e = window, t = j(); t instanceof e.HTMLIFrameElement; ) {
        if (SP(t))
          e = t.contentWindow;
        else
          return t;
        t = j(e.document);
      }
      return t;
    }
    function E1(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
    }
    function xP() {
      var e = LT();
      return {
        focusedElem: e,
        selectionRange: E1(e) ? EP(e) : null
      };
    }
    function CP(e) {
      var t = LT(), o = e.focusedElem, l = e.selectionRange;
      if (t !== o && bP(o)) {
        l !== null && E1(o) && wP(o, l);
        for (var f = [], m = o; m = m.parentNode; )
          m.nodeType === Ra && f.push({
            element: m,
            left: m.scrollLeft,
            top: m.scrollTop
          });
        typeof o.focus == "function" && o.focus();
        for (var g = 0; g < f.length; g++) {
          var C = f[g];
          C.element.scrollLeft = C.left, C.element.scrollTop = C.top;
        }
      }
    }
    function EP(e) {
      var t;
      return "selectionStart" in e ? t = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : t = Os(e), t || {
        start: 0,
        end: 0
      };
    }
    function wP(e, t) {
      var o = t.start, l = t.end;
      l === void 0 && (l = o), "selectionStart" in e ? (e.selectionStart = o, e.selectionEnd = Math.min(l, e.value.length)) : gP(e, t);
    }
    var TP = kn && "documentMode" in document && document.documentMode <= 11;
    function kP() {
      $t("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var ip = null, w1 = null, _m = null, T1 = !1;
    function RP(e) {
      if ("selectionStart" in e && E1(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var t = e.ownerDocument && e.ownerDocument.defaultView || window, o = t.getSelection();
      return {
        anchorNode: o.anchorNode,
        anchorOffset: o.anchorOffset,
        focusNode: o.focusNode,
        focusOffset: o.focusOffset
      };
    }
    function _P(e) {
      return e.window === e ? e.document : e.nodeType === Fi ? e : e.ownerDocument;
    }
    function $T(e, t, o) {
      var l = _P(o);
      if (!(T1 || ip == null || ip !== j(l))) {
        var f = RP(ip);
        if (!_m || !Ie(_m, f)) {
          _m = f;
          var m = $g(w1, "onSelect");
          if (m.length > 0) {
            var g = new Jr("onSelect", "select", null, t, o);
            e.push({
              event: g,
              listeners: m
            }), g.target = ip;
          }
        }
      }
    }
    function DP(e, t, o, l, f, m, g) {
      var C = o ? cp(o) : window;
      switch (t) {
        case "focusin":
          (Fu(C) || C.contentEditable === "true") && (ip = C, w1 = o, _m = null);
          break;
        case "focusout":
          ip = null, w1 = null, _m = null;
          break;
        case "mousedown":
          T1 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          T1 = !1, $T(e, l, f);
          break;
        case "selectionchange":
          if (TP)
            break;
        case "keydown":
        case "keyup":
          $T(e, l, f);
      }
    }
    function zg(e, t) {
      var o = {};
      return o[e.toLowerCase()] = t.toLowerCase(), o["Webkit" + e] = "webkit" + t, o["Moz" + e] = "moz" + t, o;
    }
    var op = {
      animationend: zg("Animation", "AnimationEnd"),
      animationiteration: zg("Animation", "AnimationIteration"),
      animationstart: zg("Animation", "AnimationStart"),
      transitionend: zg("Transition", "TransitionEnd")
    }, k1 = {}, NT = {};
    kn && (NT = document.createElement("div").style, "AnimationEvent" in window || (delete op.animationend.animation, delete op.animationiteration.animation, delete op.animationstart.animation), "TransitionEvent" in window || delete op.transitionend.transition);
    function Pg(e) {
      if (k1[e])
        return k1[e];
      if (!op[e])
        return e;
      var t = op[e];
      for (var o in t)
        if (t.hasOwnProperty(o) && o in NT)
          return k1[e] = t[o];
      return e;
    }
    var FT = Pg("animationend"), VT = Pg("animationiteration"), jT = Pg("animationstart"), BT = Pg("transitionend"), UT = /* @__PURE__ */ new Map(), IT = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Vu(e, t) {
      UT.set(e, t), $t(t, [e]);
    }
    function AP() {
      for (var e = 0; e < IT.length; e++) {
        var t = IT[e], o = t.toLowerCase(), l = t[0].toUpperCase() + t.slice(1);
        Vu(o, "on" + l);
      }
      Vu(FT, "onAnimationEnd"), Vu(VT, "onAnimationIteration"), Vu(jT, "onAnimationStart"), Vu("dblclick", "onDoubleClick"), Vu("focusin", "onFocus"), Vu("focusout", "onBlur"), Vu(BT, "onTransitionEnd");
    }
    function MP(e, t, o, l, f, m, g) {
      var C = UT.get(t);
      if (C !== void 0) {
        var T = Jr, D = t;
        switch (t) {
          case "keypress":
            if (kl(l) === 0)
              return;
          case "keydown":
          case "keyup":
            T = m1;
            break;
          case "focusin":
            D = "focus", T = Qd;
            break;
          case "focusout":
            D = "blur", T = Qd;
            break;
          case "beforeblur":
          case "afterblur":
            T = Qd;
            break;
          case "click":
            if (l.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            T = As;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            T = _l;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            T = xi;
            break;
          case FT:
          case VT:
          case jT:
            T = Kd;
            break;
          case BT:
            T = y1;
            break;
          case "scroll":
            T = ym;
            break;
          case "wheel":
            T = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            T = f1;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            T = Cm;
            break;
        }
        var M = (m & ol) !== 0;
        {
          var U = !M && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          t === "scroll", V = LP(o, C, l.type, M, U);
          if (V.length > 0) {
            var Z = new T(C, D, null, l, f);
            e.push({
              event: Z,
              listeners: V
            });
          }
        }
      }
    }
    AP(), X(), ap(), kP(), Dg();
    function OP(e, t, o, l, f, m, g) {
      MP(e, t, o, l, f, m);
      var C = (m & ZS) === 0;
      C && (me(e, t, o, l, f), B(e, t, o, l, f), DP(e, t, o, l, f), rp(e, t, o, l, f));
    }
    var Dm = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], R1 = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Dm));
    function HT(e, t, o) {
      var l = e.type || "unknown-event";
      e.currentTarget = o, Po(l, t, void 0, e), e.currentTarget = null;
    }
    function zP(e, t, o) {
      var l;
      if (o)
        for (var f = t.length - 1; f >= 0; f--) {
          var m = t[f], g = m.instance, C = m.currentTarget, T = m.listener;
          if (g !== l && e.isPropagationStopped())
            return;
          HT(e, T, C), l = g;
        }
      else
        for (var D = 0; D < t.length; D++) {
          var M = t[D], U = M.instance, V = M.currentTarget, Z = M.listener;
          if (U !== l && e.isPropagationStopped())
            return;
          HT(e, Z, V), l = U;
        }
    }
    function WT(e, t) {
      for (var o = (t & ol) !== 0, l = 0; l < e.length; l++) {
        var f = e[l], m = f.event, g = f.listeners;
        zP(m, g, o);
      }
      Vh();
    }
    function PP(e, t, o, l, f) {
      var m = od(o), g = [];
      OP(g, e, l, o, m, t), WT(g, t);
    }
    function $n(e, t) {
      R1.has(e) || h('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var o = !1, l = cL(t), f = FP(e, o);
      l.has(f) || (YT(t, e, Dc, o), l.add(f));
    }
    function _1(e, t, o) {
      R1.has(e) && !t && h('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var l = 0;
      t && (l |= ol), YT(o, e, l, t);
    }
    var Lg = "_reactListening" + Math.random().toString(36).slice(2);
    function Am(e) {
      if (!e[Lg]) {
        e[Lg] = !0, Ot.forEach(function(o) {
          o !== "selectionchange" && (R1.has(o) || _1(o, !1, e), _1(o, !0, e));
        });
        var t = e.nodeType === Fi ? e : e.ownerDocument;
        t !== null && (t[Lg] || (t[Lg] = !0, _1("selectionchange", !1, t)));
      }
    }
    function YT(e, t, o, l, f) {
      var m = Mu(e, t, o), g = void 0;
      Pc && (t === "touchstart" || t === "touchmove" || t === "wheel") && (g = !0), e = e, l ? g !== void 0 ? Uo(e, t, m, g) : zu(e, t, m) : g !== void 0 ? Yd(e, t, m, g) : vm(e, t, m);
    }
    function GT(e, t) {
      return e === t || e.nodeType === Jn && e.parentNode === t;
    }
    function D1(e, t, o, l, f) {
      var m = l;
      if (!(t & Oo) && !(t & Dc)) {
        var g = f;
        if (l !== null) {
          var C = l;
          e:
            for (; ; ) {
              if (C === null)
                return;
              var T = C.tag;
              if (T === k || T === _) {
                var D = C.stateNode.containerInfo;
                if (GT(D, g))
                  break;
                if (T === _)
                  for (var M = C.return; M !== null; ) {
                    var U = M.tag;
                    if (U === k || U === _) {
                      var V = M.stateNode.containerInfo;
                      if (GT(V, g))
                        return;
                    }
                    M = M.return;
                  }
                for (; D !== null; ) {
                  var Z = lf(D);
                  if (Z === null)
                    return;
                  var J = Z.tag;
                  if (J === A || J === L) {
                    C = m = Z;
                    continue e;
                  }
                  D = D.parentNode;
                }
              }
              C = C.return;
            }
        }
      }
      Lh(function() {
        return PP(e, t, o, m);
      });
    }
    function Mm(e, t, o) {
      return {
        instance: e,
        listener: t,
        currentTarget: o
      };
    }
    function LP(e, t, o, l, f, m) {
      for (var g = t !== null ? t + "Capture" : null, C = l ? g : t, T = [], D = e, M = null; D !== null; ) {
        var U = D, V = U.stateNode, Z = U.tag;
        if (Z === A && V !== null && (M = V, C !== null)) {
          var J = ll(D, C);
          J != null && T.push(Mm(D, J, M));
        }
        if (f)
          break;
        D = D.return;
      }
      return T;
    }
    function $g(e, t) {
      for (var o = t + "Capture", l = [], f = e; f !== null; ) {
        var m = f, g = m.stateNode, C = m.tag;
        if (C === A && g !== null) {
          var T = g, D = ll(f, o);
          D != null && l.unshift(Mm(f, D, T));
          var M = ll(f, t);
          M != null && l.push(Mm(f, M, T));
        }
        f = f.return;
      }
      return l;
    }
    function sp(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== A);
      return e || null;
    }
    function $P(e, t) {
      for (var o = e, l = t, f = 0, m = o; m; m = sp(m))
        f++;
      for (var g = 0, C = l; C; C = sp(C))
        g++;
      for (; f - g > 0; )
        o = sp(o), f--;
      for (; g - f > 0; )
        l = sp(l), g--;
      for (var T = f; T--; ) {
        if (o === l || l !== null && o === l.alternate)
          return o;
        o = sp(o), l = sp(l);
      }
      return null;
    }
    function qT(e, t, o, l, f) {
      for (var m = t._reactName, g = [], C = o; C !== null && C !== l; ) {
        var T = C, D = T.alternate, M = T.stateNode, U = T.tag;
        if (D !== null && D === l)
          break;
        if (U === A && M !== null) {
          var V = M;
          if (f) {
            var Z = ll(C, m);
            Z != null && g.unshift(Mm(C, Z, V));
          } else if (!f) {
            var J = ll(C, m);
            J != null && g.push(Mm(C, J, V));
          }
        }
        C = C.return;
      }
      g.length !== 0 && e.push({
        event: t,
        listeners: g
      });
    }
    function NP(e, t, o, l, f) {
      var m = l && f ? $P(l, f) : null;
      l !== null && qT(e, t, l, m, !1), f !== null && o !== null && qT(e, o, f, m, !0);
    }
    function FP(e, t) {
      return e + "__" + (t ? "capture" : "bubble");
    }
    var Ci = !1, Om = "dangerouslySetInnerHTML", Ng = "suppressContentEditableWarning", ju = "suppressHydrationWarning", QT = "autoFocus", of = "children", sf = "style", Fg = "__html", A1, Vg, zm, KT, jg, XT, ZT;
    A1 = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Vg = function(e, t) {
      id(e, t), Ah(e, t), qy(e, t, {
        registrationNameDependencies: Bt,
        possibleRegistrationNames: gn
      });
    }, XT = kn && !document.documentMode, zm = function(e, t, o) {
      if (!Ci) {
        var l = Bg(o), f = Bg(t);
        f !== l && (Ci = !0, h("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(f), JSON.stringify(l)));
      }
    }, KT = function(e) {
      if (!Ci) {
        Ci = !0;
        var t = [];
        e.forEach(function(o) {
          t.push(o);
        }), h("Extra attributes from the server: %s", t);
      }
    }, jg = function(e, t) {
      t === !1 ? h("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : h("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof t);
    }, ZT = function(e, t) {
      var o = e.namespaceURI === Do ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return o.innerHTML = t, o.innerHTML;
    };
    var VP = /\r\n?/g, jP = /\u0000|\uFFFD/g;
    function Bg(e) {
      Br(e);
      var t = typeof e == "string" ? e : "" + e;
      return t.replace(VP, `
`).replace(jP, "");
    }
    function Ug(e, t, o, l) {
      var f = Bg(t), m = Bg(e);
      if (m !== f && (l && (Ci || (Ci = !0, h('Text content did not match. Server: "%s" Client: "%s"', m, f))), o && Lt))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function JT(e) {
      return e.nodeType === Fi ? e : e.ownerDocument;
    }
    function BP() {
    }
    function Ig(e) {
      e.onclick = BP;
    }
    function UP(e, t, o, l, f) {
      for (var m in l)
        if (l.hasOwnProperty(m)) {
          var g = l[m];
          if (m === sf)
            g && Object.freeze(g), Fy(t, g);
          else if (m === Om) {
            var C = g ? g[Fg] : void 0;
            C != null && Ry(t, C);
          } else if (m === of)
            if (typeof g == "string") {
              var T = e !== "textarea" || g !== "";
              T && td(t, g);
            } else
              typeof g == "number" && td(t, "" + g);
          else
            m === Ng || m === ju || m === QT || (Bt.hasOwnProperty(m) ? g != null && (typeof g != "function" && jg(m, g), m === "onScroll" && $n("scroll", t)) : g != null && si(t, m, g, f));
        }
    }
    function IP(e, t, o, l) {
      for (var f = 0; f < t.length; f += 2) {
        var m = t[f], g = t[f + 1];
        m === sf ? Fy(e, g) : m === Om ? Ry(e, g) : m === of ? td(e, g) : si(e, m, g, l);
      }
    }
    function HP(e, t, o, l) {
      var f, m = JT(o), g, C = l;
      if (C === Do && (C = Jf(e)), C === Do) {
        if (f = Mo(e, t), !f && e !== e.toLowerCase() && h("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var T = m.createElement("div");
          T.innerHTML = "<script><\/script>";
          var D = T.firstChild;
          g = T.removeChild(D);
        } else if (typeof t.is == "string")
          g = m.createElement(e, {
            is: t.is
          });
        else if (g = m.createElement(e), e === "select") {
          var M = g;
          t.multiple ? M.multiple = !0 : t.size && (M.size = t.size);
        }
      } else
        g = m.createElementNS(C, e);
      return C === Do && !f && Object.prototype.toString.call(g) === "[object HTMLUnknownElement]" && !Mn.call(A1, e) && (A1[e] = !0, h("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), g;
    }
    function WP(e, t) {
      return JT(t).createTextNode(e);
    }
    function YP(e, t, o, l) {
      var f = Mo(t, o);
      Vg(t, o);
      var m;
      switch (t) {
        case "dialog":
          $n("cancel", e), $n("close", e), m = o;
          break;
        case "iframe":
        case "object":
        case "embed":
          $n("load", e), m = o;
          break;
        case "video":
        case "audio":
          for (var g = 0; g < Dm.length; g++)
            $n(Dm[g], e);
          m = o;
          break;
        case "source":
          $n("error", e), m = o;
          break;
        case "img":
        case "image":
        case "link":
          $n("error", e), $n("load", e), m = o;
          break;
        case "details":
          $n("toggle", e), m = o;
          break;
        case "input":
          qt(e, o), m = yt(e, o), $n("invalid", e);
          break;
        case "option":
          Xf(e, o), m = o;
          break;
        case "select":
          Ey(e, o), m = bh(e, o), $n("invalid", e);
          break;
        case "textarea":
          wy(e, o), m = xh(e, o), $n("invalid", e);
          break;
        default:
          m = o;
      }
      switch (rd(t, m), UP(t, e, l, m, f), t) {
        case "input":
          _o(e), $i(e, o, !1);
          break;
        case "textarea":
          _o(e), ky(e);
          break;
        case "option":
          gh(e, o);
          break;
        case "select":
          BS(e, o);
          break;
        default:
          typeof m.onClick == "function" && Ig(e);
          break;
      }
    }
    function GP(e, t, o, l, f) {
      Vg(t, l);
      var m = null, g, C;
      switch (t) {
        case "input":
          g = yt(e, o), C = yt(e, l), m = [];
          break;
        case "select":
          g = bh(e, o), C = bh(e, l), m = [];
          break;
        case "textarea":
          g = xh(e, o), C = xh(e, l), m = [];
          break;
        default:
          g = o, C = l, typeof g.onClick != "function" && typeof C.onClick == "function" && Ig(e);
          break;
      }
      rd(t, C);
      var T, D, M = null;
      for (T in g)
        if (!(C.hasOwnProperty(T) || !g.hasOwnProperty(T) || g[T] == null))
          if (T === sf) {
            var U = g[T];
            for (D in U)
              U.hasOwnProperty(D) && (M || (M = {}), M[D] = "");
          } else
            T === Om || T === of || T === Ng || T === ju || T === QT || (Bt.hasOwnProperty(T) ? m || (m = []) : (m = m || []).push(T, null));
      for (T in C) {
        var V = C[T], Z = g != null ? g[T] : void 0;
        if (!(!C.hasOwnProperty(T) || V === Z || V == null && Z == null))
          if (T === sf)
            if (V && Object.freeze(V), Z) {
              for (D in Z)
                Z.hasOwnProperty(D) && (!V || !V.hasOwnProperty(D)) && (M || (M = {}), M[D] = "");
              for (D in V)
                V.hasOwnProperty(D) && Z[D] !== V[D] && (M || (M = {}), M[D] = V[D]);
            } else
              M || (m || (m = []), m.push(T, M)), M = V;
          else if (T === Om) {
            var J = V ? V[Fg] : void 0, ae = Z ? Z[Fg] : void 0;
            J != null && ae !== J && (m = m || []).push(T, J);
          } else
            T === of ? (typeof V == "string" || typeof V == "number") && (m = m || []).push(T, "" + V) : T === Ng || T === ju || (Bt.hasOwnProperty(T) ? (V != null && (typeof V != "function" && jg(T, V), T === "onScroll" && $n("scroll", e)), !m && Z !== V && (m = [])) : (m = m || []).push(T, V));
      }
      return M && (Rc(M, C[sf]), (m = m || []).push(sf, M)), m;
    }
    function qP(e, t, o, l, f) {
      o === "input" && f.type === "radio" && f.name != null && Yr(e, f);
      var m = Mo(o, l), g = Mo(o, f);
      switch (IP(e, t, m, g), o) {
        case "input":
          Zn(e, f);
          break;
        case "textarea":
          Ty(e, f);
          break;
        case "select":
          US(e, f);
          break;
      }
    }
    function QP(e) {
      {
        var t = e.toLowerCase();
        return ad.hasOwnProperty(t) && ad[t] || null;
      }
    }
    function KP(e, t, o, l, f, m, g) {
      var C, T;
      switch (C = Mo(t, o), Vg(t, o), t) {
        case "dialog":
          $n("cancel", e), $n("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          $n("load", e);
          break;
        case "video":
        case "audio":
          for (var D = 0; D < Dm.length; D++)
            $n(Dm[D], e);
          break;
        case "source":
          $n("error", e);
          break;
        case "img":
        case "image":
        case "link":
          $n("error", e), $n("load", e);
          break;
        case "details":
          $n("toggle", e);
          break;
        case "input":
          qt(e, o), $n("invalid", e);
          break;
        case "option":
          Xf(e, o);
          break;
        case "select":
          Ey(e, o), $n("invalid", e);
          break;
        case "textarea":
          wy(e, o), $n("invalid", e);
          break;
      }
      rd(t, o);
      {
        T = /* @__PURE__ */ new Set();
        for (var M = e.attributes, U = 0; U < M.length; U++) {
          var V = M[U].name.toLowerCase();
          switch (V) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              T.add(M[U].name);
          }
        }
      }
      var Z = null;
      for (var J in o)
        if (o.hasOwnProperty(J)) {
          var ae = o[J];
          if (J === of)
            typeof ae == "string" ? e.textContent !== ae && (o[ju] !== !0 && Ug(e.textContent, ae, m, g), Z = [of, ae]) : typeof ae == "number" && e.textContent !== "" + ae && (o[ju] !== !0 && Ug(e.textContent, ae, m, g), Z = [of, "" + ae]);
          else if (Bt.hasOwnProperty(J))
            ae != null && (typeof ae != "function" && jg(J, ae), J === "onScroll" && $n("scroll", e));
          else if (g && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof C == "boolean") {
            var Re = void 0, qe = C && Ke ? null : ta(J);
            if (o[ju] !== !0) {
              if (!(J === Ng || J === ju || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              J === "value" || J === "checked" || J === "selected")) {
                if (J === Om) {
                  var je = e.innerHTML, At = ae ? ae[Fg] : void 0;
                  if (At != null) {
                    var Tt = ZT(e, At);
                    Tt !== je && zm(J, je, Tt);
                  }
                } else if (J === sf) {
                  if (T.delete(J), XT) {
                    var q = KS(ae);
                    Re = e.getAttribute("style"), q !== Re && zm(J, Re, q);
                  }
                } else if (C && !Ke)
                  T.delete(J.toLowerCase()), Re = cs(e, J, ae), ae !== Re && zm(J, Re, ae);
                else if (!hn(J, qe, C) && !Xt(J, ae, qe, C)) {
                  var ie = !1;
                  if (qe !== null)
                    T.delete(qe.attributeName), Re = kr(e, J, ae, qe);
                  else {
                    var Q = l;
                    if (Q === Do && (Q = Jf(t)), Q === Do)
                      T.delete(J.toLowerCase());
                    else {
                      var pe = QP(J);
                      pe !== null && pe !== J && (ie = !0, T.delete(pe)), T.delete(J);
                    }
                    Re = cs(e, J, ae);
                  }
                  var _e = Ke;
                  !_e && ae !== Re && !ie && zm(J, Re, ae);
                }
              }
            }
          }
        }
      switch (g && // $FlowFixMe - Should be inferred as not undefined.
      T.size > 0 && o[ju] !== !0 && KT(T), t) {
        case "input":
          _o(e), $i(e, o, !0);
          break;
        case "textarea":
          _o(e), ky(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof o.onClick == "function" && Ig(e);
          break;
      }
      return Z;
    }
    function XP(e, t, o) {
      var l = e.nodeValue !== t;
      return l;
    }
    function M1(e, t) {
      {
        if (Ci)
          return;
        Ci = !0, h("Did not expect server HTML to contain a <%s> in <%s>.", t.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function O1(e, t) {
      {
        if (Ci)
          return;
        Ci = !0, h('Did not expect server HTML to contain the text node "%s" in <%s>.', t.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function z1(e, t, o) {
      {
        if (Ci)
          return;
        Ci = !0, h("Expected server HTML to contain a matching <%s> in <%s>.", t, e.nodeName.toLowerCase());
      }
    }
    function P1(e, t) {
      {
        if (t === "" || Ci)
          return;
        Ci = !0, h('Expected server HTML to contain a matching text node for "%s" in <%s>.', t, e.nodeName.toLowerCase());
      }
    }
    function ZP(e, t, o) {
      switch (t) {
        case "input":
          lu(e, o);
          return;
        case "textarea":
          Ch(e, o);
          return;
        case "select":
          IS(e, o);
          return;
      }
    }
    var Pm = function() {
    }, Lm = function() {
    };
    {
      var JP = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], ek = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], e5 = ek.concat(["button"]), t5 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], tk = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Lm = function(e, t) {
        var o = mt({}, e || tk), l = {
          tag: t
        };
        return ek.indexOf(t) !== -1 && (o.aTagInScope = null, o.buttonTagInScope = null, o.nobrTagInScope = null), e5.indexOf(t) !== -1 && (o.pTagInButtonScope = null), JP.indexOf(t) !== -1 && t !== "address" && t !== "div" && t !== "p" && (o.listItemTagAutoclosing = null, o.dlItemTagAutoclosing = null), o.current = l, t === "form" && (o.formTag = l), t === "a" && (o.aTagInScope = l), t === "button" && (o.buttonTagInScope = l), t === "nobr" && (o.nobrTagInScope = l), t === "p" && (o.pTagInButtonScope = l), t === "li" && (o.listItemTagAutoclosing = l), (t === "dd" || t === "dt") && (o.dlItemTagAutoclosing = l), o;
      };
      var n5 = function(e, t) {
        switch (t) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6";
          case "rp":
          case "rt":
            return t5.indexOf(t) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return t == null;
        }
        return !0;
      }, r5 = function(e, t) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t.pTagInButtonScope;
          case "form":
            return t.formTag || t.pTagInButtonScope;
          case "li":
            return t.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return t.dlItemTagAutoclosing;
          case "button":
            return t.buttonTagInScope;
          case "a":
            return t.aTagInScope;
          case "nobr":
            return t.nobrTagInScope;
        }
        return null;
      }, nk = {};
      Pm = function(e, t, o) {
        o = o || tk;
        var l = o.current, f = l && l.tag;
        t != null && (e != null && h("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var m = n5(e, f) ? null : l, g = m ? null : r5(e, o), C = m || g;
        if (C) {
          var T = C.tag, D = !!m + "|" + e + "|" + T;
          if (!nk[D]) {
            nk[D] = !0;
            var M = e, U = "";
            if (e === "#text" ? /\S/.test(t) ? M = "Text nodes" : (M = "Whitespace text nodes", U = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : M = "<" + e + ">", m) {
              var V = "";
              T === "table" && e === "tr" && (V += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), h("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", M, T, U, V);
            } else
              h("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", M, T);
          }
        }
      };
    }
    var Hg = "suppressHydrationWarning", Wg = "$", Yg = "/$", $m = "$?", Nm = "$!", a5 = "style", L1 = null, $1 = null;
    function i5(e) {
      var t, o, l = e.nodeType;
      switch (l) {
        case Fi:
        case al: {
          t = l === Fi ? "#document" : "#fragment";
          var f = e.documentElement;
          o = f ? f.namespaceURI : wh(null, "");
          break;
        }
        default: {
          var m = l === Jn ? e.parentNode : e, g = m.namespaceURI || null;
          t = m.tagName, o = wh(g, t);
          break;
        }
      }
      {
        var C = t.toLowerCase(), T = Lm(null, C);
        return {
          namespace: o,
          ancestorInfo: T
        };
      }
    }
    function o5(e, t, o) {
      {
        var l = e, f = wh(l.namespace, t), m = Lm(l.ancestorInfo, t);
        return {
          namespace: f,
          ancestorInfo: m
        };
      }
    }
    function eQ(e) {
      return e;
    }
    function s5(e) {
      L1 = Za(), $1 = xP();
      var t = null;
      return xr(!1), t;
    }
    function l5(e) {
      CP($1), xr(L1), L1 = null, $1 = null;
    }
    function u5(e, t, o, l, f) {
      var m;
      {
        var g = l;
        if (Pm(e, null, g.ancestorInfo), typeof t.children == "string" || typeof t.children == "number") {
          var C = "" + t.children, T = Lm(g.ancestorInfo, e);
          Pm(null, C, T);
        }
        m = g.namespace;
      }
      var D = HP(e, t, o, m);
      return jm(f, D), H1(D, t), D;
    }
    function c5(e, t) {
      e.appendChild(t);
    }
    function f5(e, t, o, l, f) {
      switch (YP(e, t, o, l), t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!o.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function d5(e, t, o, l, f, m) {
      {
        var g = m;
        if (typeof l.children != typeof o.children && (typeof l.children == "string" || typeof l.children == "number")) {
          var C = "" + l.children, T = Lm(g.ancestorInfo, t);
          Pm(null, C, T);
        }
      }
      return GP(e, t, o, l);
    }
    function N1(e, t) {
      return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
    }
    function p5(e, t, o, l) {
      {
        var f = o;
        Pm(null, e, f.ancestorInfo);
      }
      var m = WP(e, t);
      return jm(l, m), m;
    }
    function h5() {
      var e = window.event;
      return e === void 0 ? Vo : ia(e.type);
    }
    var F1 = typeof setTimeout == "function" ? setTimeout : void 0, m5 = typeof clearTimeout == "function" ? clearTimeout : void 0, V1 = -1, rk = typeof Promise == "function" ? Promise : void 0, v5 = typeof queueMicrotask == "function" ? queueMicrotask : typeof rk < "u" ? function(e) {
      return rk.resolve(null).then(e).catch(y5);
    } : F1;
    function y5(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function g5(e, t, o, l) {
      switch (t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          o.autoFocus && e.focus();
          return;
        case "img": {
          o.src && (e.src = o.src);
          return;
        }
      }
    }
    function b5(e, t, o, l, f, m) {
      qP(e, t, o, l, f), H1(e, f);
    }
    function ak(e) {
      td(e, "");
    }
    function S5(e, t, o) {
      e.nodeValue = o;
    }
    function x5(e, t) {
      e.appendChild(t);
    }
    function C5(e, t) {
      var o;
      e.nodeType === Jn ? (o = e.parentNode, o.insertBefore(t, e)) : (o = e, o.appendChild(t));
      var l = e._reactRootContainer;
      l == null && o.onclick === null && Ig(o);
    }
    function E5(e, t, o) {
      e.insertBefore(t, o);
    }
    function w5(e, t, o) {
      e.nodeType === Jn ? e.parentNode.insertBefore(t, o) : e.insertBefore(t, o);
    }
    function T5(e, t) {
      e.removeChild(t);
    }
    function k5(e, t) {
      e.nodeType === Jn ? e.parentNode.removeChild(t) : e.removeChild(t);
    }
    function j1(e, t) {
      var o = t, l = 0;
      do {
        var f = o.nextSibling;
        if (e.removeChild(o), f && f.nodeType === Jn) {
          var m = f.data;
          if (m === Yg)
            if (l === 0) {
              e.removeChild(f), wt(t);
              return;
            } else
              l--;
          else
            (m === Wg || m === $m || m === Nm) && l++;
        }
        o = f;
      } while (o);
      wt(t);
    }
    function R5(e, t) {
      e.nodeType === Jn ? j1(e.parentNode, t) : e.nodeType === Ra && j1(e, t), wt(e);
    }
    function _5(e) {
      e = e;
      var t = e.style;
      typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function D5(e) {
      e.nodeValue = "";
    }
    function A5(e, t) {
      e = e;
      var o = t[a5], l = o != null && o.hasOwnProperty("display") ? o.display : null;
      e.style.display = nd("display", l);
    }
    function M5(e, t) {
      e.nodeValue = t;
    }
    function O5(e) {
      e.nodeType === Ra ? e.textContent = "" : e.nodeType === Fi && e.documentElement && e.removeChild(e.documentElement);
    }
    function z5(e, t, o) {
      return e.nodeType !== Ra || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function P5(e, t) {
      return t === "" || e.nodeType !== Ao ? null : e;
    }
    function L5(e) {
      return e.nodeType !== Jn ? null : e;
    }
    function ik(e) {
      return e.data === $m;
    }
    function B1(e) {
      return e.data === Nm;
    }
    function $5(e) {
      var t = e.nextSibling && e.nextSibling.dataset, o, l, f;
      return t && (o = t.dgst, l = t.msg, f = t.stck), {
        message: l,
        digest: o,
        stack: f
      };
    }
    function N5(e, t) {
      e._reactRetry = t;
    }
    function Gg(e) {
      for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === Ra || t === Ao)
          break;
        if (t === Jn) {
          var o = e.data;
          if (o === Wg || o === Nm || o === $m)
            break;
          if (o === Yg)
            return null;
        }
      }
      return e;
    }
    function Fm(e) {
      return Gg(e.nextSibling);
    }
    function F5(e) {
      return Gg(e.firstChild);
    }
    function V5(e) {
      return Gg(e.firstChild);
    }
    function j5(e) {
      return Gg(e.nextSibling);
    }
    function B5(e, t, o, l, f, m, g) {
      jm(m, e), H1(e, o);
      var C;
      {
        var T = f;
        C = T.namespace;
      }
      var D = (m.mode & xt) !== Qe;
      return KP(e, t, o, C, l, D, g);
    }
    function U5(e, t, o, l) {
      return jm(o, e), o.mode & xt, XP(e, t);
    }
    function I5(e, t) {
      jm(t, e);
    }
    function H5(e) {
      for (var t = e.nextSibling, o = 0; t; ) {
        if (t.nodeType === Jn) {
          var l = t.data;
          if (l === Yg) {
            if (o === 0)
              return Fm(t);
            o--;
          } else
            (l === Wg || l === Nm || l === $m) && o++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function ok(e) {
      for (var t = e.previousSibling, o = 0; t; ) {
        if (t.nodeType === Jn) {
          var l = t.data;
          if (l === Wg || l === Nm || l === $m) {
            if (o === 0)
              return t;
            o--;
          } else
            l === Yg && o++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function W5(e) {
      wt(e);
    }
    function Y5(e) {
      wt(e);
    }
    function G5(e) {
      return e !== "head" && e !== "body";
    }
    function q5(e, t, o, l) {
      var f = !0;
      Ug(t.nodeValue, o, l, f);
    }
    function Q5(e, t, o, l, f, m) {
      if (t[Hg] !== !0) {
        var g = !0;
        Ug(l.nodeValue, f, m, g);
      }
    }
    function K5(e, t) {
      t.nodeType === Ra ? M1(e, t) : t.nodeType === Jn || O1(e, t);
    }
    function X5(e, t) {
      {
        var o = e.parentNode;
        o !== null && (t.nodeType === Ra ? M1(o, t) : t.nodeType === Jn || O1(o, t));
      }
    }
    function Z5(e, t, o, l, f) {
      (f || t[Hg] !== !0) && (l.nodeType === Ra ? M1(o, l) : l.nodeType === Jn || O1(o, l));
    }
    function J5(e, t, o) {
      z1(e, t);
    }
    function eL(e, t) {
      P1(e, t);
    }
    function tL(e, t, o) {
      {
        var l = e.parentNode;
        l !== null && z1(l, t);
      }
    }
    function nL(e, t) {
      {
        var o = e.parentNode;
        o !== null && P1(o, t);
      }
    }
    function rL(e, t, o, l, f, m) {
      (m || t[Hg] !== !0) && z1(o, l);
    }
    function aL(e, t, o, l, f) {
      (f || t[Hg] !== !0) && P1(o, l);
    }
    function iL(e) {
      h("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function oL(e) {
      Am(e);
    }
    var lp = Math.random().toString(36).slice(2), up = "__reactFiber$" + lp, U1 = "__reactProps$" + lp, Vm = "__reactContainer$" + lp, I1 = "__reactEvents$" + lp, sL = "__reactListeners$" + lp, lL = "__reactHandles$" + lp;
    function uL(e) {
      delete e[up], delete e[U1], delete e[I1], delete e[sL], delete e[lL];
    }
    function jm(e, t) {
      t[up] = e;
    }
    function qg(e, t) {
      t[Vm] = e;
    }
    function sk(e) {
      e[Vm] = null;
    }
    function Bm(e) {
      return !!e[Vm];
    }
    function lf(e) {
      var t = e[up];
      if (t)
        return t;
      for (var o = e.parentNode; o; ) {
        if (t = o[Vm] || o[up], t) {
          var l = t.alternate;
          if (t.child !== null || l !== null && l.child !== null)
            for (var f = ok(e); f !== null; ) {
              var m = f[up];
              if (m)
                return m;
              f = ok(f);
            }
          return t;
        }
        e = o, o = e.parentNode;
      }
      return null;
    }
    function Bu(e) {
      var t = e[up] || e[Vm];
      return t && (t.tag === A || t.tag === L || t.tag === H || t.tag === k) ? t : null;
    }
    function cp(e) {
      if (e.tag === A || e.tag === L)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Qg(e) {
      return e[U1] || null;
    }
    function H1(e, t) {
      e[U1] = t;
    }
    function cL(e) {
      var t = e[I1];
      return t === void 0 && (t = e[I1] = /* @__PURE__ */ new Set()), t;
    }
    var lk = {}, uk = s.ReactDebugCurrentFrame;
    function Kg(e) {
      if (e) {
        var t = e._owner, o = el(e.type, e._source, t ? t.type : null);
        uk.setExtraStackFrame(o);
      } else
        uk.setExtraStackFrame(null);
    }
    function Ho(e, t, o, l, f) {
      {
        var m = Function.call.bind(Mn);
        for (var g in e)
          if (m(e, g)) {
            var C = void 0;
            try {
              if (typeof e[g] != "function") {
                var T = Error((l || "React class") + ": " + o + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw T.name = "Invariant Violation", T;
              }
              C = e[g](t, g, l, o, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (D) {
              C = D;
            }
            C && !(C instanceof Error) && (Kg(f), h("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", l || "React class", o, g, typeof C), Kg(null)), C instanceof Error && !(C.message in lk) && (lk[C.message] = !0, Kg(f), h("Failed %s type: %s", o, C.message), Kg(null));
          }
      }
    }
    var W1 = [], Xg;
    Xg = [];
    var Ol = -1;
    function Uu(e) {
      return {
        current: e
      };
    }
    function $a(e, t) {
      if (Ol < 0) {
        h("Unexpected pop.");
        return;
      }
      t !== Xg[Ol] && h("Unexpected Fiber popped."), e.current = W1[Ol], W1[Ol] = null, Xg[Ol] = null, Ol--;
    }
    function Na(e, t, o) {
      Ol++, W1[Ol] = e.current, Xg[Ol] = o, e.current = t;
    }
    var Y1;
    Y1 = {};
    var Ii = {};
    Object.freeze(Ii);
    var zl = Uu(Ii), zs = Uu(!1), G1 = Ii;
    function fp(e, t, o) {
      return o && Ps(t) ? G1 : zl.current;
    }
    function ck(e, t, o) {
      {
        var l = e.stateNode;
        l.__reactInternalMemoizedUnmaskedChildContext = t, l.__reactInternalMemoizedMaskedChildContext = o;
      }
    }
    function dp(e, t) {
      {
        var o = e.type, l = o.contextTypes;
        if (!l)
          return Ii;
        var f = e.stateNode;
        if (f && f.__reactInternalMemoizedUnmaskedChildContext === t)
          return f.__reactInternalMemoizedMaskedChildContext;
        var m = {};
        for (var g in l)
          m[g] = t[g];
        {
          var C = st(e) || "Unknown";
          Ho(l, m, "context", C);
        }
        return f && ck(e, t, m), m;
      }
    }
    function Zg() {
      return zs.current;
    }
    function Ps(e) {
      {
        var t = e.childContextTypes;
        return t != null;
      }
    }
    function Jg(e) {
      $a(zs, e), $a(zl, e);
    }
    function q1(e) {
      $a(zs, e), $a(zl, e);
    }
    function fk(e, t, o) {
      {
        if (zl.current !== Ii)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Na(zl, t, e), Na(zs, o, e);
      }
    }
    function dk(e, t, o) {
      {
        var l = e.stateNode, f = t.childContextTypes;
        if (typeof l.getChildContext != "function") {
          {
            var m = st(e) || "Unknown";
            Y1[m] || (Y1[m] = !0, h("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", m, m));
          }
          return o;
        }
        var g = l.getChildContext();
        for (var C in g)
          if (!(C in f))
            throw new Error((st(e) || "Unknown") + '.getChildContext(): key "' + C + '" is not defined in childContextTypes.');
        {
          var T = st(e) || "Unknown";
          Ho(f, g, "child context", T);
        }
        return mt({}, o, g);
      }
    }
    function e0(e) {
      {
        var t = e.stateNode, o = t && t.__reactInternalMemoizedMergedChildContext || Ii;
        return G1 = zl.current, Na(zl, o, e), Na(zs, zs.current, e), !0;
      }
    }
    function pk(e, t, o) {
      {
        var l = e.stateNode;
        if (!l)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (o) {
          var f = dk(e, t, G1);
          l.__reactInternalMemoizedMergedChildContext = f, $a(zs, e), $a(zl, e), Na(zl, f, e), Na(zs, o, e);
        } else
          $a(zs, e), Na(zs, o, e);
      }
    }
    function fL(e) {
      {
        if (!Hh(e) || e.tag !== E)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var t = e;
        do {
          switch (t.tag) {
            case k:
              return t.stateNode.context;
            case E: {
              var o = t.type;
              if (Ps(o))
                return t.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          t = t.return;
        } while (t !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Iu = 0, t0 = 1, Pl = null, Q1 = !1, K1 = !1;
    function hk(e) {
      Pl === null ? Pl = [e] : Pl.push(e);
    }
    function dL(e) {
      Q1 = !0, hk(e);
    }
    function mk() {
      Q1 && Hu();
    }
    function Hu() {
      if (!K1 && Pl !== null) {
        K1 = !0;
        var e = 0, t = gi();
        try {
          var o = !0, l = Pl;
          for (sr(qr); e < l.length; e++) {
            var f = l[e];
            do
              f = f(o);
            while (f !== null);
          }
          Pl = null, Q1 = !1;
        } catch (m) {
          throw Pl !== null && (Pl = Pl.slice(e + 1)), pd(md, Hu), m;
        } finally {
          sr(t), K1 = !1;
        }
      }
      return null;
    }
    var pp = [], hp = 0, n0 = null, r0 = 0, so = [], lo = 0, uf = null, Ll = 1, $l = "";
    function pL(e) {
      return ff(), (e.flags & Bh) !== We;
    }
    function hL(e) {
      return ff(), r0;
    }
    function mL() {
      var e = $l, t = Ll, o = t & ~vL(t);
      return o.toString(32) + e;
    }
    function cf(e, t) {
      ff(), pp[hp++] = r0, pp[hp++] = n0, n0 = e, r0 = t;
    }
    function vk(e, t, o) {
      ff(), so[lo++] = Ll, so[lo++] = $l, so[lo++] = uf, uf = e;
      var l = Ll, f = $l, m = a0(l) - 1, g = l & ~(1 << m), C = o + 1, T = a0(t) + m;
      if (T > 30) {
        var D = m - m % 5, M = (1 << D) - 1, U = (g & M).toString(32), V = g >> D, Z = m - D, J = a0(t) + Z, ae = C << Z, Re = ae | V, qe = U + f;
        Ll = 1 << J | Re, $l = qe;
      } else {
        var je = C << m, At = je | g, Tt = f;
        Ll = 1 << T | At, $l = Tt;
      }
    }
    function X1(e) {
      ff();
      var t = e.return;
      if (t !== null) {
        var o = 1, l = 0;
        cf(e, o), vk(e, o, l);
      }
    }
    function a0(e) {
      return 32 - xd(e);
    }
    function vL(e) {
      return 1 << a0(e) - 1;
    }
    function Z1(e) {
      for (; e === n0; )
        n0 = pp[--hp], pp[hp] = null, r0 = pp[--hp], pp[hp] = null;
      for (; e === uf; )
        uf = so[--lo], so[lo] = null, $l = so[--lo], so[lo] = null, Ll = so[--lo], so[lo] = null;
    }
    function yL() {
      return ff(), uf !== null ? {
        id: Ll,
        overflow: $l
      } : null;
    }
    function gL(e, t) {
      ff(), so[lo++] = Ll, so[lo++] = $l, so[lo++] = uf, Ll = t.id, $l = t.overflow, uf = e;
    }
    function ff() {
      sa() || h("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var oa = null, uo = null, Wo = !1, df = !1, Wu = null;
    function bL() {
      Wo && h("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function yk() {
      df = !0;
    }
    function SL() {
      return df;
    }
    function xL(e) {
      var t = e.stateNode.containerInfo;
      return uo = V5(t), oa = e, Wo = !0, Wu = null, df = !1, !0;
    }
    function CL(e, t, o) {
      return uo = j5(t), oa = e, Wo = !0, Wu = null, df = !1, o !== null && gL(e, o), !0;
    }
    function gk(e, t) {
      switch (e.tag) {
        case k: {
          K5(e.stateNode.containerInfo, t);
          break;
        }
        case A: {
          var o = (e.mode & xt) !== Qe;
          Z5(
            e.type,
            e.memoizedProps,
            e.stateNode,
            t,
            // TODO: Delete this argument when we remove the legacy root API.
            o
          );
          break;
        }
        case H: {
          var l = e.memoizedState;
          l.dehydrated !== null && X5(l.dehydrated, t);
          break;
        }
      }
    }
    function bk(e, t) {
      gk(e, t);
      var o = T3();
      o.stateNode = t, o.return = e;
      var l = e.deletions;
      l === null ? (e.deletions = [o], e.flags |= Yt) : l.push(o);
    }
    function J1(e, t) {
      {
        if (df)
          return;
        switch (e.tag) {
          case k: {
            var o = e.stateNode.containerInfo;
            switch (t.tag) {
              case A:
                var l = t.type;
                t.pendingProps, J5(o, l);
                break;
              case L:
                var f = t.pendingProps;
                eL(o, f);
                break;
            }
            break;
          }
          case A: {
            var m = e.type, g = e.memoizedProps, C = e.stateNode;
            switch (t.tag) {
              case A: {
                var T = t.type, D = t.pendingProps, M = (e.mode & xt) !== Qe;
                rL(
                  m,
                  g,
                  C,
                  T,
                  D,
                  // TODO: Delete this argument when we remove the legacy root API.
                  M
                );
                break;
              }
              case L: {
                var U = t.pendingProps, V = (e.mode & xt) !== Qe;
                aL(
                  m,
                  g,
                  C,
                  U,
                  // TODO: Delete this argument when we remove the legacy root API.
                  V
                );
                break;
              }
            }
            break;
          }
          case H: {
            var Z = e.memoizedState, J = Z.dehydrated;
            if (J !== null)
              switch (t.tag) {
                case A:
                  var ae = t.type;
                  t.pendingProps, tL(J, ae);
                  break;
                case L:
                  var Re = t.pendingProps;
                  nL(J, Re);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function Sk(e, t) {
      t.flags = t.flags & ~di | xn, J1(e, t);
    }
    function xk(e, t) {
      switch (e.tag) {
        case A: {
          var o = e.type;
          e.pendingProps;
          var l = z5(t, o);
          return l !== null ? (e.stateNode = l, oa = e, uo = F5(l), !0) : !1;
        }
        case L: {
          var f = e.pendingProps, m = P5(t, f);
          return m !== null ? (e.stateNode = m, oa = e, uo = null, !0) : !1;
        }
        case H: {
          var g = L5(t);
          if (g !== null) {
            var C = {
              dehydrated: g,
              treeContext: yL(),
              retryLane: Pa
            };
            e.memoizedState = C;
            var T = k3(g);
            return T.return = e, e.child = T, oa = e, uo = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function ex(e) {
      return (e.mode & xt) !== Qe && (e.flags & rt) === We;
    }
    function tx(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function nx(e) {
      if (Wo) {
        var t = uo;
        if (!t) {
          ex(e) && (J1(oa, e), tx()), Sk(oa, e), Wo = !1, oa = e;
          return;
        }
        var o = t;
        if (!xk(e, t)) {
          ex(e) && (J1(oa, e), tx()), t = Fm(o);
          var l = oa;
          if (!t || !xk(e, t)) {
            Sk(oa, e), Wo = !1, oa = e;
            return;
          }
          bk(l, o);
        }
      }
    }
    function EL(e, t, o) {
      var l = e.stateNode, f = !df, m = B5(l, e.type, e.memoizedProps, t, o, e, f);
      return e.updateQueue = m, m !== null;
    }
    function wL(e) {
      var t = e.stateNode, o = e.memoizedProps, l = U5(t, o, e);
      if (l) {
        var f = oa;
        if (f !== null)
          switch (f.tag) {
            case k: {
              var m = f.stateNode.containerInfo, g = (f.mode & xt) !== Qe;
              q5(
                m,
                t,
                o,
                // TODO: Delete this argument when we remove the legacy root API.
                g
              );
              break;
            }
            case A: {
              var C = f.type, T = f.memoizedProps, D = f.stateNode, M = (f.mode & xt) !== Qe;
              Q5(
                C,
                T,
                D,
                t,
                o,
                // TODO: Delete this argument when we remove the legacy root API.
                M
              );
              break;
            }
          }
      }
      return l;
    }
    function TL(e) {
      var t = e.memoizedState, o = t !== null ? t.dehydrated : null;
      if (!o)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      I5(o, e);
    }
    function kL(e) {
      var t = e.memoizedState, o = t !== null ? t.dehydrated : null;
      if (!o)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return H5(o);
    }
    function Ck(e) {
      for (var t = e.return; t !== null && t.tag !== A && t.tag !== k && t.tag !== H; )
        t = t.return;
      oa = t;
    }
    function i0(e) {
      if (e !== oa)
        return !1;
      if (!Wo)
        return Ck(e), Wo = !0, !1;
      if (e.tag !== k && (e.tag !== A || G5(e.type) && !N1(e.type, e.memoizedProps))) {
        var t = uo;
        if (t)
          if (ex(e))
            Ek(e), tx();
          else
            for (; t; )
              bk(e, t), t = Fm(t);
      }
      return Ck(e), e.tag === H ? uo = kL(e) : uo = oa ? Fm(e.stateNode) : null, !0;
    }
    function RL() {
      return Wo && uo !== null;
    }
    function Ek(e) {
      for (var t = uo; t; )
        gk(e, t), t = Fm(t);
    }
    function mp() {
      oa = null, uo = null, Wo = !1, df = !1;
    }
    function wk() {
      Wu !== null && (g_(Wu), Wu = null);
    }
    function sa() {
      return Wo;
    }
    function rx(e) {
      Wu === null ? Wu = [e] : Wu.push(e);
    }
    var _L = s.ReactCurrentBatchConfig, DL = null;
    function AL() {
      return _L.transition;
    }
    var Yo = {
      recordUnsafeLifecycleWarnings: function(e, t) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, t) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var ML = function(e) {
        for (var t = null, o = e; o !== null; )
          o.mode & Pn && (t = o), o = o.return;
        return t;
      }, pf = function(e) {
        var t = [];
        return e.forEach(function(o) {
          t.push(o);
        }), t.sort().join(", ");
      }, Um = [], Im = [], Hm = [], Wm = [], Ym = [], Gm = [], hf = /* @__PURE__ */ new Set();
      Yo.recordUnsafeLifecycleWarnings = function(e, t) {
        hf.has(e.type) || (typeof t.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        t.componentWillMount.__suppressDeprecationWarning !== !0 && Um.push(e), e.mode & Pn && typeof t.UNSAFE_componentWillMount == "function" && Im.push(e), typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Hm.push(e), e.mode & Pn && typeof t.UNSAFE_componentWillReceiveProps == "function" && Wm.push(e), typeof t.componentWillUpdate == "function" && t.componentWillUpdate.__suppressDeprecationWarning !== !0 && Ym.push(e), e.mode & Pn && typeof t.UNSAFE_componentWillUpdate == "function" && Gm.push(e));
      }, Yo.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        Um.length > 0 && (Um.forEach(function(V) {
          e.add(st(V) || "Component"), hf.add(V.type);
        }), Um = []);
        var t = /* @__PURE__ */ new Set();
        Im.length > 0 && (Im.forEach(function(V) {
          t.add(st(V) || "Component"), hf.add(V.type);
        }), Im = []);
        var o = /* @__PURE__ */ new Set();
        Hm.length > 0 && (Hm.forEach(function(V) {
          o.add(st(V) || "Component"), hf.add(V.type);
        }), Hm = []);
        var l = /* @__PURE__ */ new Set();
        Wm.length > 0 && (Wm.forEach(function(V) {
          l.add(st(V) || "Component"), hf.add(V.type);
        }), Wm = []);
        var f = /* @__PURE__ */ new Set();
        Ym.length > 0 && (Ym.forEach(function(V) {
          f.add(st(V) || "Component"), hf.add(V.type);
        }), Ym = []);
        var m = /* @__PURE__ */ new Set();
        if (Gm.length > 0 && (Gm.forEach(function(V) {
          m.add(st(V) || "Component"), hf.add(V.type);
        }), Gm = []), t.size > 0) {
          var g = pf(t);
          h(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, g);
        }
        if (l.size > 0) {
          var C = pf(l);
          h(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, C);
        }
        if (m.size > 0) {
          var T = pf(m);
          h(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, T);
        }
        if (e.size > 0) {
          var D = pf(e);
          v(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, D);
        }
        if (o.size > 0) {
          var M = pf(o);
          v(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, M);
        }
        if (f.size > 0) {
          var U = pf(f);
          v(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, U);
        }
      };
      var o0 = /* @__PURE__ */ new Map(), Tk = /* @__PURE__ */ new Set();
      Yo.recordLegacyContextWarning = function(e, t) {
        var o = ML(e);
        if (o === null) {
          h("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Tk.has(e.type)) {
          var l = o0.get(o);
          (e.type.contextTypes != null || e.type.childContextTypes != null || t !== null && typeof t.getChildContext == "function") && (l === void 0 && (l = [], o0.set(o, l)), l.push(e));
        }
      }, Yo.flushLegacyContextWarning = function() {
        o0.forEach(function(e, t) {
          if (e.length !== 0) {
            var o = e[0], l = /* @__PURE__ */ new Set();
            e.forEach(function(m) {
              l.add(st(m) || "Component"), Tk.add(m.type);
            });
            var f = pf(l);
            try {
              Ht(o), h(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, f);
            } finally {
              Yn();
            }
          }
        });
      }, Yo.discardPendingWarnings = function() {
        Um = [], Im = [], Hm = [], Wm = [], Ym = [], Gm = [], o0 = /* @__PURE__ */ new Map();
      };
    }
    function Go(e, t) {
      if (e && e.defaultProps) {
        var o = mt({}, t), l = e.defaultProps;
        for (var f in l)
          o[f] === void 0 && (o[f] = l[f]);
        return o;
      }
      return t;
    }
    var ax = Uu(null), ix;
    ix = {};
    var s0 = null, vp = null, ox = null, l0 = !1;
    function u0() {
      s0 = null, vp = null, ox = null, l0 = !1;
    }
    function kk() {
      l0 = !0;
    }
    function Rk() {
      l0 = !1;
    }
    function _k(e, t, o) {
      Na(ax, t._currentValue, e), t._currentValue = o, t._currentRenderer !== void 0 && t._currentRenderer !== null && t._currentRenderer !== ix && h("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), t._currentRenderer = ix;
    }
    function sx(e, t) {
      var o = ax.current;
      $a(ax, t), e._currentValue = o;
    }
    function lx(e, t, o) {
      for (var l = e; l !== null; ) {
        var f = l.alternate;
        if (xl(l.childLanes, t) ? f !== null && !xl(f.childLanes, t) && (f.childLanes = pt(f.childLanes, t)) : (l.childLanes = pt(l.childLanes, t), f !== null && (f.childLanes = pt(f.childLanes, t))), l === o)
          break;
        l = l.return;
      }
      l !== o && h("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function OL(e, t, o) {
      zL(e, t, o);
    }
    function zL(e, t, o) {
      var l = e.child;
      for (l !== null && (l.return = e); l !== null; ) {
        var f = void 0, m = l.dependencies;
        if (m !== null) {
          f = l.child;
          for (var g = m.firstContext; g !== null; ) {
            if (g.context === t) {
              if (l.tag === E) {
                var C = or(o), T = Nl(dn, C);
                T.tag = f0;
                var D = l.updateQueue;
                if (D !== null) {
                  var M = D.shared, U = M.pending;
                  U === null ? T.next = T : (T.next = U.next, U.next = T), M.pending = T;
                }
              }
              l.lanes = pt(l.lanes, o);
              var V = l.alternate;
              V !== null && (V.lanes = pt(V.lanes, o)), lx(l.return, o, e), m.lanes = pt(m.lanes, o);
              break;
            }
            g = g.next;
          }
        } else if (l.tag === W)
          f = l.type === e.type ? null : l.child;
        else if (l.tag === ot) {
          var Z = l.return;
          if (Z === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Z.lanes = pt(Z.lanes, o);
          var J = Z.alternate;
          J !== null && (J.lanes = pt(J.lanes, o)), lx(Z, o, e), f = l.sibling;
        } else
          f = l.child;
        if (f !== null)
          f.return = l;
        else
          for (f = l; f !== null; ) {
            if (f === e) {
              f = null;
              break;
            }
            var ae = f.sibling;
            if (ae !== null) {
              ae.return = f.return, f = ae;
              break;
            }
            f = f.return;
          }
        l = f;
      }
    }
    function yp(e, t) {
      s0 = e, vp = null, ox = null;
      var o = e.dependencies;
      if (o !== null) {
        var l = o.firstContext;
        l !== null && (La(o.lanes, t) && sv(), o.firstContext = null);
      }
    }
    function Er(e) {
      l0 && h("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var t = e._currentValue;
      if (ox !== e) {
        var o = {
          context: e,
          memoizedValue: t,
          next: null
        };
        if (vp === null) {
          if (s0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          vp = o, s0.dependencies = {
            lanes: oe,
            firstContext: o
          };
        } else
          vp = vp.next = o;
      }
      return t;
    }
    var mf = null;
    function ux(e) {
      mf === null ? mf = [e] : mf.push(e);
    }
    function PL() {
      if (mf !== null) {
        for (var e = 0; e < mf.length; e++) {
          var t = mf[e], o = t.interleaved;
          if (o !== null) {
            t.interleaved = null;
            var l = o.next, f = t.pending;
            if (f !== null) {
              var m = f.next;
              f.next = l, o.next = m;
            }
            t.pending = o;
          }
        }
        mf = null;
      }
    }
    function Dk(e, t, o, l) {
      var f = t.interleaved;
      return f === null ? (o.next = o, ux(t)) : (o.next = f.next, f.next = o), t.interleaved = o, c0(e, l);
    }
    function LL(e, t, o, l) {
      var f = t.interleaved;
      f === null ? (o.next = o, ux(t)) : (o.next = f.next, f.next = o), t.interleaved = o;
    }
    function $L(e, t, o, l) {
      var f = t.interleaved;
      return f === null ? (o.next = o, ux(t)) : (o.next = f.next, f.next = o), t.interleaved = o, c0(e, l);
    }
    function Ei(e, t) {
      return c0(e, t);
    }
    var NL = c0;
    function c0(e, t) {
      e.lanes = pt(e.lanes, t);
      var o = e.alternate;
      o !== null && (o.lanes = pt(o.lanes, t)), o === null && (e.flags & (xn | di)) !== We && A_(e);
      for (var l = e, f = e.return; f !== null; )
        f.childLanes = pt(f.childLanes, t), o = f.alternate, o !== null ? o.childLanes = pt(o.childLanes, t) : (f.flags & (xn | di)) !== We && A_(e), l = f, f = f.return;
      if (l.tag === k) {
        var m = l.stateNode;
        return m;
      } else
        return null;
    }
    var Ak = 0, Mk = 1, f0 = 2, cx = 3, d0 = !1, fx, p0;
    fx = !1, p0 = null;
    function dx(e) {
      var t = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: oe
        },
        effects: null
      };
      e.updateQueue = t;
    }
    function Ok(e, t) {
      var o = t.updateQueue, l = e.updateQueue;
      if (o === l) {
        var f = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects
        };
        t.updateQueue = f;
      }
    }
    function Nl(e, t) {
      var o = {
        eventTime: e,
        lane: t,
        tag: Ak,
        payload: null,
        callback: null,
        next: null
      };
      return o;
    }
    function Yu(e, t, o) {
      var l = e.updateQueue;
      if (l === null)
        return null;
      var f = l.shared;
      if (p0 === f && !fx && (h("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), fx = !0), NN()) {
        var m = f.pending;
        return m === null ? t.next = t : (t.next = m.next, m.next = t), f.pending = t, NL(e, o);
      } else
        return $L(e, f, t, o);
    }
    function h0(e, t, o) {
      var l = t.updateQueue;
      if (l !== null) {
        var f = l.shared;
        if (rm(o)) {
          var m = f.lanes;
          m = im(m, e.pendingLanes);
          var g = pt(m, o);
          f.lanes = g, ku(e, g);
        }
      }
    }
    function px(e, t) {
      var o = e.updateQueue, l = e.alternate;
      if (l !== null) {
        var f = l.updateQueue;
        if (o === f) {
          var m = null, g = null, C = o.firstBaseUpdate;
          if (C !== null) {
            var T = C;
            do {
              var D = {
                eventTime: T.eventTime,
                lane: T.lane,
                tag: T.tag,
                payload: T.payload,
                callback: T.callback,
                next: null
              };
              g === null ? m = g = D : (g.next = D, g = D), T = T.next;
            } while (T !== null);
            g === null ? m = g = t : (g.next = t, g = t);
          } else
            m = g = t;
          o = {
            baseState: f.baseState,
            firstBaseUpdate: m,
            lastBaseUpdate: g,
            shared: f.shared,
            effects: f.effects
          }, e.updateQueue = o;
          return;
        }
      }
      var M = o.lastBaseUpdate;
      M === null ? o.firstBaseUpdate = t : M.next = t, o.lastBaseUpdate = t;
    }
    function FL(e, t, o, l, f, m) {
      switch (o.tag) {
        case Mk: {
          var g = o.payload;
          if (typeof g == "function") {
            kk();
            var C = g.call(m, l, f);
            {
              if (e.mode & Pn) {
                ir(!0);
                try {
                  g.call(m, l, f);
                } finally {
                  ir(!1);
                }
              }
              Rk();
            }
            return C;
          }
          return g;
        }
        case cx:
          e.flags = e.flags & ~gr | rt;
        case Ak: {
          var T = o.payload, D;
          if (typeof T == "function") {
            kk(), D = T.call(m, l, f);
            {
              if (e.mode & Pn) {
                ir(!0);
                try {
                  T.call(m, l, f);
                } finally {
                  ir(!1);
                }
              }
              Rk();
            }
          } else
            D = T;
          return D == null ? l : mt({}, l, D);
        }
        case f0:
          return d0 = !0, l;
      }
      return l;
    }
    function m0(e, t, o, l) {
      var f = e.updateQueue;
      d0 = !1, p0 = f.shared;
      var m = f.firstBaseUpdate, g = f.lastBaseUpdate, C = f.shared.pending;
      if (C !== null) {
        f.shared.pending = null;
        var T = C, D = T.next;
        T.next = null, g === null ? m = D : g.next = D, g = T;
        var M = e.alternate;
        if (M !== null) {
          var U = M.updateQueue, V = U.lastBaseUpdate;
          V !== g && (V === null ? U.firstBaseUpdate = D : V.next = D, U.lastBaseUpdate = T);
        }
      }
      if (m !== null) {
        var Z = f.baseState, J = oe, ae = null, Re = null, qe = null, je = m;
        do {
          var At = je.lane, Tt = je.eventTime;
          if (xl(l, At)) {
            if (qe !== null) {
              var ie = {
                eventTime: Tt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: _t,
                tag: je.tag,
                payload: je.payload,
                callback: je.callback,
                next: null
              };
              qe = qe.next = ie;
            }
            Z = FL(e, f, je, Z, t, o);
            var Q = je.callback;
            if (Q !== null && // If the update was already committed, we should not queue its
            // callback again.
            je.lane !== _t) {
              e.flags |= to;
              var pe = f.effects;
              pe === null ? f.effects = [je] : pe.push(je);
            }
          } else {
            var q = {
              eventTime: Tt,
              lane: At,
              tag: je.tag,
              payload: je.payload,
              callback: je.callback,
              next: null
            };
            qe === null ? (Re = qe = q, ae = Z) : qe = qe.next = q, J = pt(J, At);
          }
          if (je = je.next, je === null) {
            if (C = f.shared.pending, C === null)
              break;
            var _e = C, we = _e.next;
            _e.next = null, je = we, f.lastBaseUpdate = _e, f.shared.pending = null;
          }
        } while (!0);
        qe === null && (ae = Z), f.baseState = ae, f.firstBaseUpdate = Re, f.lastBaseUpdate = qe;
        var nt = f.shared.interleaved;
        if (nt !== null) {
          var ut = nt;
          do
            J = pt(J, ut.lane), ut = ut.next;
          while (ut !== nt);
        } else
          m === null && (f.shared.lanes = oe);
        bv(J), e.lanes = J, e.memoizedState = Z;
      }
      p0 = null;
    }
    function VL(e, t) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(t);
    }
    function zk() {
      d0 = !1;
    }
    function v0() {
      return d0;
    }
    function Pk(e, t, o) {
      var l = t.effects;
      if (t.effects = null, l !== null)
        for (var f = 0; f < l.length; f++) {
          var m = l[f], g = m.callback;
          g !== null && (m.callback = null, VL(g, o));
        }
    }
    var hx = {}, Lk = new n.Component().refs, mx, vx, yx, gx, bx, $k, y0, Sx, xx, Cx;
    {
      mx = /* @__PURE__ */ new Set(), vx = /* @__PURE__ */ new Set(), yx = /* @__PURE__ */ new Set(), gx = /* @__PURE__ */ new Set(), Sx = /* @__PURE__ */ new Set(), bx = /* @__PURE__ */ new Set(), xx = /* @__PURE__ */ new Set(), Cx = /* @__PURE__ */ new Set();
      var Nk = /* @__PURE__ */ new Set();
      y0 = function(e, t) {
        if (!(e === null || typeof e == "function")) {
          var o = t + "_" + e;
          Nk.has(o) || (Nk.add(o), h("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e));
        }
      }, $k = function(e, t) {
        if (t === void 0) {
          var o = Zt(e) || "Component";
          bx.has(o) || (bx.add(o), h("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", o));
        }
      }, Object.defineProperty(hx, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(hx);
    }
    function Ex(e, t, o, l) {
      var f = e.memoizedState, m = o(l, f);
      {
        if (e.mode & Pn) {
          ir(!0);
          try {
            m = o(l, f);
          } finally {
            ir(!1);
          }
        }
        $k(t, m);
      }
      var g = m == null ? f : mt({}, f, m);
      if (e.memoizedState = g, e.lanes === oe) {
        var C = e.updateQueue;
        C.baseState = g;
      }
    }
    var wx = {
      isMounted: Qa,
      enqueueSetState: function(e, t, o) {
        var l = ci(e), f = ti(), m = ec(l), g = Nl(f, m);
        g.payload = t, o != null && (y0(o, "setState"), g.callback = o);
        var C = Yu(l, g, m);
        C !== null && (Vr(C, l, m, f), h0(C, l, m)), ws(l, m);
      },
      enqueueReplaceState: function(e, t, o) {
        var l = ci(e), f = ti(), m = ec(l), g = Nl(f, m);
        g.tag = Mk, g.payload = t, o != null && (y0(o, "replaceState"), g.callback = o);
        var C = Yu(l, g, m);
        C !== null && (Vr(C, l, m, f), h0(C, l, m)), ws(l, m);
      },
      enqueueForceUpdate: function(e, t) {
        var o = ci(e), l = ti(), f = ec(o), m = Nl(l, f);
        m.tag = f0, t != null && (y0(t, "forceUpdate"), m.callback = t);
        var g = Yu(o, m, f);
        g !== null && (Vr(g, o, f, l), h0(g, o, f)), Jh(o, f);
      }
    };
    function Fk(e, t, o, l, f, m, g) {
      var C = e.stateNode;
      if (typeof C.shouldComponentUpdate == "function") {
        var T = C.shouldComponentUpdate(l, m, g);
        {
          if (e.mode & Pn) {
            ir(!0);
            try {
              T = C.shouldComponentUpdate(l, m, g);
            } finally {
              ir(!1);
            }
          }
          T === void 0 && h("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Zt(t) || "Component");
        }
        return T;
      }
      return t.prototype && t.prototype.isPureReactComponent ? !Ie(o, l) || !Ie(f, m) : !0;
    }
    function jL(e, t, o) {
      var l = e.stateNode;
      {
        var f = Zt(t) || "Component", m = l.render;
        m || (t.prototype && typeof t.prototype.render == "function" ? h("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", f) : h("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", f)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && h("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", f), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && h("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", f), l.propTypes && h("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", f), l.contextType && h("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", f), l.contextTypes && h("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", f), t.contextType && t.contextTypes && !xx.has(t) && (xx.add(t), h("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", f)), typeof l.componentShouldUpdate == "function" && h("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", f), t.prototype && t.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && h("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Zt(t) || "A pure component"), typeof l.componentDidUnmount == "function" && h("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", f), typeof l.componentDidReceiveProps == "function" && h("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", f), typeof l.componentWillRecieveProps == "function" && h("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", f), typeof l.UNSAFE_componentWillRecieveProps == "function" && h("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", f);
        var g = l.props !== o;
        l.props !== void 0 && g && h("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", f, f), l.defaultProps && h("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", f, f), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !yx.has(t) && (yx.add(t), h("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Zt(t))), typeof l.getDerivedStateFromProps == "function" && h("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", f), typeof l.getDerivedStateFromError == "function" && h("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", f), typeof t.getSnapshotBeforeUpdate == "function" && h("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", f);
        var C = l.state;
        C && (typeof C != "object" || vr(C)) && h("%s.state: must be set to an object or null", f), typeof l.getChildContext == "function" && typeof t.childContextTypes != "object" && h("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", f);
      }
    }
    function Vk(e, t) {
      t.updater = wx, e.stateNode = t, vu(t, e), t._reactInternalInstance = hx;
    }
    function jk(e, t, o) {
      var l = !1, f = Ii, m = Ii, g = t.contextType;
      if ("contextType" in t) {
        var C = (
          // Allow null for conditional declaration
          g === null || g !== void 0 && g.$$typeof === be && g._context === void 0
        );
        if (!C && !Cx.has(t)) {
          Cx.add(t);
          var T = "";
          g === void 0 ? T = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof g != "object" ? T = " However, it is set to a " + typeof g + "." : g.$$typeof === ce ? T = " Did you accidentally pass the Context.Provider instead?" : g._context !== void 0 ? T = " Did you accidentally pass the Context.Consumer instead?" : T = " However, it is set to an object with keys {" + Object.keys(g).join(", ") + "}.", h("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Zt(t) || "Component", T);
        }
      }
      if (typeof g == "object" && g !== null)
        m = Er(g);
      else {
        f = fp(e, t, !0);
        var D = t.contextTypes;
        l = D != null, m = l ? dp(e, f) : Ii;
      }
      var M = new t(o, m);
      if (e.mode & Pn) {
        ir(!0);
        try {
          M = new t(o, m);
        } finally {
          ir(!1);
        }
      }
      var U = e.memoizedState = M.state !== null && M.state !== void 0 ? M.state : null;
      Vk(e, M);
      {
        if (typeof t.getDerivedStateFromProps == "function" && U === null) {
          var V = Zt(t) || "Component";
          vx.has(V) || (vx.add(V), h("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", V, M.state === null ? "null" : "undefined", V));
        }
        if (typeof t.getDerivedStateFromProps == "function" || typeof M.getSnapshotBeforeUpdate == "function") {
          var Z = null, J = null, ae = null;
          if (typeof M.componentWillMount == "function" && M.componentWillMount.__suppressDeprecationWarning !== !0 ? Z = "componentWillMount" : typeof M.UNSAFE_componentWillMount == "function" && (Z = "UNSAFE_componentWillMount"), typeof M.componentWillReceiveProps == "function" && M.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? J = "componentWillReceiveProps" : typeof M.UNSAFE_componentWillReceiveProps == "function" && (J = "UNSAFE_componentWillReceiveProps"), typeof M.componentWillUpdate == "function" && M.componentWillUpdate.__suppressDeprecationWarning !== !0 ? ae = "componentWillUpdate" : typeof M.UNSAFE_componentWillUpdate == "function" && (ae = "UNSAFE_componentWillUpdate"), Z !== null || J !== null || ae !== null) {
            var Re = Zt(t) || "Component", qe = typeof t.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            gx.has(Re) || (gx.add(Re), h(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Re, qe, Z !== null ? `
  ` + Z : "", J !== null ? `
  ` + J : "", ae !== null ? `
  ` + ae : ""));
          }
        }
      }
      return l && ck(e, f, m), M;
    }
    function BL(e, t) {
      var o = t.state;
      typeof t.componentWillMount == "function" && t.componentWillMount(), typeof t.UNSAFE_componentWillMount == "function" && t.UNSAFE_componentWillMount(), o !== t.state && (h("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", st(e) || "Component"), wx.enqueueReplaceState(t, t.state, null));
    }
    function Bk(e, t, o, l) {
      var f = t.state;
      if (typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(o, l), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(o, l), t.state !== f) {
        {
          var m = st(e) || "Component";
          mx.has(m) || (mx.add(m), h("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", m));
        }
        wx.enqueueReplaceState(t, t.state, null);
      }
    }
    function Tx(e, t, o, l) {
      jL(e, t, o);
      var f = e.stateNode;
      f.props = o, f.state = e.memoizedState, f.refs = Lk, dx(e);
      var m = t.contextType;
      if (typeof m == "object" && m !== null)
        f.context = Er(m);
      else {
        var g = fp(e, t, !0);
        f.context = dp(e, g);
      }
      {
        if (f.state === o) {
          var C = Zt(t) || "Component";
          Sx.has(C) || (Sx.add(C), h("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", C));
        }
        e.mode & Pn && Yo.recordLegacyContextWarning(e, f), Yo.recordUnsafeLifecycleWarnings(e, f);
      }
      f.state = e.memoizedState;
      var T = t.getDerivedStateFromProps;
      if (typeof T == "function" && (Ex(e, t, T, o), f.state = e.memoizedState), typeof t.getDerivedStateFromProps != "function" && typeof f.getSnapshotBeforeUpdate != "function" && (typeof f.UNSAFE_componentWillMount == "function" || typeof f.componentWillMount == "function") && (BL(e, f), m0(e, o, f, l), f.state = e.memoizedState), typeof f.componentDidMount == "function") {
        var D = dt;
        D |= Da, (e.mode & mi) !== Qe && (D |= Aa), e.flags |= D;
      }
    }
    function UL(e, t, o, l) {
      var f = e.stateNode, m = e.memoizedProps;
      f.props = m;
      var g = f.context, C = t.contextType, T = Ii;
      if (typeof C == "object" && C !== null)
        T = Er(C);
      else {
        var D = fp(e, t, !0);
        T = dp(e, D);
      }
      var M = t.getDerivedStateFromProps, U = typeof M == "function" || typeof f.getSnapshotBeforeUpdate == "function";
      !U && (typeof f.UNSAFE_componentWillReceiveProps == "function" || typeof f.componentWillReceiveProps == "function") && (m !== o || g !== T) && Bk(e, f, o, T), zk();
      var V = e.memoizedState, Z = f.state = V;
      if (m0(e, o, f, l), Z = e.memoizedState, m === o && V === Z && !Zg() && !v0()) {
        if (typeof f.componentDidMount == "function") {
          var J = dt;
          J |= Da, (e.mode & mi) !== Qe && (J |= Aa), e.flags |= J;
        }
        return !1;
      }
      typeof M == "function" && (Ex(e, t, M, o), Z = e.memoizedState);
      var ae = v0() || Fk(e, t, m, o, V, Z, T);
      if (ae) {
        if (!U && (typeof f.UNSAFE_componentWillMount == "function" || typeof f.componentWillMount == "function") && (typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount()), typeof f.componentDidMount == "function") {
          var Re = dt;
          Re |= Da, (e.mode & mi) !== Qe && (Re |= Aa), e.flags |= Re;
        }
      } else {
        if (typeof f.componentDidMount == "function") {
          var qe = dt;
          qe |= Da, (e.mode & mi) !== Qe && (qe |= Aa), e.flags |= qe;
        }
        e.memoizedProps = o, e.memoizedState = Z;
      }
      return f.props = o, f.state = Z, f.context = T, ae;
    }
    function IL(e, t, o, l, f) {
      var m = t.stateNode;
      Ok(e, t);
      var g = t.memoizedProps, C = t.type === t.elementType ? g : Go(t.type, g);
      m.props = C;
      var T = t.pendingProps, D = m.context, M = o.contextType, U = Ii;
      if (typeof M == "object" && M !== null)
        U = Er(M);
      else {
        var V = fp(t, o, !0);
        U = dp(t, V);
      }
      var Z = o.getDerivedStateFromProps, J = typeof Z == "function" || typeof m.getSnapshotBeforeUpdate == "function";
      !J && (typeof m.UNSAFE_componentWillReceiveProps == "function" || typeof m.componentWillReceiveProps == "function") && (g !== T || D !== U) && Bk(t, m, l, U), zk();
      var ae = t.memoizedState, Re = m.state = ae;
      if (m0(t, l, m, f), Re = t.memoizedState, g === T && ae === Re && !Zg() && !v0() && !Ce)
        return typeof m.componentDidUpdate == "function" && (g !== e.memoizedProps || ae !== e.memoizedState) && (t.flags |= dt), typeof m.getSnapshotBeforeUpdate == "function" && (g !== e.memoizedProps || ae !== e.memoizedState) && (t.flags |= fi), !1;
      typeof Z == "function" && (Ex(t, o, Z, l), Re = t.memoizedState);
      var qe = v0() || Fk(t, o, C, l, ae, Re, U) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Ce;
      return qe ? (!J && (typeof m.UNSAFE_componentWillUpdate == "function" || typeof m.componentWillUpdate == "function") && (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(l, Re, U), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(l, Re, U)), typeof m.componentDidUpdate == "function" && (t.flags |= dt), typeof m.getSnapshotBeforeUpdate == "function" && (t.flags |= fi)) : (typeof m.componentDidUpdate == "function" && (g !== e.memoizedProps || ae !== e.memoizedState) && (t.flags |= dt), typeof m.getSnapshotBeforeUpdate == "function" && (g !== e.memoizedProps || ae !== e.memoizedState) && (t.flags |= fi), t.memoizedProps = l, t.memoizedState = Re), m.props = l, m.state = Re, m.context = U, qe;
    }
    var kx, Rx, _x, Dx, Ax, Uk = function(e, t) {
    };
    kx = !1, Rx = !1, _x = {}, Dx = {}, Ax = {}, Uk = function(e, t) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var o = st(t) || "Component";
        Dx[o] || (Dx[o] = !0, h('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function qm(e, t, o) {
      var l = o.ref;
      if (l !== null && typeof l != "function" && typeof l != "object") {
        if ((e.mode & Pn || cn) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(o._owner && o._self && o._owner.stateNode !== o._self)) {
          var f = st(e) || "Component";
          _x[f] || (h('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', l), _x[f] = !0);
        }
        if (o._owner) {
          var m = o._owner, g;
          if (m) {
            var C = m;
            if (C.tag !== E)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            g = C.stateNode;
          }
          if (!g)
            throw new Error("Missing owner for string ref " + l + ". This error is likely caused by a bug in React. Please file an issue.");
          var T = g;
          Sa(l, "ref");
          var D = "" + l;
          if (t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === D)
            return t.ref;
          var M = function(U) {
            var V = T.refs;
            V === Lk && (V = T.refs = {}), U === null ? delete V[D] : V[D] = U;
          };
          return M._stringRef = D, M;
        } else {
          if (typeof l != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!o._owner)
            throw new Error("Element ref was specified as a string (" + l + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return l;
    }
    function g0(e, t) {
      var o = Object.prototype.toString.call(t);
      throw new Error("Objects are not valid as a React child (found: " + (o === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : o) + "). If you meant to render a collection of children, use an array instead.");
    }
    function b0(e) {
      {
        var t = st(e) || "Component";
        if (Ax[t])
          return;
        Ax[t] = !0, h("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Ik(e) {
      var t = e._payload, o = e._init;
      return o(t);
    }
    function Hk(e) {
      function t(q, ie) {
        if (e) {
          var Q = q.deletions;
          Q === null ? (q.deletions = [ie], q.flags |= Yt) : Q.push(ie);
        }
      }
      function o(q, ie) {
        if (!e)
          return null;
        for (var Q = ie; Q !== null; )
          t(q, Q), Q = Q.sibling;
        return null;
      }
      function l(q, ie) {
        for (var Q = /* @__PURE__ */ new Map(), pe = ie; pe !== null; )
          pe.key !== null ? Q.set(pe.key, pe) : Q.set(pe.index, pe), pe = pe.sibling;
        return Q;
      }
      function f(q, ie) {
        var Q = Ef(q, ie);
        return Q.index = 0, Q.sibling = null, Q;
      }
      function m(q, ie, Q) {
        if (q.index = Q, !e)
          return q.flags |= Bh, ie;
        var pe = q.alternate;
        if (pe !== null) {
          var _e = pe.index;
          return _e < ie ? (q.flags |= xn, ie) : _e;
        } else
          return q.flags |= xn, ie;
      }
      function g(q) {
        return e && q.alternate === null && (q.flags |= xn), q;
      }
      function C(q, ie, Q, pe) {
        if (ie === null || ie.tag !== L) {
          var _e = rE(Q, q.mode, pe);
          return _e.return = q, _e;
        } else {
          var we = f(ie, Q);
          return we.return = q, we;
        }
      }
      function T(q, ie, Q, pe) {
        var _e = Q.type;
        if (_e === Wa)
          return M(q, ie, Q.props.children, pe, Q.key);
        if (ie !== null && (ie.elementType === _e || // Keep this check inline so it only runs on the false path:
        P_(ie, Q) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof _e == "object" && _e !== null && _e.$$typeof === Ge && Ik(_e) === ie.type)) {
          var we = f(ie, Q.props);
          return we.ref = qm(q, ie, Q), we.return = q, we._debugSource = Q._source, we._debugOwner = Q._owner, we;
        }
        var nt = nE(Q, q.mode, pe);
        return nt.ref = qm(q, ie, Q), nt.return = q, nt;
      }
      function D(q, ie, Q, pe) {
        if (ie === null || ie.tag !== _ || ie.stateNode.containerInfo !== Q.containerInfo || ie.stateNode.implementation !== Q.implementation) {
          var _e = aE(Q, q.mode, pe);
          return _e.return = q, _e;
        } else {
          var we = f(ie, Q.children || []);
          return we.return = q, we;
        }
      }
      function M(q, ie, Q, pe, _e) {
        if (ie === null || ie.tag !== $) {
          var we = nc(Q, q.mode, pe, _e);
          return we.return = q, we;
        } else {
          var nt = f(ie, Q);
          return nt.return = q, nt;
        }
      }
      function U(q, ie, Q) {
        if (typeof ie == "string" && ie !== "" || typeof ie == "number") {
          var pe = rE("" + ie, q.mode, Q);
          return pe.return = q, pe;
        }
        if (typeof ie == "object" && ie !== null) {
          switch (ie.$$typeof) {
            case Zi: {
              var _e = nE(ie, q.mode, Q);
              return _e.ref = qm(q, null, ie), _e.return = q, _e;
            }
            case ra: {
              var we = aE(ie, q.mode, Q);
              return we.return = q, we;
            }
            case Ge: {
              var nt = ie._payload, ut = ie._init;
              return U(q, ut(nt), Q);
            }
          }
          if (vr(ie) || Pi(ie)) {
            var on = nc(ie, q.mode, Q, null);
            return on.return = q, on;
          }
          g0(q, ie);
        }
        return typeof ie == "function" && b0(q), null;
      }
      function V(q, ie, Q, pe) {
        var _e = ie !== null ? ie.key : null;
        if (typeof Q == "string" && Q !== "" || typeof Q == "number")
          return _e !== null ? null : C(q, ie, "" + Q, pe);
        if (typeof Q == "object" && Q !== null) {
          switch (Q.$$typeof) {
            case Zi:
              return Q.key === _e ? T(q, ie, Q, pe) : null;
            case ra:
              return Q.key === _e ? D(q, ie, Q, pe) : null;
            case Ge: {
              var we = Q._payload, nt = Q._init;
              return V(q, ie, nt(we), pe);
            }
          }
          if (vr(Q) || Pi(Q))
            return _e !== null ? null : M(q, ie, Q, pe, null);
          g0(q, Q);
        }
        return typeof Q == "function" && b0(q), null;
      }
      function Z(q, ie, Q, pe, _e) {
        if (typeof pe == "string" && pe !== "" || typeof pe == "number") {
          var we = q.get(Q) || null;
          return C(ie, we, "" + pe, _e);
        }
        if (typeof pe == "object" && pe !== null) {
          switch (pe.$$typeof) {
            case Zi: {
              var nt = q.get(pe.key === null ? Q : pe.key) || null;
              return T(ie, nt, pe, _e);
            }
            case ra: {
              var ut = q.get(pe.key === null ? Q : pe.key) || null;
              return D(ie, ut, pe, _e);
            }
            case Ge:
              var on = pe._payload, Ft = pe._init;
              return Z(q, ie, Q, Ft(on), _e);
          }
          if (vr(pe) || Pi(pe)) {
            var cr = q.get(Q) || null;
            return M(ie, cr, pe, _e, null);
          }
          g0(ie, pe);
        }
        return typeof pe == "function" && b0(ie), null;
      }
      function J(q, ie, Q) {
        {
          if (typeof q != "object" || q === null)
            return ie;
          switch (q.$$typeof) {
            case Zi:
            case ra:
              Uk(q, Q);
              var pe = q.key;
              if (typeof pe != "string")
                break;
              if (ie === null) {
                ie = /* @__PURE__ */ new Set(), ie.add(pe);
                break;
              }
              if (!ie.has(pe)) {
                ie.add(pe);
                break;
              }
              h("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", pe);
              break;
            case Ge:
              var _e = q._payload, we = q._init;
              J(we(_e), ie, Q);
              break;
          }
        }
        return ie;
      }
      function ae(q, ie, Q, pe) {
        for (var _e = null, we = 0; we < Q.length; we++) {
          var nt = Q[we];
          _e = J(nt, _e, q);
        }
        for (var ut = null, on = null, Ft = ie, cr = 0, Vt = 0, nr = null; Ft !== null && Vt < Q.length; Vt++) {
          Ft.index > Vt ? (nr = Ft, Ft = null) : nr = Ft.sibling;
          var Va = V(q, Ft, Q[Vt], pe);
          if (Va === null) {
            Ft === null && (Ft = nr);
            break;
          }
          e && Ft && Va.alternate === null && t(q, Ft), cr = m(Va, cr, Vt), on === null ? ut = Va : on.sibling = Va, on = Va, Ft = nr;
        }
        if (Vt === Q.length) {
          if (o(q, Ft), sa()) {
            var ha = Vt;
            cf(q, ha);
          }
          return ut;
        }
        if (Ft === null) {
          for (; Vt < Q.length; Vt++) {
            var Wi = U(q, Q[Vt], pe);
            Wi !== null && (cr = m(Wi, cr, Vt), on === null ? ut = Wi : on.sibling = Wi, on = Wi);
          }
          if (sa()) {
            var ni = Vt;
            cf(q, ni);
          }
          return ut;
        }
        for (var ri = l(q, Ft); Vt < Q.length; Vt++) {
          var ja = Z(ri, q, Vt, Q[Vt], pe);
          ja !== null && (e && ja.alternate !== null && ri.delete(ja.key === null ? Vt : ja.key), cr = m(ja, cr, Vt), on === null ? ut = ja : on.sibling = ja, on = ja);
        }
        if (e && ri.forEach(function(Pp) {
          return t(q, Pp);
        }), sa()) {
          var Il = Vt;
          cf(q, Il);
        }
        return ut;
      }
      function Re(q, ie, Q, pe) {
        var _e = Pi(Q);
        if (typeof _e != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Q[Symbol.toStringTag] === "Generator" && (Rx || h("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Rx = !0), Q.entries === _e && (kx || h("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), kx = !0);
          var we = _e.call(Q);
          if (we)
            for (var nt = null, ut = we.next(); !ut.done; ut = we.next()) {
              var on = ut.value;
              nt = J(on, nt, q);
            }
        }
        var Ft = _e.call(Q);
        if (Ft == null)
          throw new Error("An iterable object provided no iterator.");
        for (var cr = null, Vt = null, nr = ie, Va = 0, ha = 0, Wi = null, ni = Ft.next(); nr !== null && !ni.done; ha++, ni = Ft.next()) {
          nr.index > ha ? (Wi = nr, nr = null) : Wi = nr.sibling;
          var ri = V(q, nr, ni.value, pe);
          if (ri === null) {
            nr === null && (nr = Wi);
            break;
          }
          e && nr && ri.alternate === null && t(q, nr), Va = m(ri, Va, ha), Vt === null ? cr = ri : Vt.sibling = ri, Vt = ri, nr = Wi;
        }
        if (ni.done) {
          if (o(q, nr), sa()) {
            var ja = ha;
            cf(q, ja);
          }
          return cr;
        }
        if (nr === null) {
          for (; !ni.done; ha++, ni = Ft.next()) {
            var Il = U(q, ni.value, pe);
            Il !== null && (Va = m(Il, Va, ha), Vt === null ? cr = Il : Vt.sibling = Il, Vt = Il);
          }
          if (sa()) {
            var Pp = ha;
            cf(q, Pp);
          }
          return cr;
        }
        for (var wv = l(q, nr); !ni.done; ha++, ni = Ft.next()) {
          var Us = Z(wv, q, ha, ni.value, pe);
          Us !== null && (e && Us.alternate !== null && wv.delete(Us.key === null ? ha : Us.key), Va = m(Us, Va, ha), Vt === null ? cr = Us : Vt.sibling = Us, Vt = Us);
        }
        if (e && wv.forEach(function(r4) {
          return t(q, r4);
        }), sa()) {
          var n4 = ha;
          cf(q, n4);
        }
        return cr;
      }
      function qe(q, ie, Q, pe) {
        if (ie !== null && ie.tag === L) {
          o(q, ie.sibling);
          var _e = f(ie, Q);
          return _e.return = q, _e;
        }
        o(q, ie);
        var we = rE(Q, q.mode, pe);
        return we.return = q, we;
      }
      function je(q, ie, Q, pe) {
        for (var _e = Q.key, we = ie; we !== null; ) {
          if (we.key === _e) {
            var nt = Q.type;
            if (nt === Wa) {
              if (we.tag === $) {
                o(q, we.sibling);
                var ut = f(we, Q.props.children);
                return ut.return = q, ut._debugSource = Q._source, ut._debugOwner = Q._owner, ut;
              }
            } else if (we.elementType === nt || // Keep this check inline so it only runs on the false path:
            P_(we, Q) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof nt == "object" && nt !== null && nt.$$typeof === Ge && Ik(nt) === we.type) {
              o(q, we.sibling);
              var on = f(we, Q.props);
              return on.ref = qm(q, we, Q), on.return = q, on._debugSource = Q._source, on._debugOwner = Q._owner, on;
            }
            o(q, we);
            break;
          } else
            t(q, we);
          we = we.sibling;
        }
        if (Q.type === Wa) {
          var Ft = nc(Q.props.children, q.mode, pe, Q.key);
          return Ft.return = q, Ft;
        } else {
          var cr = nE(Q, q.mode, pe);
          return cr.ref = qm(q, ie, Q), cr.return = q, cr;
        }
      }
      function At(q, ie, Q, pe) {
        for (var _e = Q.key, we = ie; we !== null; ) {
          if (we.key === _e)
            if (we.tag === _ && we.stateNode.containerInfo === Q.containerInfo && we.stateNode.implementation === Q.implementation) {
              o(q, we.sibling);
              var nt = f(we, Q.children || []);
              return nt.return = q, nt;
            } else {
              o(q, we);
              break;
            }
          else
            t(q, we);
          we = we.sibling;
        }
        var ut = aE(Q, q.mode, pe);
        return ut.return = q, ut;
      }
      function Tt(q, ie, Q, pe) {
        var _e = typeof Q == "object" && Q !== null && Q.type === Wa && Q.key === null;
        if (_e && (Q = Q.props.children), typeof Q == "object" && Q !== null) {
          switch (Q.$$typeof) {
            case Zi:
              return g(je(q, ie, Q, pe));
            case ra:
              return g(At(q, ie, Q, pe));
            case Ge:
              var we = Q._payload, nt = Q._init;
              return Tt(q, ie, nt(we), pe);
          }
          if (vr(Q))
            return ae(q, ie, Q, pe);
          if (Pi(Q))
            return Re(q, ie, Q, pe);
          g0(q, Q);
        }
        return typeof Q == "string" && Q !== "" || typeof Q == "number" ? g(qe(q, ie, "" + Q, pe)) : (typeof Q == "function" && b0(q), o(q, ie));
      }
      return Tt;
    }
    var gp = Hk(!0), Wk = Hk(!1);
    function HL(e, t) {
      if (e !== null && t.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (t.child !== null) {
        var o = t.child, l = Ef(o, o.pendingProps);
        for (t.child = l, l.return = t; o.sibling !== null; )
          o = o.sibling, l = l.sibling = Ef(o, o.pendingProps), l.return = t;
        l.sibling = null;
      }
    }
    function WL(e, t) {
      for (var o = e.child; o !== null; )
        S3(o, t), o = o.sibling;
    }
    var Qm = {}, Gu = Uu(Qm), Km = Uu(Qm), S0 = Uu(Qm);
    function x0(e) {
      if (e === Qm)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Yk() {
      var e = x0(S0.current);
      return e;
    }
    function Mx(e, t) {
      Na(S0, t, e), Na(Km, e, e), Na(Gu, Qm, e);
      var o = i5(t);
      $a(Gu, e), Na(Gu, o, e);
    }
    function bp(e) {
      $a(Gu, e), $a(Km, e), $a(S0, e);
    }
    function Ox() {
      var e = x0(Gu.current);
      return e;
    }
    function Gk(e) {
      x0(S0.current);
      var t = x0(Gu.current), o = o5(t, e.type);
      t !== o && (Na(Km, e, e), Na(Gu, o, e));
    }
    function zx(e) {
      Km.current === e && ($a(Gu, e), $a(Km, e));
    }
    var YL = 0, qk = 1, Qk = 1, Xm = 2, qo = Uu(YL);
    function Px(e, t) {
      return (e & t) !== 0;
    }
    function Sp(e) {
      return e & qk;
    }
    function Lx(e, t) {
      return e & qk | t;
    }
    function GL(e, t) {
      return e | t;
    }
    function qu(e, t) {
      Na(qo, t, e);
    }
    function xp(e) {
      $a(qo, e);
    }
    function qL(e, t) {
      var o = e.memoizedState;
      return o !== null ? o.dehydrated !== null : (e.memoizedProps, !0);
    }
    function C0(e) {
      for (var t = e; t !== null; ) {
        if (t.tag === H) {
          var o = t.memoizedState;
          if (o !== null) {
            var l = o.dehydrated;
            if (l === null || ik(l) || B1(l))
              return t;
          }
        } else if (t.tag === vt && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        t.memoizedProps.revealOrder !== void 0) {
          var f = (t.flags & rt) !== We;
          if (f)
            return t;
        } else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue;
        }
        if (t === e)
          return null;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return null;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return null;
    }
    var wi = (
      /*   */
      0
    ), Or = (
      /* */
      1
    ), Ls = (
      /*  */
      2
    ), zr = (
      /*    */
      4
    ), la = (
      /*   */
      8
    ), $x = [];
    function Nx() {
      for (var e = 0; e < $x.length; e++) {
        var t = $x[e];
        t._workInProgressVersionPrimary = null;
      }
      $x.length = 0;
    }
    function QL(e, t) {
      var o = t._getVersion, l = o(t._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, l] : e.mutableSourceEagerHydrationData.push(t, l);
    }
    var ke = s.ReactCurrentDispatcher, Zm = s.ReactCurrentBatchConfig, Fx, Cp;
    Fx = /* @__PURE__ */ new Set();
    var vf = oe, an = null, Pr = null, Lr = null, E0 = !1, Jm = !1, ev = 0, KL = 0, XL = 25, se = null, co = null, Qu = -1, Vx = !1;
    function Kt() {
      {
        var e = se;
        co === null ? co = [e] : co.push(e);
      }
    }
    function xe() {
      {
        var e = se;
        co !== null && (Qu++, co[Qu] !== e && ZL(e));
      }
    }
    function Ep(e) {
      e != null && !vr(e) && h("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", se, typeof e);
    }
    function ZL(e) {
      {
        var t = st(an);
        if (!Fx.has(t) && (Fx.add(t), co !== null)) {
          for (var o = "", l = 30, f = 0; f <= Qu; f++) {
            for (var m = co[f], g = f === Qu ? e : m, C = f + 1 + ". " + m; C.length < l; )
              C += " ";
            C += g + `
`, o += C;
          }
          h(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, t, o);
        }
      }
    }
    function Fa() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function jx(e, t) {
      if (Vx)
        return !1;
      if (t === null)
        return h("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", se), !1;
      e.length !== t.length && h(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, se, "[" + t.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var o = 0; o < t.length && o < e.length; o++)
        if (!Pe(e[o], t[o]))
          return !1;
      return !0;
    }
    function wp(e, t, o, l, f, m) {
      vf = m, an = t, co = e !== null ? e._debugHookTypes : null, Qu = -1, Vx = e !== null && e.type !== t.type, t.memoizedState = null, t.updateQueue = null, t.lanes = oe, e !== null && e.memoizedState !== null ? ke.current = yR : co !== null ? ke.current = vR : ke.current = mR;
      var g = o(l, f);
      if (Jm) {
        var C = 0;
        do {
          if (Jm = !1, ev = 0, C >= XL)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          C += 1, Vx = !1, Pr = null, Lr = null, t.updateQueue = null, Qu = -1, ke.current = gR, g = o(l, f);
        } while (Jm);
      }
      ke.current = $0, t._debugHookTypes = co;
      var T = Pr !== null && Pr.next !== null;
      if (vf = oe, an = null, Pr = null, Lr = null, se = null, co = null, Qu = -1, e !== null && (e.flags & Dr) !== (t.flags & Dr) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & xt) !== Qe && h("Internal React error: Expected static flag was missing. Please notify the React team."), E0 = !1, T)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return g;
    }
    function Tp() {
      var e = ev !== 0;
      return ev = 0, e;
    }
    function Kk(e, t, o) {
      t.updateQueue = e.updateQueue, (t.mode & mi) !== Qe ? t.flags &= ~(fl | Aa | _n | dt) : t.flags &= ~(_n | dt), e.lanes = Tu(e.lanes, o);
    }
    function Xk() {
      if (ke.current = $0, E0) {
        for (var e = an.memoizedState; e !== null; ) {
          var t = e.queue;
          t !== null && (t.pending = null), e = e.next;
        }
        E0 = !1;
      }
      vf = oe, an = null, Pr = null, Lr = null, co = null, Qu = -1, se = null, cR = !1, Jm = !1, ev = 0;
    }
    function $s() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Lr === null ? an.memoizedState = Lr = e : Lr = Lr.next = e, Lr;
    }
    function fo() {
      var e;
      if (Pr === null) {
        var t = an.alternate;
        t !== null ? e = t.memoizedState : e = null;
      } else
        e = Pr.next;
      var o;
      if (Lr === null ? o = an.memoizedState : o = Lr.next, o !== null)
        Lr = o, o = Lr.next, Pr = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Pr = e;
        var l = {
          memoizedState: Pr.memoizedState,
          baseState: Pr.baseState,
          baseQueue: Pr.baseQueue,
          queue: Pr.queue,
          next: null
        };
        Lr === null ? an.memoizedState = Lr = l : Lr = Lr.next = l;
      }
      return Lr;
    }
    function Zk() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Bx(e, t) {
      return typeof t == "function" ? t(e) : t;
    }
    function Ux(e, t, o) {
      var l = $s(), f;
      o !== void 0 ? f = o(t) : f = t, l.memoizedState = l.baseState = f;
      var m = {
        pending: null,
        interleaved: null,
        lanes: oe,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: f
      };
      l.queue = m;
      var g = m.dispatch = n$.bind(null, an, m);
      return [l.memoizedState, g];
    }
    function Ix(e, t, o) {
      var l = fo(), f = l.queue;
      if (f === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      f.lastRenderedReducer = e;
      var m = Pr, g = m.baseQueue, C = f.pending;
      if (C !== null) {
        if (g !== null) {
          var T = g.next, D = C.next;
          g.next = D, C.next = T;
        }
        m.baseQueue !== g && h("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), m.baseQueue = g = C, f.pending = null;
      }
      if (g !== null) {
        var M = g.next, U = m.baseState, V = null, Z = null, J = null, ae = M;
        do {
          var Re = ae.lane;
          if (xl(vf, Re)) {
            if (J !== null) {
              var je = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: _t,
                action: ae.action,
                hasEagerState: ae.hasEagerState,
                eagerState: ae.eagerState,
                next: null
              };
              J = J.next = je;
            }
            if (ae.hasEagerState)
              U = ae.eagerState;
            else {
              var At = ae.action;
              U = e(U, At);
            }
          } else {
            var qe = {
              lane: Re,
              action: ae.action,
              hasEagerState: ae.hasEagerState,
              eagerState: ae.eagerState,
              next: null
            };
            J === null ? (Z = J = qe, V = U) : J = J.next = qe, an.lanes = pt(an.lanes, Re), bv(Re);
          }
          ae = ae.next;
        } while (ae !== null && ae !== M);
        J === null ? V = U : J.next = Z, Pe(U, l.memoizedState) || sv(), l.memoizedState = U, l.baseState = V, l.baseQueue = J, f.lastRenderedState = U;
      }
      var Tt = f.interleaved;
      if (Tt !== null) {
        var q = Tt;
        do {
          var ie = q.lane;
          an.lanes = pt(an.lanes, ie), bv(ie), q = q.next;
        } while (q !== Tt);
      } else
        g === null && (f.lanes = oe);
      var Q = f.dispatch;
      return [l.memoizedState, Q];
    }
    function Hx(e, t, o) {
      var l = fo(), f = l.queue;
      if (f === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      f.lastRenderedReducer = e;
      var m = f.dispatch, g = f.pending, C = l.memoizedState;
      if (g !== null) {
        f.pending = null;
        var T = g.next, D = T;
        do {
          var M = D.action;
          C = e(C, M), D = D.next;
        } while (D !== T);
        Pe(C, l.memoizedState) || sv(), l.memoizedState = C, l.baseQueue === null && (l.baseState = C), f.lastRenderedState = C;
      }
      return [C, m];
    }
    function tQ(e, t, o) {
    }
    function nQ(e, t, o) {
    }
    function Wx(e, t, o) {
      var l = an, f = $s(), m, g = sa();
      if (g) {
        if (o === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        m = o(), Cp || m !== o() && (h("The result of getServerSnapshot should be cached to avoid an infinite loop"), Cp = !0);
      } else {
        if (m = t(), !Cp) {
          var C = t();
          Pe(m, C) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), Cp = !0);
        }
        var T = eb();
        if (T === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Yc(T, vf) || Jk(l, t, m);
      }
      f.memoizedState = m;
      var D = {
        value: m,
        getSnapshot: t
      };
      return f.queue = D, _0(tR.bind(null, l, D, e), [e]), l.flags |= _n, tv(Or | la, eR.bind(null, l, D, m, t), void 0, null), m;
    }
    function w0(e, t, o) {
      var l = an, f = fo(), m = t();
      if (!Cp) {
        var g = t();
        Pe(m, g) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), Cp = !0);
      }
      var C = f.memoizedState, T = !Pe(C, m);
      T && (f.memoizedState = m, sv());
      var D = f.queue;
      if (rv(tR.bind(null, l, D, e), [e]), D.getSnapshot !== t || T || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Lr !== null && Lr.memoizedState.tag & Or) {
        l.flags |= _n, tv(Or | la, eR.bind(null, l, D, m, t), void 0, null);
        var M = eb();
        if (M === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Yc(M, vf) || Jk(l, t, m);
      }
      return m;
    }
    function Jk(e, t, o) {
      e.flags |= Nc;
      var l = {
        getSnapshot: t,
        value: o
      }, f = an.updateQueue;
      if (f === null)
        f = Zk(), an.updateQueue = f, f.stores = [l];
      else {
        var m = f.stores;
        m === null ? f.stores = [l] : m.push(l);
      }
    }
    function eR(e, t, o, l) {
      t.value = o, t.getSnapshot = l, nR(t) && rR(e);
    }
    function tR(e, t, o) {
      var l = function() {
        nR(t) && rR(e);
      };
      return o(l);
    }
    function nR(e) {
      var t = e.getSnapshot, o = e.value;
      try {
        var l = t();
        return !Pe(o, l);
      } catch {
        return !0;
      }
    }
    function rR(e) {
      var t = Ei(e, Ze);
      t !== null && Vr(t, e, Ze, dn);
    }
    function T0(e) {
      var t = $s();
      typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e;
      var o = {
        pending: null,
        interleaved: null,
        lanes: oe,
        dispatch: null,
        lastRenderedReducer: Bx,
        lastRenderedState: e
      };
      t.queue = o;
      var l = o.dispatch = r$.bind(null, an, o);
      return [t.memoizedState, l];
    }
    function Yx(e) {
      return Ix(Bx);
    }
    function Gx(e) {
      return Hx(Bx);
    }
    function tv(e, t, o, l) {
      var f = {
        tag: e,
        create: t,
        destroy: o,
        deps: l,
        // Circular
        next: null
      }, m = an.updateQueue;
      if (m === null)
        m = Zk(), an.updateQueue = m, m.lastEffect = f.next = f;
      else {
        var g = m.lastEffect;
        if (g === null)
          m.lastEffect = f.next = f;
        else {
          var C = g.next;
          g.next = f, f.next = C, m.lastEffect = f;
        }
      }
      return f;
    }
    function qx(e) {
      var t = $s();
      {
        var o = {
          current: e
        };
        return t.memoizedState = o, o;
      }
    }
    function k0(e) {
      var t = fo();
      return t.memoizedState;
    }
    function nv(e, t, o, l) {
      var f = $s(), m = l === void 0 ? null : l;
      an.flags |= e, f.memoizedState = tv(Or | t, o, void 0, m);
    }
    function R0(e, t, o, l) {
      var f = fo(), m = l === void 0 ? null : l, g = void 0;
      if (Pr !== null) {
        var C = Pr.memoizedState;
        if (g = C.destroy, m !== null) {
          var T = C.deps;
          if (jx(m, T)) {
            f.memoizedState = tv(t, o, g, m);
            return;
          }
        }
      }
      an.flags |= e, f.memoizedState = tv(Or | t, o, g, m);
    }
    function _0(e, t) {
      return (an.mode & mi) !== Qe ? nv(fl | _n | gs, la, e, t) : nv(_n | gs, la, e, t);
    }
    function rv(e, t) {
      return R0(_n, la, e, t);
    }
    function Qx(e, t) {
      return nv(dt, Ls, e, t);
    }
    function D0(e, t) {
      return R0(dt, Ls, e, t);
    }
    function Kx(e, t) {
      var o = dt;
      return o |= Da, (an.mode & mi) !== Qe && (o |= Aa), nv(o, zr, e, t);
    }
    function A0(e, t) {
      return R0(dt, zr, e, t);
    }
    function aR(e, t) {
      if (typeof t == "function") {
        var o = t, l = e();
        return o(l), function() {
          o(null);
        };
      } else if (t != null) {
        var f = t;
        f.hasOwnProperty("current") || h("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(f).join(", ") + "}");
        var m = e();
        return f.current = m, function() {
          f.current = null;
        };
      }
    }
    function Xx(e, t, o) {
      typeof t != "function" && h("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var l = o != null ? o.concat([e]) : null, f = dt;
      return f |= Da, (an.mode & mi) !== Qe && (f |= Aa), nv(f, zr, aR.bind(null, t, e), l);
    }
    function M0(e, t, o) {
      typeof t != "function" && h("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var l = o != null ? o.concat([e]) : null;
      return R0(dt, zr, aR.bind(null, t, e), l);
    }
    function JL(e, t) {
    }
    var O0 = JL;
    function Zx(e, t) {
      var o = $s(), l = t === void 0 ? null : t;
      return o.memoizedState = [e, l], e;
    }
    function z0(e, t) {
      var o = fo(), l = t === void 0 ? null : t, f = o.memoizedState;
      if (f !== null && l !== null) {
        var m = f[1];
        if (jx(l, m))
          return f[0];
      }
      return o.memoizedState = [e, l], e;
    }
    function Jx(e, t) {
      var o = $s(), l = t === void 0 ? null : t, f = e();
      return o.memoizedState = [f, l], f;
    }
    function P0(e, t) {
      var o = fo(), l = t === void 0 ? null : t, f = o.memoizedState;
      if (f !== null && l !== null) {
        var m = f[1];
        if (jx(l, m))
          return f[0];
      }
      var g = e();
      return o.memoizedState = [g, l], g;
    }
    function eC(e) {
      var t = $s();
      return t.memoizedState = e, e;
    }
    function iR(e) {
      var t = fo(), o = Pr, l = o.memoizedState;
      return sR(t, l, e);
    }
    function oR(e) {
      var t = fo();
      if (Pr === null)
        return t.memoizedState = e, e;
      var o = Pr.memoizedState;
      return sR(t, o, e);
    }
    function sR(e, t, o) {
      var l = !o1(vf);
      if (l) {
        if (!Pe(o, t)) {
          var f = am();
          an.lanes = pt(an.lanes, f), bv(f), e.baseState = !0;
        }
        return t;
      } else
        return e.baseState && (e.baseState = !1, sv()), e.memoizedState = o, o;
    }
    function e$(e, t, o) {
      var l = gi();
      sr(Qr(l, Mr)), e(!0);
      var f = Zm.transition;
      Zm.transition = {};
      var m = Zm.transition;
      Zm.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), t();
      } finally {
        if (sr(l), Zm.transition = f, f === null && m._updatedFibers) {
          var g = m._updatedFibers.size;
          g > 10 && v("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), m._updatedFibers.clear();
        }
      }
    }
    function tC() {
      var e = T0(!1), t = e[0], o = e[1], l = e$.bind(null, o), f = $s();
      return f.memoizedState = l, [t, l];
    }
    function lR() {
      var e = Yx(), t = e[0], o = fo(), l = o.memoizedState;
      return [t, l];
    }
    function uR() {
      var e = Gx(), t = e[0], o = fo(), l = o.memoizedState;
      return [t, l];
    }
    var cR = !1;
    function t$() {
      return cR;
    }
    function nC() {
      var e = $s(), t = eb(), o = t.identifierPrefix, l;
      if (sa()) {
        var f = mL();
        l = ":" + o + "R" + f;
        var m = ev++;
        m > 0 && (l += "H" + m.toString(32)), l += ":";
      } else {
        var g = KL++;
        l = ":" + o + "r" + g.toString(32) + ":";
      }
      return e.memoizedState = l, l;
    }
    function L0() {
      var e = fo(), t = e.memoizedState;
      return t;
    }
    function n$(e, t, o) {
      typeof arguments[3] == "function" && h("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var l = ec(e), f = {
        lane: l,
        action: o,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (fR(e))
        dR(t, f);
      else {
        var m = Dk(e, t, f, l);
        if (m !== null) {
          var g = ti();
          Vr(m, e, l, g), pR(m, t, l);
        }
      }
      hR(e, l);
    }
    function r$(e, t, o) {
      typeof arguments[3] == "function" && h("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var l = ec(e), f = {
        lane: l,
        action: o,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (fR(e))
        dR(t, f);
      else {
        var m = e.alternate;
        if (e.lanes === oe && (m === null || m.lanes === oe)) {
          var g = t.lastRenderedReducer;
          if (g !== null) {
            var C;
            C = ke.current, ke.current = Qo;
            try {
              var T = t.lastRenderedState, D = g(T, o);
              if (f.hasEagerState = !0, f.eagerState = D, Pe(D, T)) {
                LL(e, t, f, l);
                return;
              }
            } catch {
            } finally {
              ke.current = C;
            }
          }
        }
        var M = Dk(e, t, f, l);
        if (M !== null) {
          var U = ti();
          Vr(M, e, l, U), pR(M, t, l);
        }
      }
      hR(e, l);
    }
    function fR(e) {
      var t = e.alternate;
      return e === an || t !== null && t === an;
    }
    function dR(e, t) {
      Jm = E0 = !0;
      var o = e.pending;
      o === null ? t.next = t : (t.next = o.next, o.next = t), e.pending = t;
    }
    function pR(e, t, o) {
      if (rm(o)) {
        var l = t.lanes;
        l = im(l, e.pendingLanes);
        var f = pt(l, o);
        t.lanes = f, ku(e, f);
      }
    }
    function hR(e, t, o) {
      ws(e, t);
    }
    var $0 = {
      readContext: Er,
      useCallback: Fa,
      useContext: Fa,
      useEffect: Fa,
      useImperativeHandle: Fa,
      useInsertionEffect: Fa,
      useLayoutEffect: Fa,
      useMemo: Fa,
      useReducer: Fa,
      useRef: Fa,
      useState: Fa,
      useDebugValue: Fa,
      useDeferredValue: Fa,
      useTransition: Fa,
      useMutableSource: Fa,
      useSyncExternalStore: Fa,
      useId: Fa,
      unstable_isNewReconciler: he
    }, mR = null, vR = null, yR = null, gR = null, Ns = null, Qo = null, N0 = null;
    {
      var rC = function() {
        h("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, lt = function() {
        h("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      mR = {
        readContext: function(e) {
          return Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", Kt(), Ep(t), Zx(e, t);
        },
        useContext: function(e) {
          return se = "useContext", Kt(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", Kt(), Ep(t), _0(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", Kt(), Ep(o), Xx(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", Kt(), Ep(t), Qx(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", Kt(), Ep(t), Kx(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", Kt(), Ep(t);
          var o = ke.current;
          ke.current = Ns;
          try {
            return Jx(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", Kt();
          var l = ke.current;
          ke.current = Ns;
          try {
            return Ux(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", Kt(), qx(e);
        },
        useState: function(e) {
          se = "useState", Kt();
          var t = ke.current;
          ke.current = Ns;
          try {
            return T0(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", Kt(), void 0;
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", Kt(), eC(e);
        },
        useTransition: function() {
          return se = "useTransition", Kt(), tC();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", Kt(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", Kt(), Wx(e, t, o);
        },
        useId: function() {
          return se = "useId", Kt(), nC();
        },
        unstable_isNewReconciler: he
      }, vR = {
        readContext: function(e) {
          return Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", xe(), Zx(e, t);
        },
        useContext: function(e) {
          return se = "useContext", xe(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", xe(), _0(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", xe(), Xx(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", xe(), Qx(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", xe(), Kx(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", xe();
          var o = ke.current;
          ke.current = Ns;
          try {
            return Jx(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", xe();
          var l = ke.current;
          ke.current = Ns;
          try {
            return Ux(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", xe(), qx(e);
        },
        useState: function(e) {
          se = "useState", xe();
          var t = ke.current;
          ke.current = Ns;
          try {
            return T0(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", xe(), void 0;
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", xe(), eC(e);
        },
        useTransition: function() {
          return se = "useTransition", xe(), tC();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", xe(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", xe(), Wx(e, t, o);
        },
        useId: function() {
          return se = "useId", xe(), nC();
        },
        unstable_isNewReconciler: he
      }, yR = {
        readContext: function(e) {
          return Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", xe(), z0(e, t);
        },
        useContext: function(e) {
          return se = "useContext", xe(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", xe(), rv(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", xe(), M0(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", xe(), D0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", xe(), A0(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", xe();
          var o = ke.current;
          ke.current = Qo;
          try {
            return P0(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", xe();
          var l = ke.current;
          ke.current = Qo;
          try {
            return Ix(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", xe(), k0();
        },
        useState: function(e) {
          se = "useState", xe();
          var t = ke.current;
          ke.current = Qo;
          try {
            return Yx(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", xe(), O0();
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", xe(), iR(e);
        },
        useTransition: function() {
          return se = "useTransition", xe(), lR();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", xe(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", xe(), w0(e, t);
        },
        useId: function() {
          return se = "useId", xe(), L0();
        },
        unstable_isNewReconciler: he
      }, gR = {
        readContext: function(e) {
          return Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", xe(), z0(e, t);
        },
        useContext: function(e) {
          return se = "useContext", xe(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", xe(), rv(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", xe(), M0(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", xe(), D0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", xe(), A0(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", xe();
          var o = ke.current;
          ke.current = N0;
          try {
            return P0(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", xe();
          var l = ke.current;
          ke.current = N0;
          try {
            return Hx(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", xe(), k0();
        },
        useState: function(e) {
          se = "useState", xe();
          var t = ke.current;
          ke.current = N0;
          try {
            return Gx(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", xe(), O0();
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", xe(), oR(e);
        },
        useTransition: function() {
          return se = "useTransition", xe(), uR();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", xe(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", xe(), w0(e, t);
        },
        useId: function() {
          return se = "useId", xe(), L0();
        },
        unstable_isNewReconciler: he
      }, Ns = {
        readContext: function(e) {
          return rC(), Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", lt(), Kt(), Zx(e, t);
        },
        useContext: function(e) {
          return se = "useContext", lt(), Kt(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", lt(), Kt(), _0(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", lt(), Kt(), Xx(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", lt(), Kt(), Qx(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", lt(), Kt(), Kx(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", lt(), Kt();
          var o = ke.current;
          ke.current = Ns;
          try {
            return Jx(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", lt(), Kt();
          var l = ke.current;
          ke.current = Ns;
          try {
            return Ux(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", lt(), Kt(), qx(e);
        },
        useState: function(e) {
          se = "useState", lt(), Kt();
          var t = ke.current;
          ke.current = Ns;
          try {
            return T0(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", lt(), Kt(), void 0;
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", lt(), Kt(), eC(e);
        },
        useTransition: function() {
          return se = "useTransition", lt(), Kt(), tC();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", lt(), Kt(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", lt(), Kt(), Wx(e, t, o);
        },
        useId: function() {
          return se = "useId", lt(), Kt(), nC();
        },
        unstable_isNewReconciler: he
      }, Qo = {
        readContext: function(e) {
          return rC(), Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", lt(), xe(), z0(e, t);
        },
        useContext: function(e) {
          return se = "useContext", lt(), xe(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", lt(), xe(), rv(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", lt(), xe(), M0(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", lt(), xe(), D0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", lt(), xe(), A0(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", lt(), xe();
          var o = ke.current;
          ke.current = Qo;
          try {
            return P0(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", lt(), xe();
          var l = ke.current;
          ke.current = Qo;
          try {
            return Ix(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", lt(), xe(), k0();
        },
        useState: function(e) {
          se = "useState", lt(), xe();
          var t = ke.current;
          ke.current = Qo;
          try {
            return Yx(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", lt(), xe(), O0();
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", lt(), xe(), iR(e);
        },
        useTransition: function() {
          return se = "useTransition", lt(), xe(), lR();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", lt(), xe(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", lt(), xe(), w0(e, t);
        },
        useId: function() {
          return se = "useId", lt(), xe(), L0();
        },
        unstable_isNewReconciler: he
      }, N0 = {
        readContext: function(e) {
          return rC(), Er(e);
        },
        useCallback: function(e, t) {
          return se = "useCallback", lt(), xe(), z0(e, t);
        },
        useContext: function(e) {
          return se = "useContext", lt(), xe(), Er(e);
        },
        useEffect: function(e, t) {
          return se = "useEffect", lt(), xe(), rv(e, t);
        },
        useImperativeHandle: function(e, t, o) {
          return se = "useImperativeHandle", lt(), xe(), M0(e, t, o);
        },
        useInsertionEffect: function(e, t) {
          return se = "useInsertionEffect", lt(), xe(), D0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return se = "useLayoutEffect", lt(), xe(), A0(e, t);
        },
        useMemo: function(e, t) {
          se = "useMemo", lt(), xe();
          var o = ke.current;
          ke.current = Qo;
          try {
            return P0(e, t);
          } finally {
            ke.current = o;
          }
        },
        useReducer: function(e, t, o) {
          se = "useReducer", lt(), xe();
          var l = ke.current;
          ke.current = Qo;
          try {
            return Hx(e, t, o);
          } finally {
            ke.current = l;
          }
        },
        useRef: function(e) {
          return se = "useRef", lt(), xe(), k0();
        },
        useState: function(e) {
          se = "useState", lt(), xe();
          var t = ke.current;
          ke.current = Qo;
          try {
            return Gx(e);
          } finally {
            ke.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return se = "useDebugValue", lt(), xe(), O0();
        },
        useDeferredValue: function(e) {
          return se = "useDeferredValue", lt(), xe(), oR(e);
        },
        useTransition: function() {
          return se = "useTransition", lt(), xe(), uR();
        },
        useMutableSource: function(e, t, o) {
          return se = "useMutableSource", lt(), xe(), void 0;
        },
        useSyncExternalStore: function(e, t, o) {
          return se = "useSyncExternalStore", lt(), xe(), w0(e, t);
        },
        useId: function() {
          return se = "useId", lt(), xe(), L0();
        },
        unstable_isNewReconciler: he
      };
    }
    var Ku = a.unstable_now, bR = 0, F0 = -1, av = -1, V0 = -1, aC = !1, j0 = !1;
    function SR() {
      return aC;
    }
    function a$() {
      j0 = !0;
    }
    function i$() {
      aC = !1, j0 = !1;
    }
    function o$() {
      aC = j0, j0 = !1;
    }
    function xR() {
      return bR;
    }
    function CR() {
      bR = Ku();
    }
    function iC(e) {
      av = Ku(), e.actualStartTime < 0 && (e.actualStartTime = Ku());
    }
    function ER(e) {
      av = -1;
    }
    function B0(e, t) {
      if (av >= 0) {
        var o = Ku() - av;
        e.actualDuration += o, t && (e.selfBaseDuration = o), av = -1;
      }
    }
    function Fs(e) {
      if (F0 >= 0) {
        var t = Ku() - F0;
        F0 = -1;
        for (var o = e.return; o !== null; ) {
          switch (o.tag) {
            case k:
              var l = o.stateNode;
              l.effectDuration += t;
              return;
            case ne:
              var f = o.stateNode;
              f.effectDuration += t;
              return;
          }
          o = o.return;
        }
      }
    }
    function oC(e) {
      if (V0 >= 0) {
        var t = Ku() - V0;
        V0 = -1;
        for (var o = e.return; o !== null; ) {
          switch (o.tag) {
            case k:
              var l = o.stateNode;
              l !== null && (l.passiveEffectDuration += t);
              return;
            case ne:
              var f = o.stateNode;
              f !== null && (f.passiveEffectDuration += t);
              return;
          }
          o = o.return;
        }
      }
    }
    function Vs() {
      F0 = Ku();
    }
    function sC() {
      V0 = Ku();
    }
    function lC(e) {
      for (var t = e.child; t; )
        e.actualDuration += t.actualDuration, t = t.sibling;
    }
    function yf(e, t) {
      return {
        value: e,
        source: t,
        stack: iu(t),
        digest: null
      };
    }
    function uC(e, t, o) {
      return {
        value: e,
        source: null,
        stack: o ?? null,
        digest: t ?? null
      };
    }
    function s$(e, t) {
      return !0;
    }
    function cC(e, t) {
      try {
        var o = s$(e, t);
        if (o === !1)
          return;
        var l = t.value, f = t.source, m = t.stack, g = m !== null ? m : "";
        if (l != null && l._suppressLogging) {
          if (e.tag === E)
            return;
          console.error(l);
        }
        var C = f ? st(f) : null, T = C ? "The above error occurred in the <" + C + "> component:" : "The above error occurred in one of your React components:", D;
        if (e.tag === k)
          D = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var M = st(e) || "Anonymous";
          D = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + M + ".");
        }
        var U = T + `
` + g + `

` + ("" + D);
        console.error(U);
      } catch (V) {
        setTimeout(function() {
          throw V;
        });
      }
    }
    var l$ = typeof WeakMap == "function" ? WeakMap : Map;
    function wR(e, t, o) {
      var l = Nl(dn, o);
      l.tag = cx, l.payload = {
        element: null
      };
      var f = t.value;
      return l.callback = function() {
        e3(f), cC(e, t);
      }, l;
    }
    function fC(e, t, o) {
      var l = Nl(dn, o);
      l.tag = cx;
      var f = e.type.getDerivedStateFromError;
      if (typeof f == "function") {
        var m = t.value;
        l.payload = function() {
          return f(m);
        }, l.callback = function() {
          L_(e), cC(e, t);
        };
      }
      var g = e.stateNode;
      return g !== null && typeof g.componentDidCatch == "function" && (l.callback = function() {
        L_(e), cC(e, t), typeof f != "function" && ZN(this);
        var T = t.value, D = t.stack;
        this.componentDidCatch(T, {
          componentStack: D !== null ? D : ""
        }), typeof f != "function" && (La(e.lanes, Ze) || h("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", st(e) || "Unknown"));
      }), l;
    }
    function TR(e, t, o) {
      var l = e.pingCache, f;
      if (l === null ? (l = e.pingCache = new l$(), f = /* @__PURE__ */ new Set(), l.set(t, f)) : (f = l.get(t), f === void 0 && (f = /* @__PURE__ */ new Set(), l.set(t, f))), !f.has(o)) {
        f.add(o);
        var m = t3.bind(null, e, t, o);
        Ar && Sv(e, o), t.then(m, m);
      }
    }
    function u$(e, t, o, l) {
      var f = e.updateQueue;
      if (f === null) {
        var m = /* @__PURE__ */ new Set();
        m.add(o), e.updateQueue = m;
      } else
        f.add(o);
    }
    function c$(e, t) {
      var o = e.tag;
      if ((e.mode & xt) === Qe && (o === x || o === F || o === re)) {
        var l = e.alternate;
        l ? (e.updateQueue = l.updateQueue, e.memoizedState = l.memoizedState, e.lanes = l.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function kR(e) {
      var t = e;
      do {
        if (t.tag === H && qL(t))
          return t;
        t = t.return;
      } while (t !== null);
      return null;
    }
    function RR(e, t, o, l, f) {
      if ((e.mode & xt) === Qe) {
        if (e === t)
          e.flags |= gr;
        else {
          if (e.flags |= rt, o.flags |= Fc, o.flags &= ~(cd | Ga), o.tag === E) {
            var m = o.alternate;
            if (m === null)
              o.tag = Fe;
            else {
              var g = Nl(dn, Ze);
              g.tag = f0, Yu(o, g, Ze);
            }
          }
          o.lanes = pt(o.lanes, Ze);
        }
        return e;
      }
      return e.flags |= gr, e.lanes = f, e;
    }
    function f$(e, t, o, l, f) {
      if (o.flags |= Ga, Ar && Sv(e, f), l !== null && typeof l == "object" && typeof l.then == "function") {
        var m = l;
        c$(o), sa() && o.mode & xt && yk();
        var g = kR(t);
        if (g !== null) {
          g.flags &= ~Un, RR(g, t, o, e, f), g.mode & xt && TR(e, m, f), u$(g, e, m);
          return;
        } else {
          if (!wu(f)) {
            TR(e, m, f), HC();
            return;
          }
          var C = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          l = C;
        }
      } else if (sa() && o.mode & xt) {
        yk();
        var T = kR(t);
        if (T !== null) {
          (T.flags & gr) === We && (T.flags |= Un), RR(T, t, o, e, f), rx(yf(l, o));
          return;
        }
      }
      l = yf(l, o), HN(l);
      var D = t;
      do {
        switch (D.tag) {
          case k: {
            var M = l;
            D.flags |= gr;
            var U = or(f);
            D.lanes = pt(D.lanes, U);
            var V = wR(D, M, U);
            px(D, V);
            return;
          }
          case E:
            var Z = l, J = D.type, ae = D.stateNode;
            if ((D.flags & rt) === We && (typeof J.getDerivedStateFromError == "function" || ae !== null && typeof ae.componentDidCatch == "function" && !k_(ae))) {
              D.flags |= gr;
              var Re = or(f);
              D.lanes = pt(D.lanes, Re);
              var qe = fC(D, Z, Re);
              px(D, qe);
              return;
            }
            break;
        }
        D = D.return;
      } while (D !== null);
    }
    function d$() {
      return null;
    }
    var iv = s.ReactCurrentOwner, Ko = !1, dC, ov, pC, hC, mC, gf, vC, U0;
    dC = {}, ov = {}, pC = {}, hC = {}, mC = {}, gf = !1, vC = {}, U0 = {};
    function Ja(e, t, o, l) {
      e === null ? t.child = Wk(t, null, o, l) : t.child = gp(t, e.child, o, l);
    }
    function p$(e, t, o, l) {
      t.child = gp(t, e.child, null, l), t.child = gp(t, null, o, l);
    }
    function _R(e, t, o, l, f) {
      if (t.type !== t.elementType) {
        var m = o.propTypes;
        m && Ho(
          m,
          l,
          // Resolved props
          "prop",
          Zt(o)
        );
      }
      var g = o.render, C = t.ref, T, D;
      yp(t, f), Es(t);
      {
        if (iv.current = t, Ta(!0), T = wp(e, t, g, l, C, f), D = Tp(), t.mode & Pn) {
          ir(!0);
          try {
            T = wp(e, t, g, l, C, f), D = Tp();
          } finally {
            ir(!1);
          }
        }
        Ta(!1);
      }
      return dl(), e !== null && !Ko ? (Kk(e, t, f), Fl(e, t, f)) : (sa() && D && X1(t), t.flags |= vs, Ja(e, t, T, f), t.child);
    }
    function DR(e, t, o, l, f) {
      if (e === null) {
        var m = o.type;
        if (g3(m) && o.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        o.defaultProps === void 0) {
          var g = m;
          return g = zp(m), t.tag = re, t.type = g, bC(t, m), AR(e, t, g, l, f);
        }
        {
          var C = m.propTypes;
          C && Ho(
            C,
            l,
            // Resolved props
            "prop",
            Zt(m)
          );
        }
        var T = tE(o.type, null, l, t, t.mode, f);
        return T.ref = t.ref, T.return = t, t.child = T, T;
      }
      {
        var D = o.type, M = D.propTypes;
        M && Ho(
          M,
          l,
          // Resolved props
          "prop",
          Zt(D)
        );
      }
      var U = e.child, V = TC(e, f);
      if (!V) {
        var Z = U.memoizedProps, J = o.compare;
        if (J = J !== null ? J : Ie, J(Z, l) && e.ref === t.ref)
          return Fl(e, t, f);
      }
      t.flags |= vs;
      var ae = Ef(U, l);
      return ae.ref = t.ref, ae.return = t, t.child = ae, ae;
    }
    function AR(e, t, o, l, f) {
      if (t.type !== t.elementType) {
        var m = t.elementType;
        if (m.$$typeof === Ge) {
          var g = m, C = g._payload, T = g._init;
          try {
            m = T(C);
          } catch {
            m = null;
          }
          var D = m && m.propTypes;
          D && Ho(
            D,
            l,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Zt(m)
          );
        }
      }
      if (e !== null) {
        var M = e.memoizedProps;
        if (Ie(M, l) && e.ref === t.ref && // Prevent bailout if the implementation changed due to hot reload.
        t.type === e.type)
          if (Ko = !1, t.pendingProps = l = M, TC(e, f))
            (e.flags & Fc) !== We && (Ko = !0);
          else
            return t.lanes = e.lanes, Fl(e, t, f);
      }
      return yC(e, t, o, l, f);
    }
    function MR(e, t, o) {
      var l = t.pendingProps, f = l.children, m = e !== null ? e.memoizedState : null;
      if (l.mode === "hidden" || ve)
        if ((t.mode & xt) === Qe) {
          var g = {
            baseLanes: oe,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = g, tb(t, o);
        } else if (La(o, Pa)) {
          var U = {
            baseLanes: oe,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = U;
          var V = m !== null ? m.baseLanes : o;
          tb(t, V);
        } else {
          var C = null, T;
          if (m !== null) {
            var D = m.baseLanes;
            T = pt(D, o);
          } else
            T = o;
          t.lanes = t.childLanes = Pa;
          var M = {
            baseLanes: T,
            cachePool: C,
            transitions: null
          };
          return t.memoizedState = M, t.updateQueue = null, tb(t, T), null;
        }
      else {
        var Z;
        m !== null ? (Z = pt(m.baseLanes, o), t.memoizedState = null) : Z = o, tb(t, Z);
      }
      return Ja(e, t, f, o), t.child;
    }
    function h$(e, t, o) {
      var l = t.pendingProps;
      return Ja(e, t, l, o), t.child;
    }
    function m$(e, t, o) {
      var l = t.pendingProps.children;
      return Ja(e, t, l, o), t.child;
    }
    function v$(e, t, o) {
      {
        t.flags |= dt;
        {
          var l = t.stateNode;
          l.effectDuration = 0, l.passiveEffectDuration = 0;
        }
      }
      var f = t.pendingProps, m = f.children;
      return Ja(e, t, m, o), t.child;
    }
    function OR(e, t) {
      var o = t.ref;
      (e === null && o !== null || e !== null && e.ref !== o) && (t.flags |= _a, t.flags |= Uh);
    }
    function yC(e, t, o, l, f) {
      if (t.type !== t.elementType) {
        var m = o.propTypes;
        m && Ho(
          m,
          l,
          // Resolved props
          "prop",
          Zt(o)
        );
      }
      var g;
      {
        var C = fp(t, o, !0);
        g = dp(t, C);
      }
      var T, D;
      yp(t, f), Es(t);
      {
        if (iv.current = t, Ta(!0), T = wp(e, t, o, l, g, f), D = Tp(), t.mode & Pn) {
          ir(!0);
          try {
            T = wp(e, t, o, l, g, f), D = Tp();
          } finally {
            ir(!1);
          }
        }
        Ta(!1);
      }
      return dl(), e !== null && !Ko ? (Kk(e, t, f), Fl(e, t, f)) : (sa() && D && X1(t), t.flags |= vs, Ja(e, t, T, f), t.child);
    }
    function zR(e, t, o, l, f) {
      {
        switch (z3(t)) {
          case !1: {
            var m = t.stateNode, g = t.type, C = new g(t.memoizedProps, m.context), T = C.state;
            m.updater.enqueueSetState(m, T, null);
            break;
          }
          case !0: {
            t.flags |= rt, t.flags |= gr;
            var D = new Error("Simulated error coming from DevTools"), M = or(f);
            t.lanes = pt(t.lanes, M);
            var U = fC(t, yf(D, t), M);
            px(t, U);
            break;
          }
        }
        if (t.type !== t.elementType) {
          var V = o.propTypes;
          V && Ho(
            V,
            l,
            // Resolved props
            "prop",
            Zt(o)
          );
        }
      }
      var Z;
      Ps(o) ? (Z = !0, e0(t)) : Z = !1, yp(t, f);
      var J = t.stateNode, ae;
      J === null ? (H0(e, t), jk(t, o, l), Tx(t, o, l, f), ae = !0) : e === null ? ae = UL(t, o, l, f) : ae = IL(e, t, o, l, f);
      var Re = gC(e, t, o, ae, Z, f);
      {
        var qe = t.stateNode;
        ae && qe.props !== l && (gf || h("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", st(t) || "a component"), gf = !0);
      }
      return Re;
    }
    function gC(e, t, o, l, f, m) {
      OR(e, t);
      var g = (t.flags & rt) !== We;
      if (!l && !g)
        return f && pk(t, o, !1), Fl(e, t, m);
      var C = t.stateNode;
      iv.current = t;
      var T;
      if (g && typeof o.getDerivedStateFromError != "function")
        T = null, ER();
      else {
        Es(t);
        {
          if (Ta(!0), T = C.render(), t.mode & Pn) {
            ir(!0);
            try {
              C.render();
            } finally {
              ir(!1);
            }
          }
          Ta(!1);
        }
        dl();
      }
      return t.flags |= vs, e !== null && g ? p$(e, t, T, m) : Ja(e, t, T, m), t.memoizedState = C.state, f && pk(t, o, !0), t.child;
    }
    function PR(e) {
      var t = e.stateNode;
      t.pendingContext ? fk(e, t.pendingContext, t.pendingContext !== t.context) : t.context && fk(e, t.context, !1), Mx(e, t.containerInfo);
    }
    function y$(e, t, o) {
      if (PR(t), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var l = t.pendingProps, f = t.memoizedState, m = f.element;
      Ok(e, t), m0(t, l, null, o);
      var g = t.memoizedState;
      t.stateNode;
      var C = g.element;
      if (f.isDehydrated) {
        var T = {
          element: C,
          isDehydrated: !1,
          cache: g.cache,
          pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
          transitions: g.transitions
        }, D = t.updateQueue;
        if (D.baseState = T, t.memoizedState = T, t.flags & Un) {
          var M = yf(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), t);
          return LR(e, t, C, o, M);
        } else if (C !== m) {
          var U = yf(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), t);
          return LR(e, t, C, o, U);
        } else {
          xL(t);
          var V = Wk(t, null, C, o);
          t.child = V;
          for (var Z = V; Z; )
            Z.flags = Z.flags & ~xn | di, Z = Z.sibling;
        }
      } else {
        if (mp(), C === m)
          return Fl(e, t, o);
        Ja(e, t, C, o);
      }
      return t.child;
    }
    function LR(e, t, o, l, f) {
      return mp(), rx(f), t.flags |= Un, Ja(e, t, o, l), t.child;
    }
    function g$(e, t, o) {
      Gk(t), e === null && nx(t);
      var l = t.type, f = t.pendingProps, m = e !== null ? e.memoizedProps : null, g = f.children, C = N1(l, f);
      return C ? g = null : m !== null && N1(l, m) && (t.flags |= Qt), OR(e, t), Ja(e, t, g, o), t.child;
    }
    function b$(e, t) {
      return e === null && nx(t), null;
    }
    function S$(e, t, o, l) {
      H0(e, t);
      var f = t.pendingProps, m = o, g = m._payload, C = m._init, T = C(g);
      t.type = T;
      var D = t.tag = b3(T), M = Go(T, f), U;
      switch (D) {
        case x:
          return bC(t, T), t.type = T = zp(T), U = yC(null, t, T, M, l), U;
        case E:
          return t.type = T = QC(T), U = zR(null, t, T, M, l), U;
        case F:
          return t.type = T = KC(T), U = _R(null, t, T, M, l), U;
        case le: {
          if (t.type !== t.elementType) {
            var V = T.propTypes;
            V && Ho(
              V,
              M,
              // Resolved for outer only
              "prop",
              Zt(T)
            );
          }
          return U = DR(
            null,
            t,
            T,
            Go(T.type, M),
            // The inner type can have defaults too
            l
          ), U;
        }
      }
      var Z = "";
      throw T !== null && typeof T == "object" && T.$$typeof === Ge && (Z = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + T + ". " + ("Lazy element type must resolve to a class or function." + Z));
    }
    function x$(e, t, o, l, f) {
      H0(e, t), t.tag = E;
      var m;
      return Ps(o) ? (m = !0, e0(t)) : m = !1, yp(t, f), jk(t, o, l), Tx(t, o, l, f), gC(null, t, o, !0, m, f);
    }
    function C$(e, t, o, l) {
      H0(e, t);
      var f = t.pendingProps, m;
      {
        var g = fp(t, o, !1);
        m = dp(t, g);
      }
      yp(t, l);
      var C, T;
      Es(t);
      {
        if (o.prototype && typeof o.prototype.render == "function") {
          var D = Zt(o) || "Unknown";
          dC[D] || (h("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", D, D), dC[D] = !0);
        }
        t.mode & Pn && Yo.recordLegacyContextWarning(t, null), Ta(!0), iv.current = t, C = wp(null, t, o, f, m, l), T = Tp(), Ta(!1);
      }
      if (dl(), t.flags |= vs, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0) {
        var M = Zt(o) || "Unknown";
        ov[M] || (h("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", M, M, M), ov[M] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0
      ) {
        {
          var U = Zt(o) || "Unknown";
          ov[U] || (h("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", U, U, U), ov[U] = !0);
        }
        t.tag = E, t.memoizedState = null, t.updateQueue = null;
        var V = !1;
        return Ps(o) ? (V = !0, e0(t)) : V = !1, t.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, dx(t), Vk(t, C), Tx(t, o, f, l), gC(null, t, o, !0, V, l);
      } else {
        if (t.tag = x, t.mode & Pn) {
          ir(!0);
          try {
            C = wp(null, t, o, f, m, l), T = Tp();
          } finally {
            ir(!1);
          }
        }
        return sa() && T && X1(t), Ja(null, t, C, l), bC(t, o), t.child;
      }
    }
    function bC(e, t) {
      {
        if (t && t.childContextTypes && h("%s(...): childContextTypes cannot be defined on a function component.", t.displayName || t.name || "Component"), e.ref !== null) {
          var o = "", l = Wr();
          l && (o += `

Check the render method of \`` + l + "`.");
          var f = l || "", m = e._debugSource;
          m && (f = m.fileName + ":" + m.lineNumber), mC[f] || (mC[f] = !0, h("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", o));
        }
        if (typeof t.getDerivedStateFromProps == "function") {
          var g = Zt(t) || "Unknown";
          hC[g] || (h("%s: Function components do not support getDerivedStateFromProps.", g), hC[g] = !0);
        }
        if (typeof t.contextType == "object" && t.contextType !== null) {
          var C = Zt(t) || "Unknown";
          pC[C] || (h("%s: Function components do not support contextType.", C), pC[C] = !0);
        }
      }
    }
    var SC = {
      dehydrated: null,
      treeContext: null,
      retryLane: _t
    };
    function xC(e) {
      return {
        baseLanes: e,
        cachePool: d$(),
        transitions: null
      };
    }
    function E$(e, t) {
      var o = null;
      return {
        baseLanes: pt(e.baseLanes, t),
        cachePool: o,
        transitions: e.transitions
      };
    }
    function w$(e, t, o, l) {
      if (t !== null) {
        var f = t.memoizedState;
        if (f === null)
          return !1;
      }
      return Px(e, Xm);
    }
    function T$(e, t) {
      return Tu(e.childLanes, t);
    }
    function $R(e, t, o) {
      var l = t.pendingProps;
      P3(t) && (t.flags |= rt);
      var f = qo.current, m = !1, g = (t.flags & rt) !== We;
      if (g || w$(f, e) ? (m = !0, t.flags &= ~rt) : (e === null || e.memoizedState !== null) && (f = GL(f, Qk)), f = Sp(f), qu(t, f), e === null) {
        nx(t);
        var C = t.memoizedState;
        if (C !== null) {
          var T = C.dehydrated;
          if (T !== null)
            return A$(t, T);
        }
        var D = l.children, M = l.fallback;
        if (m) {
          var U = k$(t, D, M, o), V = t.child;
          return V.memoizedState = xC(o), t.memoizedState = SC, U;
        } else
          return CC(t, D);
      } else {
        var Z = e.memoizedState;
        if (Z !== null) {
          var J = Z.dehydrated;
          if (J !== null)
            return M$(e, t, g, l, J, Z, o);
        }
        if (m) {
          var ae = l.fallback, Re = l.children, qe = _$(e, t, Re, ae, o), je = t.child, At = e.child.memoizedState;
          return je.memoizedState = At === null ? xC(o) : E$(At, o), je.childLanes = T$(e, o), t.memoizedState = SC, qe;
        } else {
          var Tt = l.children, q = R$(e, t, Tt, o);
          return t.memoizedState = null, q;
        }
      }
    }
    function CC(e, t, o) {
      var l = e.mode, f = {
        mode: "visible",
        children: t
      }, m = EC(f, l);
      return m.return = e, e.child = m, m;
    }
    function k$(e, t, o, l) {
      var f = e.mode, m = e.child, g = {
        mode: "hidden",
        children: t
      }, C, T;
      return (f & xt) === Qe && m !== null ? (C = m, C.childLanes = oe, C.pendingProps = g, e.mode & Xe && (C.actualDuration = 0, C.actualStartTime = -1, C.selfBaseDuration = 0, C.treeBaseDuration = 0), T = nc(o, f, l, null)) : (C = EC(g, f), T = nc(o, f, l, null)), C.return = e, T.return = e, C.sibling = T, e.child = C, T;
    }
    function EC(e, t, o) {
      return N_(e, t, oe, null);
    }
    function NR(e, t) {
      return Ef(e, t);
    }
    function R$(e, t, o, l) {
      var f = e.child, m = f.sibling, g = NR(f, {
        mode: "visible",
        children: o
      });
      if ((t.mode & xt) === Qe && (g.lanes = l), g.return = t, g.sibling = null, m !== null) {
        var C = t.deletions;
        C === null ? (t.deletions = [m], t.flags |= Yt) : C.push(m);
      }
      return t.child = g, g;
    }
    function _$(e, t, o, l, f) {
      var m = t.mode, g = e.child, C = g.sibling, T = {
        mode: "hidden",
        children: o
      }, D;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (m & xt) === Qe && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        t.child !== g
      ) {
        var M = t.child;
        D = M, D.childLanes = oe, D.pendingProps = T, t.mode & Xe && (D.actualDuration = 0, D.actualStartTime = -1, D.selfBaseDuration = g.selfBaseDuration, D.treeBaseDuration = g.treeBaseDuration), t.deletions = null;
      } else
        D = NR(g, T), D.subtreeFlags = g.subtreeFlags & Dr;
      var U;
      return C !== null ? U = Ef(C, l) : (U = nc(l, m, f, null), U.flags |= xn), U.return = t, D.return = t, D.sibling = U, t.child = D, U;
    }
    function I0(e, t, o, l) {
      l !== null && rx(l), gp(t, e.child, null, o);
      var f = t.pendingProps, m = f.children, g = CC(t, m);
      return g.flags |= xn, t.memoizedState = null, g;
    }
    function D$(e, t, o, l, f) {
      var m = t.mode, g = {
        mode: "visible",
        children: o
      }, C = EC(g, m), T = nc(l, m, f, null);
      return T.flags |= xn, C.return = t, T.return = t, C.sibling = T, t.child = C, (t.mode & xt) !== Qe && gp(t, e.child, null, f), T;
    }
    function A$(e, t, o) {
      return (e.mode & xt) === Qe ? (h("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = Ze) : B1(t) ? e.lanes = ml : e.lanes = Pa, null;
    }
    function M$(e, t, o, l, f, m, g) {
      if (o)
        if (t.flags & Un) {
          t.flags &= ~Un;
          var q = uC(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return I0(e, t, g, q);
        } else {
          if (t.memoizedState !== null)
            return t.child = e.child, t.flags |= rt, null;
          var ie = l.children, Q = l.fallback, pe = D$(e, t, ie, Q, g), _e = t.child;
          return _e.memoizedState = xC(g), t.memoizedState = SC, pe;
        }
      else {
        if (bL(), (t.mode & xt) === Qe)
          return I0(
            e,
            t,
            g,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (B1(f)) {
          var C, T, D;
          {
            var M = $5(f);
            C = M.digest, T = M.message, D = M.stack;
          }
          var U;
          T ? U = new Error(T) : U = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var V = uC(U, C, D);
          return I0(e, t, g, V);
        }
        var Z = La(g, e.childLanes);
        if (Ko || Z) {
          var J = eb();
          if (J !== null) {
            var ae = l1(J, g);
            if (ae !== _t && ae !== m.retryLane) {
              m.retryLane = ae;
              var Re = dn;
              Ei(e, ae), Vr(J, e, ae, Re);
            }
          }
          HC();
          var qe = uC(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return I0(e, t, g, qe);
        } else if (ik(f)) {
          t.flags |= rt, t.child = e.child;
          var je = n3.bind(null, e);
          return N5(f, je), null;
        } else {
          CL(t, f, m.treeContext);
          var At = l.children, Tt = CC(t, At);
          return Tt.flags |= di, Tt;
        }
      }
    }
    function FR(e, t, o) {
      e.lanes = pt(e.lanes, t);
      var l = e.alternate;
      l !== null && (l.lanes = pt(l.lanes, t)), lx(e.return, t, o);
    }
    function O$(e, t, o) {
      for (var l = t; l !== null; ) {
        if (l.tag === H) {
          var f = l.memoizedState;
          f !== null && FR(l, o, e);
        } else if (l.tag === vt)
          FR(l, o, e);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === e)
          return;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === e)
            return;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    function z$(e) {
      for (var t = e, o = null; t !== null; ) {
        var l = t.alternate;
        l !== null && C0(l) === null && (o = t), t = t.sibling;
      }
      return o;
    }
    function P$(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !vC[e])
        if (vC[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              h('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              h('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              h('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          h('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function L$(e, t) {
      e !== void 0 && !U0[e] && (e !== "collapsed" && e !== "hidden" ? (U0[e] = !0, h('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : t !== "forwards" && t !== "backwards" && (U0[e] = !0, h('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function VR(e, t) {
      {
        var o = vr(e), l = !o && typeof Pi(e) == "function";
        if (o || l) {
          var f = o ? "array" : "iterable";
          return h("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", f, t, f), !1;
        }
      }
      return !0;
    }
    function $$(e, t) {
      if ((t === "forwards" || t === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (vr(e)) {
          for (var o = 0; o < e.length; o++)
            if (!VR(e[o], o))
              return;
        } else {
          var l = Pi(e);
          if (typeof l == "function") {
            var f = l.call(e);
            if (f)
              for (var m = f.next(), g = 0; !m.done; m = f.next()) {
                if (!VR(m.value, g))
                  return;
                g++;
              }
          } else
            h('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', t);
        }
    }
    function wC(e, t, o, l, f) {
      var m = e.memoizedState;
      m === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: l,
        tail: o,
        tailMode: f
      } : (m.isBackwards = t, m.rendering = null, m.renderingStartTime = 0, m.last = l, m.tail = o, m.tailMode = f);
    }
    function jR(e, t, o) {
      var l = t.pendingProps, f = l.revealOrder, m = l.tail, g = l.children;
      P$(f), L$(m, f), $$(g, f), Ja(e, t, g, o);
      var C = qo.current, T = Px(C, Xm);
      if (T)
        C = Lx(C, Xm), t.flags |= rt;
      else {
        var D = e !== null && (e.flags & rt) !== We;
        D && O$(t, t.child, o), C = Sp(C);
      }
      if (qu(t, C), (t.mode & xt) === Qe)
        t.memoizedState = null;
      else
        switch (f) {
          case "forwards": {
            var M = z$(t.child), U;
            M === null ? (U = t.child, t.child = null) : (U = M.sibling, M.sibling = null), wC(
              t,
              !1,
              // isBackwards
              U,
              M,
              m
            );
            break;
          }
          case "backwards": {
            var V = null, Z = t.child;
            for (t.child = null; Z !== null; ) {
              var J = Z.alternate;
              if (J !== null && C0(J) === null) {
                t.child = Z;
                break;
              }
              var ae = Z.sibling;
              Z.sibling = V, V = Z, Z = ae;
            }
            wC(
              t,
              !0,
              // isBackwards
              V,
              null,
              // last
              m
            );
            break;
          }
          case "together": {
            wC(
              t,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            t.memoizedState = null;
        }
      return t.child;
    }
    function N$(e, t, o) {
      Mx(t, t.stateNode.containerInfo);
      var l = t.pendingProps;
      return e === null ? t.child = gp(t, null, l, o) : Ja(e, t, l, o), t.child;
    }
    var BR = !1;
    function F$(e, t, o) {
      var l = t.type, f = l._context, m = t.pendingProps, g = t.memoizedProps, C = m.value;
      {
        "value" in m || BR || (BR = !0, h("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var T = t.type.propTypes;
        T && Ho(T, m, "prop", "Context.Provider");
      }
      if (_k(t, f, C), g !== null) {
        var D = g.value;
        if (Pe(D, C)) {
          if (g.children === m.children && !Zg())
            return Fl(e, t, o);
        } else
          OL(t, f, o);
      }
      var M = m.children;
      return Ja(e, t, M, o), t.child;
    }
    var UR = !1;
    function V$(e, t, o) {
      var l = t.type;
      l._context === void 0 ? l !== l.Consumer && (UR || (UR = !0, h("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : l = l._context;
      var f = t.pendingProps, m = f.children;
      typeof m != "function" && h("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), yp(t, o);
      var g = Er(l);
      Es(t);
      var C;
      return iv.current = t, Ta(!0), C = m(g), Ta(!1), dl(), t.flags |= vs, Ja(e, t, C, o), t.child;
    }
    function sv() {
      Ko = !0;
    }
    function H0(e, t) {
      (t.mode & xt) === Qe && e !== null && (e.alternate = null, t.alternate = null, t.flags |= xn);
    }
    function Fl(e, t, o) {
      return e !== null && (t.dependencies = e.dependencies), ER(), bv(t.lanes), La(o, t.childLanes) ? (HL(e, t), t.child) : null;
    }
    function j$(e, t, o) {
      {
        var l = t.return;
        if (l === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, t.alternate = null, o.index = t.index, o.sibling = t.sibling, o.return = t.return, o.ref = t.ref, t === l.child)
          l.child = o;
        else {
          var f = l.child;
          if (f === null)
            throw new Error("Expected parent to have a child.");
          for (; f.sibling !== t; )
            if (f = f.sibling, f === null)
              throw new Error("Expected to find the previous sibling.");
          f.sibling = o;
        }
        var m = l.deletions;
        return m === null ? (l.deletions = [e], l.flags |= Yt) : m.push(e), o.flags |= xn, o;
      }
    }
    function TC(e, t) {
      var o = e.lanes;
      return !!La(o, t);
    }
    function B$(e, t, o) {
      switch (t.tag) {
        case k:
          PR(t), t.stateNode, mp();
          break;
        case A:
          Gk(t);
          break;
        case E: {
          var l = t.type;
          Ps(l) && e0(t);
          break;
        }
        case _:
          Mx(t, t.stateNode.containerInfo);
          break;
        case W: {
          var f = t.memoizedProps.value, m = t.type._context;
          _k(t, m, f);
          break;
        }
        case ne:
          {
            var g = La(o, t.childLanes);
            g && (t.flags |= dt);
            {
              var C = t.stateNode;
              C.effectDuration = 0, C.passiveEffectDuration = 0;
            }
          }
          break;
        case H: {
          var T = t.memoizedState;
          if (T !== null) {
            if (T.dehydrated !== null)
              return qu(t, Sp(qo.current)), t.flags |= rt, null;
            var D = t.child, M = D.childLanes;
            if (La(o, M))
              return $R(e, t, o);
            qu(t, Sp(qo.current));
            var U = Fl(e, t, o);
            return U !== null ? U.sibling : null;
          } else
            qu(t, Sp(qo.current));
          break;
        }
        case vt: {
          var V = (e.flags & rt) !== We, Z = La(o, t.childLanes);
          if (V) {
            if (Z)
              return jR(e, t, o);
            t.flags |= rt;
          }
          var J = t.memoizedState;
          if (J !== null && (J.rendering = null, J.tail = null, J.lastEffect = null), qu(t, qo.current), Z)
            break;
          return null;
        }
        case $e:
        case Be:
          return t.lanes = oe, MR(e, t, o);
      }
      return Fl(e, t, o);
    }
    function IR(e, t, o) {
      if (t._debugNeedsRemount && e !== null)
        return j$(e, t, tE(t.type, t.key, t.pendingProps, t._debugOwner || null, t.mode, t.lanes));
      if (e !== null) {
        var l = e.memoizedProps, f = t.pendingProps;
        if (l !== f || Zg() || // Force a re-render if the implementation changed due to hot reload:
        t.type !== e.type)
          Ko = !0;
        else {
          var m = TC(e, o);
          if (!m && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (t.flags & rt) === We)
            return Ko = !1, B$(e, t, o);
          (e.flags & Fc) !== We ? Ko = !0 : Ko = !1;
        }
      } else if (Ko = !1, sa() && pL(t)) {
        var g = t.index, C = hL();
        vk(t, C, g);
      }
      switch (t.lanes = oe, t.tag) {
        case w:
          return C$(e, t, t.type, o);
        case De: {
          var T = t.elementType;
          return S$(e, t, T, o);
        }
        case x: {
          var D = t.type, M = t.pendingProps, U = t.elementType === D ? M : Go(D, M);
          return yC(e, t, D, U, o);
        }
        case E: {
          var V = t.type, Z = t.pendingProps, J = t.elementType === V ? Z : Go(V, Z);
          return zR(e, t, V, J, o);
        }
        case k:
          return y$(e, t, o);
        case A:
          return g$(e, t, o);
        case L:
          return b$(e, t);
        case H:
          return $R(e, t, o);
        case _:
          return N$(e, t, o);
        case F: {
          var ae = t.type, Re = t.pendingProps, qe = t.elementType === ae ? Re : Go(ae, Re);
          return _R(e, t, ae, qe, o);
        }
        case $:
          return h$(e, t, o);
        case Y:
          return m$(e, t, o);
        case ne:
          return v$(e, t, o);
        case W:
          return F$(e, t, o);
        case K:
          return V$(e, t, o);
        case le: {
          var je = t.type, At = t.pendingProps, Tt = Go(je, At);
          if (t.type !== t.elementType) {
            var q = je.propTypes;
            q && Ho(
              q,
              Tt,
              // Resolved for outer only
              "prop",
              Zt(je)
            );
          }
          return Tt = Go(je.type, Tt), DR(e, t, je, Tt, o);
        }
        case re:
          return AR(e, t, t.type, t.pendingProps, o);
        case Fe: {
          var ie = t.type, Q = t.pendingProps, pe = t.elementType === ie ? Q : Go(ie, Q);
          return x$(e, t, ie, pe, o);
        }
        case vt:
          return jR(e, t, o);
        case Rt:
          break;
        case $e:
          return MR(e, t, o);
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function kp(e) {
      e.flags |= dt;
    }
    function HR(e) {
      e.flags |= _a, e.flags |= Uh;
    }
    var WR, kC, YR, GR;
    WR = function(e, t, o, l) {
      for (var f = t.child; f !== null; ) {
        if (f.tag === A || f.tag === L)
          c5(e, f.stateNode);
        else if (f.tag !== _) {
          if (f.child !== null) {
            f.child.return = f, f = f.child;
            continue;
          }
        }
        if (f === t)
          return;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === t)
            return;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
    }, kC = function(e, t) {
    }, YR = function(e, t, o, l, f) {
      var m = e.memoizedProps;
      if (m !== l) {
        var g = t.stateNode, C = Ox(), T = d5(g, o, m, l, f, C);
        t.updateQueue = T, T && kp(t);
      }
    }, GR = function(e, t, o, l) {
      o !== l && kp(t);
    };
    function lv(e, t) {
      if (!sa())
        switch (e.tailMode) {
          case "hidden": {
            for (var o = e.tail, l = null; o !== null; )
              o.alternate !== null && (l = o), o = o.sibling;
            l === null ? e.tail = null : l.sibling = null;
            break;
          }
          case "collapsed": {
            for (var f = e.tail, m = null; f !== null; )
              f.alternate !== null && (m = f), f = f.sibling;
            m === null ? !t && e.tail !== null ? e.tail.sibling = null : e.tail = null : m.sibling = null;
            break;
          }
        }
    }
    function ua(e) {
      var t = e.alternate !== null && e.alternate.child === e.child, o = oe, l = We;
      if (t) {
        if ((e.mode & Xe) !== Qe) {
          for (var T = e.selfBaseDuration, D = e.child; D !== null; )
            o = pt(o, pt(D.lanes, D.childLanes)), l |= D.subtreeFlags & Dr, l |= D.flags & Dr, T += D.treeBaseDuration, D = D.sibling;
          e.treeBaseDuration = T;
        } else
          for (var M = e.child; M !== null; )
            o = pt(o, pt(M.lanes, M.childLanes)), l |= M.subtreeFlags & Dr, l |= M.flags & Dr, M.return = e, M = M.sibling;
        e.subtreeFlags |= l;
      } else {
        if ((e.mode & Xe) !== Qe) {
          for (var f = e.actualDuration, m = e.selfBaseDuration, g = e.child; g !== null; )
            o = pt(o, pt(g.lanes, g.childLanes)), l |= g.subtreeFlags, l |= g.flags, f += g.actualDuration, m += g.treeBaseDuration, g = g.sibling;
          e.actualDuration = f, e.treeBaseDuration = m;
        } else
          for (var C = e.child; C !== null; )
            o = pt(o, pt(C.lanes, C.childLanes)), l |= C.subtreeFlags, l |= C.flags, C.return = e, C = C.sibling;
        e.subtreeFlags |= l;
      }
      return e.childLanes = o, t;
    }
    function U$(e, t, o) {
      if (RL() && (t.mode & xt) !== Qe && (t.flags & rt) === We)
        return Ek(t), mp(), t.flags |= Un | Ga | gr, !1;
      var l = i0(t);
      if (o !== null && o.dehydrated !== null)
        if (e === null) {
          if (!l)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (TL(t), ua(t), (t.mode & Xe) !== Qe) {
            var f = o !== null;
            if (f) {
              var m = t.child;
              m !== null && (t.treeBaseDuration -= m.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (mp(), (t.flags & rt) === We && (t.memoizedState = null), t.flags |= dt, ua(t), (t.mode & Xe) !== Qe) {
            var g = o !== null;
            if (g) {
              var C = t.child;
              C !== null && (t.treeBaseDuration -= C.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return wk(), !0;
    }
    function qR(e, t, o) {
      var l = t.pendingProps;
      switch (Z1(t), t.tag) {
        case w:
        case De:
        case re:
        case x:
        case F:
        case $:
        case Y:
        case ne:
        case K:
        case le:
          return ua(t), null;
        case E: {
          var f = t.type;
          return Ps(f) && Jg(t), ua(t), null;
        }
        case k: {
          var m = t.stateNode;
          if (bp(t), q1(t), Nx(), m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null), e === null || e.child === null) {
            var g = i0(t);
            if (g)
              kp(t);
            else if (e !== null) {
              var C = e.memoizedState;
              // Check if this is a client root
              (!C.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (t.flags & Un) !== We) && (t.flags |= fi, wk());
            }
          }
          return kC(e, t), ua(t), null;
        }
        case A: {
          zx(t);
          var T = Yk(), D = t.type;
          if (e !== null && t.stateNode != null)
            YR(e, t, D, l, T), e.ref !== t.ref && HR(t);
          else {
            if (!l) {
              if (t.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return ua(t), null;
            }
            var M = Ox(), U = i0(t);
            if (U)
              EL(t, T, M) && kp(t);
            else {
              var V = u5(D, l, T, M, t);
              WR(V, t, !1, !1), t.stateNode = V, f5(V, D, l, T) && kp(t);
            }
            t.ref !== null && HR(t);
          }
          return ua(t), null;
        }
        case L: {
          var Z = l;
          if (e && t.stateNode != null) {
            var J = e.memoizedProps;
            GR(e, t, J, Z);
          } else {
            if (typeof Z != "string" && t.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var ae = Yk(), Re = Ox(), qe = i0(t);
            qe ? wL(t) && kp(t) : t.stateNode = p5(Z, ae, Re, t);
          }
          return ua(t), null;
        }
        case H: {
          xp(t);
          var je = t.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var At = U$(e, t, je);
            if (!At)
              return t.flags & gr ? t : null;
          }
          if ((t.flags & rt) !== We)
            return t.lanes = o, (t.mode & Xe) !== Qe && lC(t), t;
          var Tt = je !== null, q = e !== null && e.memoizedState !== null;
          if (Tt !== q && Tt) {
            var ie = t.child;
            if (ie.flags |= ys, (t.mode & xt) !== Qe) {
              var Q = e === null && (t.memoizedProps.unstable_avoidThisFallback !== !0 || !Ae);
              Q || Px(qo.current, Qk) ? IN() : HC();
            }
          }
          var pe = t.updateQueue;
          if (pe !== null && (t.flags |= dt), ua(t), (t.mode & Xe) !== Qe && Tt) {
            var _e = t.child;
            _e !== null && (t.treeBaseDuration -= _e.treeBaseDuration);
          }
          return null;
        }
        case _:
          return bp(t), kC(e, t), e === null && oL(t.stateNode.containerInfo), ua(t), null;
        case W:
          var we = t.type._context;
          return sx(we, t), ua(t), null;
        case Fe: {
          var nt = t.type;
          return Ps(nt) && Jg(t), ua(t), null;
        }
        case vt: {
          xp(t);
          var ut = t.memoizedState;
          if (ut === null)
            return ua(t), null;
          var on = (t.flags & rt) !== We, Ft = ut.rendering;
          if (Ft === null)
            if (on)
              lv(ut, !1);
            else {
              var cr = WN() && (e === null || (e.flags & rt) === We);
              if (!cr)
                for (var Vt = t.child; Vt !== null; ) {
                  var nr = C0(Vt);
                  if (nr !== null) {
                    on = !0, t.flags |= rt, lv(ut, !1);
                    var Va = nr.updateQueue;
                    return Va !== null && (t.updateQueue = Va, t.flags |= dt), t.subtreeFlags = We, WL(t, o), qu(t, Lx(qo.current, Xm)), t.child;
                  }
                  Vt = Vt.sibling;
                }
              ut.tail !== null && zn() > m_() && (t.flags |= rt, on = !0, lv(ut, !1), t.lanes = tm);
            }
          else {
            if (!on) {
              var ha = C0(Ft);
              if (ha !== null) {
                t.flags |= rt, on = !0;
                var Wi = ha.updateQueue;
                if (Wi !== null && (t.updateQueue = Wi, t.flags |= dt), lv(ut, !0), ut.tail === null && ut.tailMode === "hidden" && !Ft.alternate && !sa())
                  return ua(t), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                zn() * 2 - ut.renderingStartTime > m_() && o !== Pa && (t.flags |= rt, on = !0, lv(ut, !1), t.lanes = tm);
            }
            if (ut.isBackwards)
              Ft.sibling = t.child, t.child = Ft;
            else {
              var ni = ut.last;
              ni !== null ? ni.sibling = Ft : t.child = Ft, ut.last = Ft;
            }
          }
          if (ut.tail !== null) {
            var ri = ut.tail;
            ut.rendering = ri, ut.tail = ri.sibling, ut.renderingStartTime = zn(), ri.sibling = null;
            var ja = qo.current;
            return on ? ja = Lx(ja, Xm) : ja = Sp(ja), qu(t, ja), ri;
          }
          return ua(t), null;
        }
        case Rt:
          break;
        case $e:
        case Be: {
          IC(t);
          var Il = t.memoizedState, Pp = Il !== null;
          if (e !== null) {
            var wv = e.memoizedState, Us = wv !== null;
            Us !== Pp && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !ve && (t.flags |= ys);
          }
          return !Pp || (t.mode & xt) === Qe ? ua(t) : La(Bs, Pa) && (ua(t), t.subtreeFlags & (xn | dt) && (t.flags |= ys)), null;
        }
        case jt:
          return null;
        case tt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function I$(e, t, o) {
      switch (Z1(t), t.tag) {
        case E: {
          var l = t.type;
          Ps(l) && Jg(t);
          var f = t.flags;
          return f & gr ? (t.flags = f & ~gr | rt, (t.mode & Xe) !== Qe && lC(t), t) : null;
        }
        case k: {
          t.stateNode, bp(t), q1(t), Nx();
          var m = t.flags;
          return (m & gr) !== We && (m & rt) === We ? (t.flags = m & ~gr | rt, t) : null;
        }
        case A:
          return zx(t), null;
        case H: {
          xp(t);
          var g = t.memoizedState;
          if (g !== null && g.dehydrated !== null) {
            if (t.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            mp();
          }
          var C = t.flags;
          return C & gr ? (t.flags = C & ~gr | rt, (t.mode & Xe) !== Qe && lC(t), t) : null;
        }
        case vt:
          return xp(t), null;
        case _:
          return bp(t), null;
        case W:
          var T = t.type._context;
          return sx(T, t), null;
        case $e:
        case Be:
          return IC(t), null;
        case jt:
          return null;
        default:
          return null;
      }
    }
    function QR(e, t, o) {
      switch (Z1(t), t.tag) {
        case E: {
          var l = t.type.childContextTypes;
          l != null && Jg(t);
          break;
        }
        case k: {
          t.stateNode, bp(t), q1(t), Nx();
          break;
        }
        case A: {
          zx(t);
          break;
        }
        case _:
          bp(t);
          break;
        case H:
          xp(t);
          break;
        case vt:
          xp(t);
          break;
        case W:
          var f = t.type._context;
          sx(f, t);
          break;
        case $e:
        case Be:
          IC(t);
          break;
      }
    }
    var KR = null;
    KR = /* @__PURE__ */ new Set();
    var W0 = !1, ca = !1, H$ = typeof WeakSet == "function" ? WeakSet : Set, Le = null, Rp = null, _p = null;
    function W$(e) {
      cl(null, function() {
        throw e;
      }), jh();
    }
    var Y$ = function(e, t) {
      if (t.props = e.memoizedProps, t.state = e.memoizedState, e.mode & Xe)
        try {
          Vs(), t.componentWillUnmount();
        } finally {
          Fs(e);
        }
      else
        t.componentWillUnmount();
    };
    function XR(e, t) {
      try {
        Xu(zr, e);
      } catch (o) {
        Tn(e, t, o);
      }
    }
    function RC(e, t, o) {
      try {
        Y$(e, o);
      } catch (l) {
        Tn(e, t, l);
      }
    }
    function G$(e, t, o) {
      try {
        o.componentDidMount();
      } catch (l) {
        Tn(e, t, l);
      }
    }
    function ZR(e, t) {
      try {
        e_(e);
      } catch (o) {
        Tn(e, t, o);
      }
    }
    function Dp(e, t) {
      var o = e.ref;
      if (o !== null)
        if (typeof o == "function") {
          var l;
          try {
            if (bt && yn && e.mode & Xe)
              try {
                Vs(), l = o(null);
              } finally {
                Fs(e);
              }
            else
              l = o(null);
          } catch (f) {
            Tn(e, t, f);
          }
          typeof l == "function" && h("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", st(e));
        } else
          o.current = null;
    }
    function Y0(e, t, o) {
      try {
        o();
      } catch (l) {
        Tn(e, t, l);
      }
    }
    var JR = !1;
    function q$(e, t) {
      s5(e.containerInfo), Le = t, Q$();
      var o = JR;
      return JR = !1, o;
    }
    function Q$() {
      for (; Le !== null; ) {
        var e = Le, t = e.child;
        (e.subtreeFlags & yu) !== We && t !== null ? (t.return = e, Le = t) : K$();
      }
    }
    function K$() {
      for (; Le !== null; ) {
        var e = Le;
        Ht(e);
        try {
          X$(e);
        } catch (o) {
          Tn(e, e.return, o);
        }
        Yn();
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, Le = t;
          return;
        }
        Le = e.return;
      }
    }
    function X$(e) {
      var t = e.alternate, o = e.flags;
      if ((o & fi) !== We) {
        switch (Ht(e), e.tag) {
          case x:
          case F:
          case re:
            break;
          case E: {
            if (t !== null) {
              var l = t.memoizedProps, f = t.memoizedState, m = e.stateNode;
              e.type === e.elementType && !gf && (m.props !== e.memoizedProps && h("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", st(e) || "instance"), m.state !== e.memoizedState && h("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", st(e) || "instance"));
              var g = m.getSnapshotBeforeUpdate(e.elementType === e.type ? l : Go(e.type, l), f);
              {
                var C = KR;
                g === void 0 && !C.has(e.type) && (C.add(e.type), h("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", st(e)));
              }
              m.__reactInternalSnapshotBeforeUpdate = g;
            }
            break;
          }
          case k: {
            {
              var T = e.stateNode;
              O5(T.containerInfo);
            }
            break;
          }
          case A:
          case L:
          case _:
          case Fe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Yn();
      }
    }
    function Xo(e, t, o) {
      var l = t.updateQueue, f = l !== null ? l.lastEffect : null;
      if (f !== null) {
        var m = f.next, g = m;
        do {
          if ((g.tag & e) === e) {
            var C = g.destroy;
            g.destroy = void 0, C !== void 0 && ((e & la) !== wi ? gd(t) : (e & zr) !== wi && bd(t), (e & Ls) !== wi && xv(!0), Y0(t, o, C), (e & Ls) !== wi && xv(!1), (e & la) !== wi ? ag() : (e & zr) !== wi && gu());
          }
          g = g.next;
        } while (g !== m);
      }
    }
    function Xu(e, t) {
      var o = t.updateQueue, l = o !== null ? o.lastEffect : null;
      if (l !== null) {
        var f = l.next, m = f;
        do {
          if ((m.tag & e) === e) {
            (e & la) !== wi ? rg(t) : (e & zr) !== wi && ig(t);
            var g = m.create;
            (e & Ls) !== wi && xv(!0), m.destroy = g(), (e & Ls) !== wi && xv(!1), (e & la) !== wi ? Zh() : (e & zr) !== wi && og();
            {
              var C = m.destroy;
              if (C !== void 0 && typeof C != "function") {
                var T = void 0;
                (m.tag & zr) !== We ? T = "useLayoutEffect" : (m.tag & Ls) !== We ? T = "useInsertionEffect" : T = "useEffect";
                var D = void 0;
                C === null ? D = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof C.then == "function" ? D = `

It looks like you wrote ` + T + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + T + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : D = " You returned: " + C, h("%s must not return anything besides a function, which is used for clean-up.%s", T, D);
              }
            }
          }
          m = m.next;
        } while (m !== f);
      }
    }
    function Z$(e, t) {
      if ((t.flags & dt) !== We)
        switch (t.tag) {
          case ne: {
            var o = t.stateNode.passiveEffectDuration, l = t.memoizedProps, f = l.id, m = l.onPostCommit, g = xR(), C = t.alternate === null ? "mount" : "update";
            SR() && (C = "nested-update"), typeof m == "function" && m(f, C, o, g);
            var T = t.return;
            e:
              for (; T !== null; ) {
                switch (T.tag) {
                  case k:
                    var D = T.stateNode;
                    D.passiveEffectDuration += o;
                    break e;
                  case ne:
                    var M = T.stateNode;
                    M.passiveEffectDuration += o;
                    break e;
                }
                T = T.return;
              }
            break;
          }
        }
    }
    function J$(e, t, o, l) {
      if ((o.flags & Gr) !== We)
        switch (o.tag) {
          case x:
          case F:
          case re: {
            if (!ca)
              if (o.mode & Xe)
                try {
                  Vs(), Xu(zr | Or, o);
                } finally {
                  Fs(o);
                }
              else
                Xu(zr | Or, o);
            break;
          }
          case E: {
            var f = o.stateNode;
            if (o.flags & dt && !ca)
              if (t === null)
                if (o.type === o.elementType && !gf && (f.props !== o.memoizedProps && h("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", st(o) || "instance"), f.state !== o.memoizedState && h("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", st(o) || "instance")), o.mode & Xe)
                  try {
                    Vs(), f.componentDidMount();
                  } finally {
                    Fs(o);
                  }
                else
                  f.componentDidMount();
              else {
                var m = o.elementType === o.type ? t.memoizedProps : Go(o.type, t.memoizedProps), g = t.memoizedState;
                if (o.type === o.elementType && !gf && (f.props !== o.memoizedProps && h("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", st(o) || "instance"), f.state !== o.memoizedState && h("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", st(o) || "instance")), o.mode & Xe)
                  try {
                    Vs(), f.componentDidUpdate(m, g, f.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Fs(o);
                  }
                else
                  f.componentDidUpdate(m, g, f.__reactInternalSnapshotBeforeUpdate);
              }
            var C = o.updateQueue;
            C !== null && (o.type === o.elementType && !gf && (f.props !== o.memoizedProps && h("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", st(o) || "instance"), f.state !== o.memoizedState && h("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", st(o) || "instance")), Pk(o, C, f));
            break;
          }
          case k: {
            var T = o.updateQueue;
            if (T !== null) {
              var D = null;
              if (o.child !== null)
                switch (o.child.tag) {
                  case A:
                    D = o.child.stateNode;
                    break;
                  case E:
                    D = o.child.stateNode;
                    break;
                }
              Pk(o, T, D);
            }
            break;
          }
          case A: {
            var M = o.stateNode;
            if (t === null && o.flags & dt) {
              var U = o.type, V = o.memoizedProps;
              g5(M, U, V);
            }
            break;
          }
          case L:
            break;
          case _:
            break;
          case ne: {
            {
              var Z = o.memoizedProps, J = Z.onCommit, ae = Z.onRender, Re = o.stateNode.effectDuration, qe = xR(), je = t === null ? "mount" : "update";
              SR() && (je = "nested-update"), typeof ae == "function" && ae(o.memoizedProps.id, je, o.actualDuration, o.treeBaseDuration, o.actualStartTime, qe);
              {
                typeof J == "function" && J(o.memoizedProps.id, je, Re, qe), KN(o);
                var At = o.return;
                e:
                  for (; At !== null; ) {
                    switch (At.tag) {
                      case k:
                        var Tt = At.stateNode;
                        Tt.effectDuration += Re;
                        break e;
                      case ne:
                        var q = At.stateNode;
                        q.effectDuration += Re;
                        break e;
                    }
                    At = At.return;
                  }
              }
            }
            break;
          }
          case H: {
            sN(e, o);
            break;
          }
          case vt:
          case Fe:
          case Rt:
          case $e:
          case Be:
          case tt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      ca || o.flags & _a && e_(o);
    }
    function eN(e) {
      switch (e.tag) {
        case x:
        case F:
        case re: {
          if (e.mode & Xe)
            try {
              Vs(), XR(e, e.return);
            } finally {
              Fs(e);
            }
          else
            XR(e, e.return);
          break;
        }
        case E: {
          var t = e.stateNode;
          typeof t.componentDidMount == "function" && G$(e, e.return, t), ZR(e, e.return);
          break;
        }
        case A: {
          ZR(e, e.return);
          break;
        }
      }
    }
    function tN(e, t) {
      for (var o = null, l = e; ; ) {
        if (l.tag === A) {
          if (o === null) {
            o = l;
            try {
              var f = l.stateNode;
              t ? _5(f) : A5(l.stateNode, l.memoizedProps);
            } catch (g) {
              Tn(e, e.return, g);
            }
          }
        } else if (l.tag === L) {
          if (o === null)
            try {
              var m = l.stateNode;
              t ? D5(m) : M5(m, l.memoizedProps);
            } catch (g) {
              Tn(e, e.return, g);
            }
        } else if (!((l.tag === $e || l.tag === Be) && l.memoizedState !== null && l !== e)) {
          if (l.child !== null) {
            l.child.return = l, l = l.child;
            continue;
          }
        }
        if (l === e)
          return;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === e)
            return;
          o === l && (o = null), l = l.return;
        }
        o === l && (o = null), l.sibling.return = l.return, l = l.sibling;
      }
    }
    function e_(e) {
      var t = e.ref;
      if (t !== null) {
        var o = e.stateNode, l;
        switch (e.tag) {
          case A:
            l = o;
            break;
          default:
            l = o;
        }
        if (typeof t == "function") {
          var f;
          if (e.mode & Xe)
            try {
              Vs(), f = t(l);
            } finally {
              Fs(e);
            }
          else
            f = t(l);
          typeof f == "function" && h("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", st(e));
        } else
          t.hasOwnProperty("current") || h("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", st(e)), t.current = l;
      }
    }
    function nN(e) {
      var t = e.alternate;
      t !== null && (t.return = null), e.return = null;
    }
    function t_(e) {
      var t = e.alternate;
      t !== null && (e.alternate = null, t_(t));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === A) {
          var o = e.stateNode;
          o !== null && uL(o);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function rN(e) {
      for (var t = e.return; t !== null; ) {
        if (n_(t))
          return t;
        t = t.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function n_(e) {
      return e.tag === A || e.tag === k || e.tag === _;
    }
    function r_(e) {
      var t = e;
      e:
        for (; ; ) {
          for (; t.sibling === null; ) {
            if (t.return === null || n_(t.return))
              return null;
            t = t.return;
          }
          for (t.sibling.return = t.return, t = t.sibling; t.tag !== A && t.tag !== L && t.tag !== ot; ) {
            if (t.flags & xn || t.child === null || t.tag === _)
              continue e;
            t.child.return = t, t = t.child;
          }
          if (!(t.flags & xn))
            return t.stateNode;
        }
    }
    function aN(e) {
      var t = rN(e);
      switch (t.tag) {
        case A: {
          var o = t.stateNode;
          t.flags & Qt && (ak(o), t.flags &= ~Qt);
          var l = r_(e);
          DC(e, l, o);
          break;
        }
        case k:
        case _: {
          var f = t.stateNode.containerInfo, m = r_(e);
          _C(e, m, f);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function _C(e, t, o) {
      var l = e.tag, f = l === A || l === L;
      if (f) {
        var m = e.stateNode;
        t ? w5(o, m, t) : C5(o, m);
      } else if (l !== _) {
        var g = e.child;
        if (g !== null) {
          _C(g, t, o);
          for (var C = g.sibling; C !== null; )
            _C(C, t, o), C = C.sibling;
        }
      }
    }
    function DC(e, t, o) {
      var l = e.tag, f = l === A || l === L;
      if (f) {
        var m = e.stateNode;
        t ? E5(o, m, t) : x5(o, m);
      } else if (l !== _) {
        var g = e.child;
        if (g !== null) {
          DC(g, t, o);
          for (var C = g.sibling; C !== null; )
            DC(C, t, o), C = C.sibling;
        }
      }
    }
    var fa = null, Zo = !1;
    function iN(e, t, o) {
      {
        var l = t;
        e:
          for (; l !== null; ) {
            switch (l.tag) {
              case A: {
                fa = l.stateNode, Zo = !1;
                break e;
              }
              case k: {
                fa = l.stateNode.containerInfo, Zo = !0;
                break e;
              }
              case _: {
                fa = l.stateNode.containerInfo, Zo = !0;
                break e;
              }
            }
            l = l.return;
          }
        if (fa === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        a_(e, t, o), fa = null, Zo = !1;
      }
      nN(o);
    }
    function Zu(e, t, o) {
      for (var l = o.child; l !== null; )
        a_(e, t, l), l = l.sibling;
    }
    function a_(e, t, o) {
      switch (Kh(o), o.tag) {
        case A:
          ca || Dp(o, t);
        case L: {
          {
            var l = fa, f = Zo;
            fa = null, Zu(e, t, o), fa = l, Zo = f, fa !== null && (Zo ? k5(fa, o.stateNode) : T5(fa, o.stateNode));
          }
          return;
        }
        case ot: {
          fa !== null && (Zo ? R5(fa, o.stateNode) : j1(fa, o.stateNode));
          return;
        }
        case _: {
          {
            var m = fa, g = Zo;
            fa = o.stateNode.containerInfo, Zo = !0, Zu(e, t, o), fa = m, Zo = g;
          }
          return;
        }
        case x:
        case F:
        case le:
        case re: {
          if (!ca) {
            var C = o.updateQueue;
            if (C !== null) {
              var T = C.lastEffect;
              if (T !== null) {
                var D = T.next, M = D;
                do {
                  var U = M, V = U.destroy, Z = U.tag;
                  V !== void 0 && ((Z & Ls) !== wi ? Y0(o, t, V) : (Z & zr) !== wi && (bd(o), o.mode & Xe ? (Vs(), Y0(o, t, V), Fs(o)) : Y0(o, t, V), gu())), M = M.next;
                } while (M !== D);
              }
            }
          }
          Zu(e, t, o);
          return;
        }
        case E: {
          if (!ca) {
            Dp(o, t);
            var J = o.stateNode;
            typeof J.componentWillUnmount == "function" && RC(o, t, J);
          }
          Zu(e, t, o);
          return;
        }
        case Rt: {
          Zu(e, t, o);
          return;
        }
        case $e: {
          if (
            // TODO: Remove this dead flag
            o.mode & xt
          ) {
            var ae = ca;
            ca = ae || o.memoizedState !== null, Zu(e, t, o), ca = ae;
          } else
            Zu(e, t, o);
          break;
        }
        default: {
          Zu(e, t, o);
          return;
        }
      }
    }
    function oN(e) {
      e.memoizedState;
    }
    function sN(e, t) {
      var o = t.memoizedState;
      if (o === null) {
        var l = t.alternate;
        if (l !== null) {
          var f = l.memoizedState;
          if (f !== null) {
            var m = f.dehydrated;
            m !== null && Y5(m);
          }
        }
      }
    }
    function i_(e) {
      var t = e.updateQueue;
      if (t !== null) {
        e.updateQueue = null;
        var o = e.stateNode;
        o === null && (o = e.stateNode = new H$()), t.forEach(function(l) {
          var f = r3.bind(null, e, l);
          if (!o.has(l)) {
            if (o.add(l), Ar)
              if (Rp !== null && _p !== null)
                Sv(_p, Rp);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            l.then(f, f);
          }
        });
      }
    }
    function lN(e, t, o) {
      Rp = o, _p = e, Ht(t), o_(t, e), Ht(t), Rp = null, _p = null;
    }
    function Jo(e, t, o) {
      var l = t.deletions;
      if (l !== null)
        for (var f = 0; f < l.length; f++) {
          var m = l[f];
          try {
            iN(e, t, m);
          } catch (T) {
            Tn(m, t, T);
          }
        }
      var g = Cc();
      if (t.subtreeFlags & Ma)
        for (var C = t.child; C !== null; )
          Ht(C), o_(C, e), C = C.sibling;
      Ht(g);
    }
    function o_(e, t, o) {
      var l = e.alternate, f = e.flags;
      switch (e.tag) {
        case x:
        case F:
        case le:
        case re: {
          if (Jo(t, e), js(e), f & dt) {
            try {
              Xo(Ls | Or, e, e.return), Xu(Ls | Or, e);
            } catch (nt) {
              Tn(e, e.return, nt);
            }
            if (e.mode & Xe) {
              try {
                Vs(), Xo(zr | Or, e, e.return);
              } catch (nt) {
                Tn(e, e.return, nt);
              }
              Fs(e);
            } else
              try {
                Xo(zr | Or, e, e.return);
              } catch (nt) {
                Tn(e, e.return, nt);
              }
          }
          return;
        }
        case E: {
          Jo(t, e), js(e), f & _a && l !== null && Dp(l, l.return);
          return;
        }
        case A: {
          Jo(t, e), js(e), f & _a && l !== null && Dp(l, l.return);
          {
            if (e.flags & Qt) {
              var m = e.stateNode;
              try {
                ak(m);
              } catch (nt) {
                Tn(e, e.return, nt);
              }
            }
            if (f & dt) {
              var g = e.stateNode;
              if (g != null) {
                var C = e.memoizedProps, T = l !== null ? l.memoizedProps : C, D = e.type, M = e.updateQueue;
                if (e.updateQueue = null, M !== null)
                  try {
                    b5(g, M, D, T, C, e);
                  } catch (nt) {
                    Tn(e, e.return, nt);
                  }
              }
            }
          }
          return;
        }
        case L: {
          if (Jo(t, e), js(e), f & dt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var U = e.stateNode, V = e.memoizedProps, Z = l !== null ? l.memoizedProps : V;
            try {
              S5(U, Z, V);
            } catch (nt) {
              Tn(e, e.return, nt);
            }
          }
          return;
        }
        case k: {
          if (Jo(t, e), js(e), f & dt && l !== null) {
            var J = l.memoizedState;
            if (J.isDehydrated)
              try {
                W5(t.containerInfo);
              } catch (nt) {
                Tn(e, e.return, nt);
              }
          }
          return;
        }
        case _: {
          Jo(t, e), js(e);
          return;
        }
        case H: {
          Jo(t, e), js(e);
          var ae = e.child;
          if (ae.flags & ys) {
            var Re = ae.stateNode, qe = ae.memoizedState, je = qe !== null;
            if (Re.isHidden = je, je) {
              var At = ae.alternate !== null && ae.alternate.memoizedState !== null;
              At || UN();
            }
          }
          if (f & dt) {
            try {
              oN(e);
            } catch (nt) {
              Tn(e, e.return, nt);
            }
            i_(e);
          }
          return;
        }
        case $e: {
          var Tt = l !== null && l.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & xt
          ) {
            var q = ca;
            ca = q || Tt, Jo(t, e), ca = q;
          } else
            Jo(t, e);
          if (js(e), f & ys) {
            var ie = e.stateNode, Q = e.memoizedState, pe = Q !== null, _e = e;
            if (ie.isHidden = pe, pe && !Tt && (_e.mode & xt) !== Qe) {
              Le = _e;
              for (var we = _e.child; we !== null; )
                Le = we, cN(we), we = we.sibling;
            }
            tN(_e, pe);
          }
          return;
        }
        case vt: {
          Jo(t, e), js(e), f & dt && i_(e);
          return;
        }
        case Rt:
          return;
        default: {
          Jo(t, e), js(e);
          return;
        }
      }
    }
    function js(e) {
      var t = e.flags;
      if (t & xn) {
        try {
          aN(e);
        } catch (o) {
          Tn(e, e.return, o);
        }
        e.flags &= ~xn;
      }
      t & di && (e.flags &= ~di);
    }
    function uN(e, t, o) {
      Rp = o, _p = t, Le = e, s_(e, t, o), Rp = null, _p = null;
    }
    function s_(e, t, o) {
      for (var l = (e.mode & xt) !== Qe; Le !== null; ) {
        var f = Le, m = f.child;
        if (f.tag === $e && l) {
          var g = f.memoizedState !== null, C = g || W0;
          if (C) {
            AC(e, t, o);
            continue;
          } else {
            var T = f.alternate, D = T !== null && T.memoizedState !== null, M = D || ca, U = W0, V = ca;
            W0 = C, ca = M, ca && !V && (Le = f, fN(f));
            for (var Z = m; Z !== null; )
              Le = Z, s_(
                Z,
                // New root; bubble back up to here and stop.
                t,
                o
              ), Z = Z.sibling;
            Le = f, W0 = U, ca = V, AC(e, t, o);
            continue;
          }
        }
        (f.subtreeFlags & Gr) !== We && m !== null ? (m.return = f, Le = m) : AC(e, t, o);
      }
    }
    function AC(e, t, o) {
      for (; Le !== null; ) {
        var l = Le;
        if ((l.flags & Gr) !== We) {
          var f = l.alternate;
          Ht(l);
          try {
            J$(t, f, l, o);
          } catch (g) {
            Tn(l, l.return, g);
          }
          Yn();
        }
        if (l === e) {
          Le = null;
          return;
        }
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Le = m;
          return;
        }
        Le = l.return;
      }
    }
    function cN(e) {
      for (; Le !== null; ) {
        var t = Le, o = t.child;
        switch (t.tag) {
          case x:
          case F:
          case le:
          case re: {
            if (t.mode & Xe)
              try {
                Vs(), Xo(zr, t, t.return);
              } finally {
                Fs(t);
              }
            else
              Xo(zr, t, t.return);
            break;
          }
          case E: {
            Dp(t, t.return);
            var l = t.stateNode;
            typeof l.componentWillUnmount == "function" && RC(t, t.return, l);
            break;
          }
          case A: {
            Dp(t, t.return);
            break;
          }
          case $e: {
            var f = t.memoizedState !== null;
            if (f) {
              l_(e);
              continue;
            }
            break;
          }
        }
        o !== null ? (o.return = t, Le = o) : l_(e);
      }
    }
    function l_(e) {
      for (; Le !== null; ) {
        var t = Le;
        if (t === e) {
          Le = null;
          return;
        }
        var o = t.sibling;
        if (o !== null) {
          o.return = t.return, Le = o;
          return;
        }
        Le = t.return;
      }
    }
    function fN(e) {
      for (; Le !== null; ) {
        var t = Le, o = t.child;
        if (t.tag === $e) {
          var l = t.memoizedState !== null;
          if (l) {
            u_(e);
            continue;
          }
        }
        o !== null ? (o.return = t, Le = o) : u_(e);
      }
    }
    function u_(e) {
      for (; Le !== null; ) {
        var t = Le;
        Ht(t);
        try {
          eN(t);
        } catch (l) {
          Tn(t, t.return, l);
        }
        if (Yn(), t === e) {
          Le = null;
          return;
        }
        var o = t.sibling;
        if (o !== null) {
          o.return = t.return, Le = o;
          return;
        }
        Le = t.return;
      }
    }
    function dN(e, t, o, l) {
      Le = t, pN(t, e, o, l);
    }
    function pN(e, t, o, l) {
      for (; Le !== null; ) {
        var f = Le, m = f.child;
        (f.subtreeFlags & pi) !== We && m !== null ? (m.return = f, Le = m) : hN(e, t, o, l);
      }
    }
    function hN(e, t, o, l) {
      for (; Le !== null; ) {
        var f = Le;
        if ((f.flags & _n) !== We) {
          Ht(f);
          try {
            mN(t, f, o, l);
          } catch (g) {
            Tn(f, f.return, g);
          }
          Yn();
        }
        if (f === e) {
          Le = null;
          return;
        }
        var m = f.sibling;
        if (m !== null) {
          m.return = f.return, Le = m;
          return;
        }
        Le = f.return;
      }
    }
    function mN(e, t, o, l) {
      switch (t.tag) {
        case x:
        case F:
        case re: {
          if (t.mode & Xe) {
            sC();
            try {
              Xu(la | Or, t);
            } finally {
              oC(t);
            }
          } else
            Xu(la | Or, t);
          break;
        }
      }
    }
    function vN(e) {
      Le = e, yN();
    }
    function yN() {
      for (; Le !== null; ) {
        var e = Le, t = e.child;
        if ((Le.flags & Yt) !== We) {
          var o = e.deletions;
          if (o !== null) {
            for (var l = 0; l < o.length; l++) {
              var f = o[l];
              Le = f, SN(f, e);
            }
            {
              var m = e.alternate;
              if (m !== null) {
                var g = m.child;
                if (g !== null) {
                  m.child = null;
                  do {
                    var C = g.sibling;
                    g.sibling = null, g = C;
                  } while (g !== null);
                }
              }
            }
            Le = e;
          }
        }
        (e.subtreeFlags & pi) !== We && t !== null ? (t.return = e, Le = t) : gN();
      }
    }
    function gN() {
      for (; Le !== null; ) {
        var e = Le;
        (e.flags & _n) !== We && (Ht(e), bN(e), Yn());
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, Le = t;
          return;
        }
        Le = e.return;
      }
    }
    function bN(e) {
      switch (e.tag) {
        case x:
        case F:
        case re: {
          e.mode & Xe ? (sC(), Xo(la | Or, e, e.return), oC(e)) : Xo(la | Or, e, e.return);
          break;
        }
      }
    }
    function SN(e, t) {
      for (; Le !== null; ) {
        var o = Le;
        Ht(o), CN(o, t), Yn();
        var l = o.child;
        l !== null ? (l.return = o, Le = l) : xN(e);
      }
    }
    function xN(e) {
      for (; Le !== null; ) {
        var t = Le, o = t.sibling, l = t.return;
        if (t_(t), t === e) {
          Le = null;
          return;
        }
        if (o !== null) {
          o.return = l, Le = o;
          return;
        }
        Le = l;
      }
    }
    function CN(e, t) {
      switch (e.tag) {
        case x:
        case F:
        case re: {
          e.mode & Xe ? (sC(), Xo(la, e, t), oC(e)) : Xo(la, e, t);
          break;
        }
      }
    }
    function EN(e) {
      switch (e.tag) {
        case x:
        case F:
        case re: {
          try {
            Xu(zr | Or, e);
          } catch (o) {
            Tn(e, e.return, o);
          }
          break;
        }
        case E: {
          var t = e.stateNode;
          try {
            t.componentDidMount();
          } catch (o) {
            Tn(e, e.return, o);
          }
          break;
        }
      }
    }
    function wN(e) {
      switch (e.tag) {
        case x:
        case F:
        case re: {
          try {
            Xu(la | Or, e);
          } catch (t) {
            Tn(e, e.return, t);
          }
          break;
        }
      }
    }
    function TN(e) {
      switch (e.tag) {
        case x:
        case F:
        case re: {
          try {
            Xo(zr | Or, e, e.return);
          } catch (o) {
            Tn(e, e.return, o);
          }
          break;
        }
        case E: {
          var t = e.stateNode;
          typeof t.componentWillUnmount == "function" && RC(e, e.return, t);
          break;
        }
      }
    }
    function kN(e) {
      switch (e.tag) {
        case x:
        case F:
        case re:
          try {
            Xo(la | Or, e, e.return);
          } catch (t) {
            Tn(e, e.return, t);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var uv = Symbol.for;
      uv("selector.component"), uv("selector.has_pseudo_class"), uv("selector.role"), uv("selector.test_id"), uv("selector.text");
    }
    var RN = [];
    function _N() {
      RN.forEach(function(e) {
        return e();
      });
    }
    var DN = s.ReactCurrentActQueue;
    function AN(e) {
      {
        var t = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), o = typeof jest < "u";
        return o && t !== !1;
      }
    }
    function c_() {
      {
        var e = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && DN.current !== null && h("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var MN = Math.ceil, MC = s.ReactCurrentDispatcher, OC = s.ReactCurrentOwner, da = s.ReactCurrentBatchConfig, es = s.ReactCurrentActQueue, $r = (
      /*             */
      0
    ), f_ = (
      /*               */
      1
    ), pa = (
      /*                */
      2
    ), po = (
      /*                */
      4
    ), Vl = 0, cv = 1, bf = 2, G0 = 3, fv = 4, d_ = 5, zC = 6, Dt = $r, ei = null, Qn = null, Nr = oe, Bs = oe, PC = Uu(oe), Fr = Vl, dv = null, q0 = oe, pv = oe, Q0 = oe, hv = null, Ti = null, LC = 0, p_ = 500, h_ = 1 / 0, ON = 500, jl = null;
    function mv() {
      h_ = zn() + ON;
    }
    function m_() {
      return h_;
    }
    var K0 = !1, $C = null, Ap = null, Sf = !1, Ju = null, vv = oe, NC = [], FC = null, zN = 50, yv = 0, VC = null, jC = !1, X0 = !1, PN = 50, Mp = 0, Z0 = null, gv = dn, J0 = oe, v_ = !1;
    function eb() {
      return ei;
    }
    function ti() {
      return (Dt & (pa | po)) !== $r ? zn() : (gv !== dn || (gv = zn()), gv);
    }
    function ec(e) {
      var t = e.mode;
      if ((t & xt) === Qe)
        return Ze;
      if ((Dt & pa) !== $r && Nr !== oe)
        return or(Nr);
      var o = AL() !== DL;
      if (o) {
        if (da.transition !== null) {
          var l = da.transition;
          l._updatedFibers || (l._updatedFibers = /* @__PURE__ */ new Set()), l._updatedFibers.add(e);
        }
        return J0 === _t && (J0 = am()), J0;
      }
      var f = gi();
      if (f !== _t)
        return f;
      var m = h5();
      return m;
    }
    function LN(e) {
      var t = e.mode;
      return (t & xt) === Qe ? Ze : s1();
    }
    function Vr(e, t, o, l) {
      i3(), v_ && h("useInsertionEffect must not schedule updates."), jC && (X0 = !0), Cl(e, o, l), (Dt & pa) !== oe && e === ei ? l3(t) : (Ar && um(e, t, o), u3(t), e === ei && ((Dt & pa) === $r && (pv = pt(pv, o)), Fr === fv && tc(e, Nr)), ki(e, l), o === Ze && Dt === $r && (t.mode & xt) === Qe && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !es.isBatchingLegacy && (mv(), mk()));
    }
    function $N(e, t, o) {
      var l = e.current;
      l.lanes = t, Cl(e, t, o), ki(e, o);
    }
    function NN(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Dt & pa) !== $r
      );
    }
    function ki(e, t) {
      var o = e.callbackNode;
      a1(e, t);
      var l = Hc(e, e === ei ? Nr : oe);
      if (l === oe) {
        o !== null && O_(o), e.callbackNode = null, e.callbackPriority = _t;
        return;
      }
      var f = er(l), m = e.callbackPriority;
      if (m === f && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(es.current !== null && o !== GC)) {
        o == null && m !== Ze && h("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      o != null && O_(o);
      var g;
      if (f === Ze)
        e.tag === Iu ? (es.isBatchingLegacy !== null && (es.didScheduleLegacyUpdate = !0), dL(b_.bind(null, e))) : hk(b_.bind(null, e)), es.current !== null ? es.current.push(Hu) : v5(function() {
          (Dt & (pa | po)) === $r && Hu();
        }), g = null;
      else {
        var C;
        switch (Qc(l)) {
          case qr:
            C = md;
            break;
          case Mr:
            C = Ka;
            break;
          case Vo:
            C = no;
            break;
          case Gc:
            C = bs;
            break;
          default:
            C = no;
            break;
        }
        g = qC(C, y_.bind(null, e));
      }
      e.callbackPriority = f, e.callbackNode = g;
    }
    function y_(e, t) {
      if (i$(), gv = dn, J0 = oe, (Dt & (pa | po)) !== $r)
        throw new Error("Should not already be working.");
      var o = e.callbackNode, l = Ul();
      if (l && e.callbackNode !== o)
        return null;
      var f = Hc(e, e === ei ? Nr : oe);
      if (f === oe)
        return null;
      var m = !Yc(e, f) && !dg(e, f) && !t, g = m ? GN(e, f) : nb(e, f);
      if (g !== Vl) {
        if (g === bf) {
          var C = nm(e);
          C !== oe && (f = C, g = BC(e, C));
        }
        if (g === cv) {
          var T = dv;
          throw xf(e, oe), tc(e, f), ki(e, zn()), T;
        }
        if (g === zC)
          tc(e, f);
        else {
          var D = !Yc(e, f), M = e.current.alternate;
          if (D && !VN(M)) {
            if (g = nb(e, f), g === bf) {
              var U = nm(e);
              U !== oe && (f = U, g = BC(e, U));
            }
            if (g === cv) {
              var V = dv;
              throw xf(e, oe), tc(e, f), ki(e, zn()), V;
            }
          }
          e.finishedWork = M, e.finishedLanes = f, FN(e, g, f);
        }
      }
      return ki(e, zn()), e.callbackNode === o ? y_.bind(null, e) : null;
    }
    function BC(e, t) {
      var o = hv;
      if (lr(e)) {
        var l = xf(e, t);
        l.flags |= Un, iL(e.containerInfo);
      }
      var f = nb(e, t);
      if (f !== bf) {
        var m = Ti;
        Ti = o, m !== null && g_(m);
      }
      return f;
    }
    function g_(e) {
      Ti === null ? Ti = e : Ti.push.apply(Ti, e);
    }
    function FN(e, t, o) {
      switch (t) {
        case Vl:
        case cv:
          throw new Error("Root did not complete. This is a bug in React.");
        case bf: {
          Cf(e, Ti, jl);
          break;
        }
        case G0: {
          if (tc(e, o), Vd(o) && // do not delay if we're inside an act() scope
          !z_()) {
            var l = LC + p_ - zn();
            if (l > 10) {
              var f = Hc(e, oe);
              if (f !== oe)
                break;
              var m = e.suspendedLanes;
              if (!xl(m, o)) {
                ti(), sm(e, m);
                break;
              }
              e.timeoutHandle = F1(Cf.bind(null, e, Ti, jl), l);
              break;
            }
          }
          Cf(e, Ti, jl);
          break;
        }
        case fv: {
          if (tc(e, o), fg(o))
            break;
          if (!z_()) {
            var g = cg(e, o), C = g, T = zn() - C, D = a3(T) - T;
            if (D > 10) {
              e.timeoutHandle = F1(Cf.bind(null, e, Ti, jl), D);
              break;
            }
          }
          Cf(e, Ti, jl);
          break;
        }
        case d_: {
          Cf(e, Ti, jl);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function VN(e) {
      for (var t = e; ; ) {
        if (t.flags & Nc) {
          var o = t.updateQueue;
          if (o !== null) {
            var l = o.stores;
            if (l !== null)
              for (var f = 0; f < l.length; f++) {
                var m = l[f], g = m.getSnapshot, C = m.value;
                try {
                  if (!Pe(g(), C))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var T = t.child;
        if (t.subtreeFlags & Nc && T !== null) {
          T.return = t, t = T;
          continue;
        }
        if (t === e)
          return !0;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return !0;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return !0;
    }
    function tc(e, t) {
      t = Tu(t, Q0), t = Tu(t, pv), om(e, t);
    }
    function b_(e) {
      if (o$(), (Dt & (pa | po)) !== $r)
        throw new Error("Should not already be working.");
      Ul();
      var t = Hc(e, oe);
      if (!La(t, Ze))
        return ki(e, zn()), null;
      var o = nb(e, t);
      if (e.tag !== Iu && o === bf) {
        var l = nm(e);
        l !== oe && (t = l, o = BC(e, l));
      }
      if (o === cv) {
        var f = dv;
        throw xf(e, oe), tc(e, t), ki(e, zn()), f;
      }
      if (o === zC)
        throw new Error("Root did not complete. This is a bug in React.");
      var m = e.current.alternate;
      return e.finishedWork = m, e.finishedLanes = t, Cf(e, Ti, jl), ki(e, zn()), null;
    }
    function jN(e, t) {
      t !== oe && (ku(e, pt(t, Ze)), ki(e, zn()), (Dt & (pa | po)) === $r && (mv(), Hu()));
    }
    function UC(e, t) {
      var o = Dt;
      Dt |= f_;
      try {
        return e(t);
      } finally {
        Dt = o, Dt === $r && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !es.isBatchingLegacy && (mv(), mk());
      }
    }
    function BN(e, t, o, l, f) {
      var m = gi(), g = da.transition;
      try {
        return da.transition = null, sr(qr), e(t, o, l, f);
      } finally {
        sr(m), da.transition = g, Dt === $r && mv();
      }
    }
    function Bl(e) {
      Ju !== null && Ju.tag === Iu && (Dt & (pa | po)) === $r && Ul();
      var t = Dt;
      Dt |= f_;
      var o = da.transition, l = gi();
      try {
        return da.transition = null, sr(qr), e ? e() : void 0;
      } finally {
        sr(l), da.transition = o, Dt = t, (Dt & (pa | po)) === $r && Hu();
      }
    }
    function S_() {
      return (Dt & (pa | po)) !== $r;
    }
    function tb(e, t) {
      Na(PC, Bs, e), Bs = pt(Bs, t);
    }
    function IC(e) {
      Bs = PC.current, $a(PC, e);
    }
    function xf(e, t) {
      e.finishedWork = null, e.finishedLanes = oe;
      var o = e.timeoutHandle;
      if (o !== V1 && (e.timeoutHandle = V1, m5(o)), Qn !== null)
        for (var l = Qn.return; l !== null; ) {
          var f = l.alternate;
          QR(f, l), l = l.return;
        }
      ei = e;
      var m = Ef(e.current, null);
      return Qn = m, Nr = Bs = t, Fr = Vl, dv = null, q0 = oe, pv = oe, Q0 = oe, hv = null, Ti = null, PL(), Yo.discardPendingWarnings(), m;
    }
    function x_(e, t) {
      do {
        var o = Qn;
        try {
          if (u0(), Xk(), Yn(), OC.current = null, o === null || o.return === null) {
            Fr = cv, dv = t, Qn = null;
            return;
          }
          if (bt && o.mode & Xe && B0(o, !0), Vn)
            if (dl(), t !== null && typeof t == "object" && typeof t.then == "function") {
              var l = t;
              sg(o, l, Nr);
            } else
              Sd(o, t, Nr);
          f$(e, o.return, o, t, Nr), T_(o);
        } catch (f) {
          t = f, Qn === o && o !== null ? (o = o.return, Qn = o) : o = Qn;
          continue;
        }
        return;
      } while (!0);
    }
    function C_() {
      var e = MC.current;
      return MC.current = $0, e === null ? $0 : e;
    }
    function E_(e) {
      MC.current = e;
    }
    function UN() {
      LC = zn();
    }
    function bv(e) {
      q0 = pt(e, q0);
    }
    function IN() {
      Fr === Vl && (Fr = G0);
    }
    function HC() {
      (Fr === Vl || Fr === G0 || Fr === bf) && (Fr = fv), ei !== null && (Wc(q0) || Wc(pv)) && tc(ei, Nr);
    }
    function HN(e) {
      Fr !== fv && (Fr = bf), hv === null ? hv = [e] : hv.push(e);
    }
    function WN() {
      return Fr === Vl;
    }
    function nb(e, t) {
      var o = Dt;
      Dt |= pa;
      var l = C_();
      if (ei !== e || Nr !== t) {
        if (Ar) {
          var f = e.memoizedUpdaters;
          f.size > 0 && (Sv(e, Nr), f.clear()), Ud(e, t);
        }
        jl = cm(), xf(e, t);
      }
      Bi(t);
      do
        try {
          YN();
          break;
        } catch (m) {
          x_(e, m);
        }
      while (!0);
      if (u0(), Dt = o, E_(l), Qn !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Su(), ei = null, Nr = oe, Fr;
    }
    function YN() {
      for (; Qn !== null; )
        w_(Qn);
    }
    function GN(e, t) {
      var o = Dt;
      Dt |= pa;
      var l = C_();
      if (ei !== e || Nr !== t) {
        if (Ar) {
          var f = e.memoizedUpdaters;
          f.size > 0 && (Sv(e, Nr), f.clear()), Ud(e, t);
        }
        jl = cm(), mv(), xf(e, t);
      }
      Bi(t);
      do
        try {
          qN();
          break;
        } catch (m) {
          x_(e, m);
        }
      while (!0);
      return u0(), E_(l), Dt = o, Qn !== null ? (jc(), Vl) : (Su(), ei = null, Nr = oe, Fr);
    }
    function qN() {
      for (; Qn !== null && !hd(); )
        w_(Qn);
    }
    function w_(e) {
      var t = e.alternate;
      Ht(e);
      var o;
      (e.mode & Xe) !== Qe ? (iC(e), o = WC(t, e, Bs), B0(e, !0)) : o = WC(t, e, Bs), Yn(), e.memoizedProps = e.pendingProps, o === null ? T_(e) : Qn = o, OC.current = null;
    }
    function T_(e) {
      var t = e;
      do {
        var o = t.alternate, l = t.return;
        if ((t.flags & Ga) === We) {
          Ht(t);
          var f = void 0;
          if ((t.mode & Xe) === Qe ? f = qR(o, t, Bs) : (iC(t), f = qR(o, t, Bs), B0(t, !1)), Yn(), f !== null) {
            Qn = f;
            return;
          }
        } else {
          var m = I$(o, t);
          if (m !== null) {
            m.flags &= Zy, Qn = m;
            return;
          }
          if ((t.mode & Xe) !== Qe) {
            B0(t, !1);
            for (var g = t.actualDuration, C = t.child; C !== null; )
              g += C.actualDuration, C = C.sibling;
            t.actualDuration = g;
          }
          if (l !== null)
            l.flags |= Ga, l.subtreeFlags = We, l.deletions = null;
          else {
            Fr = zC, Qn = null;
            return;
          }
        }
        var T = t.sibling;
        if (T !== null) {
          Qn = T;
          return;
        }
        t = l, Qn = t;
      } while (t !== null);
      Fr === Vl && (Fr = d_);
    }
    function Cf(e, t, o) {
      var l = gi(), f = da.transition;
      try {
        da.transition = null, sr(qr), QN(e, t, o, l);
      } finally {
        da.transition = f, sr(l);
      }
      return null;
    }
    function QN(e, t, o, l) {
      do
        Ul();
      while (Ju !== null);
      if (o3(), (Dt & (pa | po)) !== $r)
        throw new Error("Should not already be working.");
      var f = e.finishedWork, m = e.finishedLanes;
      if (yd(m), f === null)
        return Xh(), null;
      if (m === oe && h("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = oe, f === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = _t;
      var g = pt(f.lanes, f.childLanes);
      lm(e, g), e === ei && (ei = null, Qn = null, Nr = oe), ((f.subtreeFlags & pi) !== We || (f.flags & pi) !== We) && (Sf || (Sf = !0, FC = o, qC(no, function() {
        return Ul(), null;
      })));
      var C = (f.subtreeFlags & (yu | Ma | Gr | pi)) !== We, T = (f.flags & (yu | Ma | Gr | pi)) !== We;
      if (C || T) {
        var D = da.transition;
        da.transition = null;
        var M = gi();
        sr(qr);
        var U = Dt;
        Dt |= po, OC.current = null, q$(e, f), CR(), lN(e, f, m), l5(e.containerInfo), e.current = f, lg(m), uN(f, e, m), bu(), tg(), Dt = U, sr(M), da.transition = D;
      } else
        e.current = f, CR();
      var V = Sf;
      if (Sf ? (Sf = !1, Ju = e, vv = m) : (Mp = 0, Z0 = null), g = e.pendingLanes, g === oe && (Ap = null), V || D_(e.current, !1), $o(f.stateNode, l), Ar && e.memoizedUpdaters.clear(), _N(), ki(e, zn()), t !== null)
        for (var Z = e.onRecoverableError, J = 0; J < t.length; J++) {
          var ae = t[J], Re = ae.stack, qe = ae.digest;
          Z(ae.value, {
            componentStack: Re,
            digest: qe
          });
        }
      if (K0) {
        K0 = !1;
        var je = $C;
        throw $C = null, je;
      }
      return La(vv, Ze) && e.tag !== Iu && Ul(), g = e.pendingLanes, La(g, Ze) ? (a$(), e === VC ? yv++ : (yv = 0, VC = e)) : yv = 0, Hu(), Xh(), null;
    }
    function Ul() {
      if (Ju !== null) {
        var e = Qc(vv), t = u1(Vo, e), o = da.transition, l = gi();
        try {
          return da.transition = null, sr(t), XN();
        } finally {
          sr(l), da.transition = o;
        }
      }
      return !1;
    }
    function KN(e) {
      NC.push(e), Sf || (Sf = !0, qC(no, function() {
        return Ul(), null;
      }));
    }
    function XN() {
      if (Ju === null)
        return !1;
      var e = FC;
      FC = null;
      var t = Ju, o = vv;
      if (Ju = null, vv = oe, (Dt & (pa | po)) !== $r)
        throw new Error("Cannot flush passive effects while already rendering.");
      jC = !0, X0 = !1, ug(o);
      var l = Dt;
      Dt |= po, vN(t.current), dN(t, t.current, o, e);
      {
        var f = NC;
        NC = [];
        for (var m = 0; m < f.length; m++) {
          var g = f[m];
          Z$(t, g);
        }
      }
      Vc(), D_(t.current, !0), Dt = l, Hu(), X0 ? t === Z0 ? Mp++ : (Mp = 0, Z0 = t) : Mp = 0, jC = !1, X0 = !1, xs(t);
      {
        var C = t.current.stateNode;
        C.effectDuration = 0, C.passiveEffectDuration = 0;
      }
      return !0;
    }
    function k_(e) {
      return Ap !== null && Ap.has(e);
    }
    function ZN(e) {
      Ap === null ? Ap = /* @__PURE__ */ new Set([e]) : Ap.add(e);
    }
    function JN(e) {
      K0 || (K0 = !0, $C = e);
    }
    var e3 = JN;
    function R_(e, t, o) {
      var l = yf(o, t), f = wR(e, l, Ze), m = Yu(e, f, Ze), g = ti();
      m !== null && (Cl(m, Ze, g), ki(m, g));
    }
    function Tn(e, t, o) {
      if (W$(o), xv(!1), e.tag === k) {
        R_(e, e, o);
        return;
      }
      var l = null;
      for (l = t; l !== null; ) {
        if (l.tag === k) {
          R_(l, e, o);
          return;
        } else if (l.tag === E) {
          var f = l.type, m = l.stateNode;
          if (typeof f.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && !k_(m)) {
            var g = yf(o, e), C = fC(l, g, Ze), T = Yu(l, C, Ze), D = ti();
            T !== null && (Cl(T, Ze, D), ki(T, D));
            return;
          }
        }
        l = l.return;
      }
      h(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, o);
    }
    function t3(e, t, o) {
      var l = e.pingCache;
      l !== null && l.delete(t);
      var f = ti();
      sm(e, o), c3(e), ei === e && xl(Nr, o) && (Fr === fv || Fr === G0 && Vd(Nr) && zn() - LC < p_ ? xf(e, oe) : Q0 = pt(Q0, o)), ki(e, f);
    }
    function __(e, t) {
      t === _t && (t = LN(e));
      var o = ti(), l = Ei(e, t);
      l !== null && (Cl(l, t, o), ki(l, o));
    }
    function n3(e) {
      var t = e.memoizedState, o = _t;
      t !== null && (o = t.retryLane), __(e, o);
    }
    function r3(e, t) {
      var o = _t, l;
      switch (e.tag) {
        case H:
          l = e.stateNode;
          var f = e.memoizedState;
          f !== null && (o = f.retryLane);
          break;
        case vt:
          l = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      l !== null && l.delete(t), __(e, o);
    }
    function a3(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : MN(e / 1960) * 1960;
    }
    function i3() {
      if (yv > zN)
        throw yv = 0, VC = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Mp > PN && (Mp = 0, Z0 = null, h("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function o3() {
      Yo.flushLegacyContextWarning(), Yo.flushPendingUnsafeLifecycleWarnings();
    }
    function D_(e, t) {
      Ht(e), rb(e, Aa, TN), t && rb(e, fl, kN), rb(e, Aa, EN), t && rb(e, fl, wN), Yn();
    }
    function rb(e, t, o) {
      for (var l = e, f = null; l !== null; ) {
        var m = l.subtreeFlags & t;
        l !== f && l.child !== null && m !== We ? l = l.child : ((l.flags & t) !== We && o(l), l.sibling !== null ? l = l.sibling : l = f = l.return);
      }
    }
    var ab = null;
    function A_(e) {
      {
        if ((Dt & pa) !== $r || !(e.mode & xt))
          return;
        var t = e.tag;
        if (t !== w && t !== k && t !== E && t !== x && t !== F && t !== le && t !== re)
          return;
        var o = st(e) || "ReactComponent";
        if (ab !== null) {
          if (ab.has(o))
            return;
          ab.add(o);
        } else
          ab = /* @__PURE__ */ new Set([o]);
        var l = Sn;
        try {
          Ht(e), h("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          l ? Ht(e) : Yn();
        }
      }
    }
    var WC;
    {
      var s3 = null;
      WC = function(e, t, o) {
        var l = F_(s3, t);
        try {
          return IR(e, t, o);
        } catch (m) {
          if (SL() || m !== null && typeof m == "object" && typeof m.then == "function")
            throw m;
          if (u0(), Xk(), QR(e, t), F_(t, l), t.mode & Xe && iC(t), cl(null, IR, null, e, t, o), n1()) {
            var f = jh();
            typeof f == "object" && f !== null && f._suppressLogging && typeof m == "object" && m !== null && !m._suppressLogging && (m._suppressLogging = !0);
          }
          throw m;
        }
      };
    }
    var M_ = !1, YC;
    YC = /* @__PURE__ */ new Set();
    function l3(e) {
      if (Hr && !t$())
        switch (e.tag) {
          case x:
          case F:
          case re: {
            var t = Qn && st(Qn) || "Unknown", o = t;
            if (!YC.has(o)) {
              YC.add(o);
              var l = st(e) || "Unknown";
              h("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", l, t, t);
            }
            break;
          }
          case E: {
            M_ || (h("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), M_ = !0);
            break;
          }
        }
    }
    function Sv(e, t) {
      if (Ar) {
        var o = e.memoizedUpdaters;
        o.forEach(function(l) {
          um(e, l, t);
        });
      }
    }
    var GC = {};
    function qC(e, t) {
      {
        var o = es.current;
        return o !== null ? (o.push(t), GC) : pd(e, t);
      }
    }
    function O_(e) {
      if (e !== GC)
        return eg(e);
    }
    function z_() {
      return es.current !== null;
    }
    function u3(e) {
      {
        if (e.mode & xt) {
          if (!c_())
            return;
        } else if (!AN() || Dt !== $r || e.tag !== x && e.tag !== F && e.tag !== re)
          return;
        if (es.current === null) {
          var t = Sn;
          try {
            Ht(e), h(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, st(e));
          } finally {
            t ? Ht(e) : Yn();
          }
        }
      }
    }
    function c3(e) {
      e.tag !== Iu && c_() && es.current === null && h(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function xv(e) {
      v_ = e;
    }
    var ho = null, Op = null, f3 = function(e) {
      ho = e;
    };
    function zp(e) {
      {
        if (ho === null)
          return e;
        var t = ho(e);
        return t === void 0 ? e : t.current;
      }
    }
    function QC(e) {
      return zp(e);
    }
    function KC(e) {
      {
        if (ho === null)
          return e;
        var t = ho(e);
        if (t === void 0) {
          if (e != null && typeof e.render == "function") {
            var o = zp(e.render);
            if (e.render !== o) {
              var l = {
                $$typeof: He,
                render: o
              };
              return e.displayName !== void 0 && (l.displayName = e.displayName), l;
            }
          }
          return e;
        }
        return t.current;
      }
    }
    function P_(e, t) {
      {
        if (ho === null)
          return !1;
        var o = e.elementType, l = t.type, f = !1, m = typeof l == "object" && l !== null ? l.$$typeof : null;
        switch (e.tag) {
          case E: {
            typeof l == "function" && (f = !0);
            break;
          }
          case x: {
            (typeof l == "function" || m === Ge) && (f = !0);
            break;
          }
          case F: {
            (m === He || m === Ge) && (f = !0);
            break;
          }
          case le:
          case re: {
            (m === ft || m === Ge) && (f = !0);
            break;
          }
          default:
            return !1;
        }
        if (f) {
          var g = ho(o);
          if (g !== void 0 && g === ho(l))
            return !0;
        }
        return !1;
      }
    }
    function L_(e) {
      {
        if (ho === null || typeof WeakSet != "function")
          return;
        Op === null && (Op = /* @__PURE__ */ new WeakSet()), Op.add(e);
      }
    }
    var d3 = function(e, t) {
      {
        if (ho === null)
          return;
        var o = t.staleFamilies, l = t.updatedFamilies;
        Ul(), Bl(function() {
          XC(e.current, l, o);
        });
      }
    }, p3 = function(e, t) {
      {
        if (e.context !== Ii)
          return;
        Ul(), Bl(function() {
          Cv(t, e, null, null);
        });
      }
    };
    function XC(e, t, o) {
      {
        var l = e.alternate, f = e.child, m = e.sibling, g = e.tag, C = e.type, T = null;
        switch (g) {
          case x:
          case re:
          case E:
            T = C;
            break;
          case F:
            T = C.render;
            break;
        }
        if (ho === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var D = !1, M = !1;
        if (T !== null) {
          var U = ho(T);
          U !== void 0 && (o.has(U) ? M = !0 : t.has(U) && (g === E ? M = !0 : D = !0));
        }
        if (Op !== null && (Op.has(e) || l !== null && Op.has(l)) && (M = !0), M && (e._debugNeedsRemount = !0), M || D) {
          var V = Ei(e, Ze);
          V !== null && Vr(V, e, Ze, dn);
        }
        f !== null && !M && XC(f, t, o), m !== null && XC(m, t, o);
      }
    }
    var h3 = function(e, t) {
      {
        var o = /* @__PURE__ */ new Set(), l = new Set(t.map(function(f) {
          return f.current;
        }));
        return ZC(e.current, l, o), o;
      }
    };
    function ZC(e, t, o) {
      {
        var l = e.child, f = e.sibling, m = e.tag, g = e.type, C = null;
        switch (m) {
          case x:
          case re:
          case E:
            C = g;
            break;
          case F:
            C = g.render;
            break;
        }
        var T = !1;
        C !== null && t.has(C) && (T = !0), T ? m3(e, o) : l !== null && ZC(l, t, o), f !== null && ZC(f, t, o);
      }
    }
    function m3(e, t) {
      {
        var o = v3(e, t);
        if (o)
          return;
        for (var l = e; ; ) {
          switch (l.tag) {
            case A:
              t.add(l.stateNode);
              return;
            case _:
              t.add(l.stateNode.containerInfo);
              return;
            case k:
              t.add(l.stateNode.containerInfo);
              return;
          }
          if (l.return === null)
            throw new Error("Expected to reach root first.");
          l = l.return;
        }
      }
    }
    function v3(e, t) {
      for (var o = e, l = !1; ; ) {
        if (o.tag === A)
          l = !0, t.add(o.stateNode);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === e)
          return l;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === e)
            return l;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return !1;
    }
    var JC;
    {
      JC = !1;
      try {
        var $_ = Object.preventExtensions({});
      } catch {
        JC = !0;
      }
    }
    function y3(e, t, o, l) {
      this.tag = e, this.key = o, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = t, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = l, this.flags = We, this.subtreeFlags = We, this.deletions = null, this.lanes = oe, this.childLanes = oe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !JC && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Hi = function(e, t, o, l) {
      return new y3(e, t, o, l);
    };
    function eE(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function g3(e) {
      return typeof e == "function" && !eE(e) && e.defaultProps === void 0;
    }
    function b3(e) {
      if (typeof e == "function")
        return eE(e) ? E : x;
      if (e != null) {
        var t = e.$$typeof;
        if (t === He)
          return F;
        if (t === ft)
          return le;
      }
      return w;
    }
    function Ef(e, t) {
      var o = e.alternate;
      o === null ? (o = Hi(e.tag, t, e.key, e.mode), o.elementType = e.elementType, o.type = e.type, o.stateNode = e.stateNode, o._debugSource = e._debugSource, o._debugOwner = e._debugOwner, o._debugHookTypes = e._debugHookTypes, o.alternate = e, e.alternate = o) : (o.pendingProps = t, o.type = e.type, o.flags = We, o.subtreeFlags = We, o.deletions = null, o.actualDuration = 0, o.actualStartTime = -1), o.flags = e.flags & Dr, o.childLanes = e.childLanes, o.lanes = e.lanes, o.child = e.child, o.memoizedProps = e.memoizedProps, o.memoizedState = e.memoizedState, o.updateQueue = e.updateQueue;
      var l = e.dependencies;
      switch (o.dependencies = l === null ? null : {
        lanes: l.lanes,
        firstContext: l.firstContext
      }, o.sibling = e.sibling, o.index = e.index, o.ref = e.ref, o.selfBaseDuration = e.selfBaseDuration, o.treeBaseDuration = e.treeBaseDuration, o._debugNeedsRemount = e._debugNeedsRemount, o.tag) {
        case w:
        case x:
        case re:
          o.type = zp(e.type);
          break;
        case E:
          o.type = QC(e.type);
          break;
        case F:
          o.type = KC(e.type);
          break;
      }
      return o;
    }
    function S3(e, t) {
      e.flags &= Dr | xn;
      var o = e.alternate;
      if (o === null)
        e.childLanes = oe, e.lanes = t, e.child = null, e.subtreeFlags = We, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = o.childLanes, e.lanes = o.lanes, e.child = o.child, e.subtreeFlags = We, e.deletions = null, e.memoizedProps = o.memoizedProps, e.memoizedState = o.memoizedState, e.updateQueue = o.updateQueue, e.type = o.type;
        var l = o.dependencies;
        e.dependencies = l === null ? null : {
          lanes: l.lanes,
          firstContext: l.firstContext
        }, e.selfBaseDuration = o.selfBaseDuration, e.treeBaseDuration = o.treeBaseDuration;
      }
      return e;
    }
    function x3(e, t, o) {
      var l;
      return e === t0 ? (l = xt, t === !0 && (l |= Pn, l |= mi)) : l = Qe, Ar && (l |= Xe), Hi(k, null, null, l);
    }
    function tE(e, t, o, l, f, m) {
      var g = w, C = e;
      if (typeof e == "function")
        eE(e) ? (g = E, C = QC(C)) : C = zp(C);
      else if (typeof e == "string")
        g = A;
      else
        e:
          switch (e) {
            case Wa:
              return nc(o.children, f, m, t);
            case aa:
              g = Y, f |= Pn, (f & xt) !== Qe && (f |= mi);
              break;
            case P:
              return C3(o, f, m, t);
            case ct:
              return E3(o, f, m, t);
            case gt:
              return w3(o, f, m, t);
            case vn:
              return N_(o, f, m, t);
            case Rr:
            case Xn:
            case li:
            case nu:
            case mn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case ce:
                    g = W;
                    break e;
                  case be:
                    g = K;
                    break e;
                  case He:
                    g = F, C = KC(C);
                    break e;
                  case ft:
                    g = le;
                    break e;
                  case Ge:
                    g = De, C = null;
                    break e;
                }
              var T = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (T += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var D = l ? st(l) : null;
                D && (T += `

Check the render method of \`` + D + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + T));
            }
          }
      var M = Hi(g, o, t, f);
      return M.elementType = e, M.type = C, M.lanes = m, M._debugOwner = l, M;
    }
    function nE(e, t, o) {
      var l = null;
      l = e._owner;
      var f = e.type, m = e.key, g = e.props, C = tE(f, m, g, l, t, o);
      return C._debugSource = e._source, C._debugOwner = e._owner, C;
    }
    function nc(e, t, o, l) {
      var f = Hi($, e, l, t);
      return f.lanes = o, f;
    }
    function C3(e, t, o, l) {
      typeof e.id != "string" && h('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var f = Hi(ne, e, l, t | Xe);
      return f.elementType = P, f.lanes = o, f.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, f;
    }
    function E3(e, t, o, l) {
      var f = Hi(H, e, l, t);
      return f.elementType = ct, f.lanes = o, f;
    }
    function w3(e, t, o, l) {
      var f = Hi(vt, e, l, t);
      return f.elementType = gt, f.lanes = o, f;
    }
    function N_(e, t, o, l) {
      var f = Hi($e, e, l, t);
      f.elementType = vn, f.lanes = o;
      var m = {
        isHidden: !1
      };
      return f.stateNode = m, f;
    }
    function rE(e, t, o) {
      var l = Hi(L, e, null, t);
      return l.lanes = o, l;
    }
    function T3() {
      var e = Hi(A, null, null, Qe);
      return e.elementType = "DELETED", e;
    }
    function k3(e) {
      var t = Hi(ot, null, null, Qe);
      return t.stateNode = e, t;
    }
    function aE(e, t, o) {
      var l = e.children !== null ? e.children : [], f = Hi(_, l, e.key, t);
      return f.lanes = o, f.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, f;
    }
    function F_(e, t) {
      return e === null && (e = Hi(w, null, null, Qe)), e.tag = t.tag, e.key = t.key, e.elementType = t.elementType, e.type = t.type, e.stateNode = t.stateNode, e.return = t.return, e.child = t.child, e.sibling = t.sibling, e.index = t.index, e.ref = t.ref, e.pendingProps = t.pendingProps, e.memoizedProps = t.memoizedProps, e.updateQueue = t.updateQueue, e.memoizedState = t.memoizedState, e.dependencies = t.dependencies, e.mode = t.mode, e.flags = t.flags, e.subtreeFlags = t.subtreeFlags, e.deletions = t.deletions, e.lanes = t.lanes, e.childLanes = t.childLanes, e.alternate = t.alternate, e.actualDuration = t.actualDuration, e.actualStartTime = t.actualStartTime, e.selfBaseDuration = t.selfBaseDuration, e.treeBaseDuration = t.treeBaseDuration, e._debugSource = t._debugSource, e._debugOwner = t._debugOwner, e._debugNeedsRemount = t._debugNeedsRemount, e._debugHookTypes = t._debugHookTypes, e;
    }
    function R3(e, t, o, l, f) {
      this.tag = t, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = V1, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = _t, this.eventTimes = Bd(oe), this.expirationTimes = Bd(dn), this.pendingLanes = oe, this.suspendedLanes = oe, this.pingedLanes = oe, this.expiredLanes = oe, this.mutableReadLanes = oe, this.finishedLanes = oe, this.entangledLanes = oe, this.entanglements = Bd(oe), this.identifierPrefix = l, this.onRecoverableError = f, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var m = this.pendingUpdatersLaneMap = [], g = 0; g < En; g++)
          m.push(/* @__PURE__ */ new Set());
      }
      switch (t) {
        case t0:
          this._debugRootType = o ? "hydrateRoot()" : "createRoot()";
          break;
        case Iu:
          this._debugRootType = o ? "hydrate()" : "render()";
          break;
      }
    }
    function V_(e, t, o, l, f, m, g, C, T, D) {
      var M = new R3(e, t, o, C, T), U = x3(t, m);
      M.current = U, U.stateNode = M;
      {
        var V = {
          element: l,
          isDehydrated: o,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        U.memoizedState = V;
      }
      return dx(U), M;
    }
    var iE = "18.2.0";
    function _3(e, t, o) {
      var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Ua(l), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: ra,
        key: l == null ? null : "" + l,
        children: e,
        containerInfo: t,
        implementation: o
      };
    }
    var oE, sE;
    oE = !1, sE = {};
    function j_(e) {
      if (!e)
        return Ii;
      var t = ci(e), o = fL(t);
      if (t.tag === E) {
        var l = t.type;
        if (Ps(l))
          return dk(t, l, o);
      }
      return o;
    }
    function D3(e, t) {
      {
        var o = ci(e);
        if (o === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var l = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + l);
        }
        var f = hi(o);
        if (f === null)
          return null;
        if (f.mode & Pn) {
          var m = st(o) || "Component";
          if (!sE[m]) {
            sE[m] = !0;
            var g = Sn;
            try {
              Ht(f), o.mode & Pn ? h("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, m) : h("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, m);
            } finally {
              g ? Ht(g) : Yn();
            }
          }
        }
        return f.stateNode;
      }
    }
    function B_(e, t, o, l, f, m, g, C) {
      var T = !1, D = null;
      return V_(e, t, T, D, o, l, f, m, g);
    }
    function U_(e, t, o, l, f, m, g, C, T, D) {
      var M = !0, U = V_(o, l, M, e, f, m, g, C, T);
      U.context = j_(null);
      var V = U.current, Z = ti(), J = ec(V), ae = Nl(Z, J);
      return ae.callback = t ?? null, Yu(V, ae, J), $N(U, J, Z), U;
    }
    function Cv(e, t, o, l) {
      ng(t, e);
      var f = t.current, m = ti(), g = ec(f);
      pl(g);
      var C = j_(o);
      t.context === null ? t.context = C : t.pendingContext = C, Hr && Sn !== null && !oE && (oE = !0, h(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, st(Sn) || "Unknown"));
      var T = Nl(m, g);
      T.payload = {
        element: e
      }, l = l === void 0 ? null : l, l !== null && (typeof l != "function" && h("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", l), T.callback = l);
      var D = Yu(f, T, g);
      return D !== null && (Vr(D, f, g, m), h0(D, f, g)), g;
    }
    function ib(e) {
      var t = e.current;
      if (!t.child)
        return null;
      switch (t.child.tag) {
        case A:
          return t.child.stateNode;
        default:
          return t.child.stateNode;
      }
    }
    function A3(e) {
      switch (e.tag) {
        case k: {
          var t = e.stateNode;
          if (lr(t)) {
            var o = i1(t);
            jN(t, o);
          }
          break;
        }
        case H: {
          Bl(function() {
            var f = Ei(e, Ze);
            if (f !== null) {
              var m = ti();
              Vr(f, e, Ze, m);
            }
          });
          var l = Ze;
          lE(e, l);
          break;
        }
      }
    }
    function I_(e, t) {
      var o = e.memoizedState;
      o !== null && o.dehydrated !== null && (o.retryLane = hg(o.retryLane, t));
    }
    function lE(e, t) {
      I_(e, t);
      var o = e.alternate;
      o && I_(o, t);
    }
    function M3(e) {
      if (e.tag === H) {
        var t = xu, o = Ei(e, t);
        if (o !== null) {
          var l = ti();
          Vr(o, e, t, l);
        }
        lE(e, t);
      }
    }
    function O3(e) {
      if (e.tag === H) {
        var t = ec(e), o = Ei(e, t);
        if (o !== null) {
          var l = ti();
          Vr(o, e, t, l);
        }
        lE(e, t);
      }
    }
    function H_(e) {
      var t = Jy(e);
      return t === null ? null : t.stateNode;
    }
    var W_ = function(e) {
      return null;
    };
    function z3(e) {
      return W_(e);
    }
    var Y_ = function(e) {
      return !1;
    };
    function P3(e) {
      return Y_(e);
    }
    var G_ = null, q_ = null, Q_ = null, K_ = null, X_ = null, Z_ = null, J_ = null, eD = null, tD = null;
    {
      var nD = function(e, t, o) {
        var l = t[o], f = vr(e) ? e.slice() : mt({}, e);
        return o + 1 === t.length ? (vr(f) ? f.splice(l, 1) : delete f[l], f) : (f[l] = nD(e[l], t, o + 1), f);
      }, rD = function(e, t) {
        return nD(e, t, 0);
      }, aD = function(e, t, o, l) {
        var f = t[l], m = vr(e) ? e.slice() : mt({}, e);
        if (l + 1 === t.length) {
          var g = o[l];
          m[g] = m[f], vr(m) ? m.splice(f, 1) : delete m[f];
        } else
          m[f] = aD(
            // $FlowFixMe number or string is fine here
            e[f],
            t,
            o,
            l + 1
          );
        return m;
      }, iD = function(e, t, o) {
        if (t.length !== o.length) {
          v("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var l = 0; l < o.length - 1; l++)
            if (t[l] !== o[l]) {
              v("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return aD(e, t, o, 0);
      }, oD = function(e, t, o, l) {
        if (o >= t.length)
          return l;
        var f = t[o], m = vr(e) ? e.slice() : mt({}, e);
        return m[f] = oD(e[f], t, o + 1, l), m;
      }, sD = function(e, t, o) {
        return oD(e, t, 0, o);
      }, uE = function(e, t) {
        for (var o = e.memoizedState; o !== null && t > 0; )
          o = o.next, t--;
        return o;
      };
      G_ = function(e, t, o, l) {
        var f = uE(e, t);
        if (f !== null) {
          var m = sD(f.memoizedState, o, l);
          f.memoizedState = m, f.baseState = m, e.memoizedProps = mt({}, e.memoizedProps);
          var g = Ei(e, Ze);
          g !== null && Vr(g, e, Ze, dn);
        }
      }, q_ = function(e, t, o) {
        var l = uE(e, t);
        if (l !== null) {
          var f = rD(l.memoizedState, o);
          l.memoizedState = f, l.baseState = f, e.memoizedProps = mt({}, e.memoizedProps);
          var m = Ei(e, Ze);
          m !== null && Vr(m, e, Ze, dn);
        }
      }, Q_ = function(e, t, o, l) {
        var f = uE(e, t);
        if (f !== null) {
          var m = iD(f.memoizedState, o, l);
          f.memoizedState = m, f.baseState = m, e.memoizedProps = mt({}, e.memoizedProps);
          var g = Ei(e, Ze);
          g !== null && Vr(g, e, Ze, dn);
        }
      }, K_ = function(e, t, o) {
        e.pendingProps = sD(e.memoizedProps, t, o), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var l = Ei(e, Ze);
        l !== null && Vr(l, e, Ze, dn);
      }, X_ = function(e, t) {
        e.pendingProps = rD(e.memoizedProps, t), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var o = Ei(e, Ze);
        o !== null && Vr(o, e, Ze, dn);
      }, Z_ = function(e, t, o) {
        e.pendingProps = iD(e.memoizedProps, t, o), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var l = Ei(e, Ze);
        l !== null && Vr(l, e, Ze, dn);
      }, J_ = function(e) {
        var t = Ei(e, Ze);
        t !== null && Vr(t, e, Ze, dn);
      }, eD = function(e) {
        W_ = e;
      }, tD = function(e) {
        Y_ = e;
      };
    }
    function L3(e) {
      var t = hi(e);
      return t === null ? null : t.stateNode;
    }
    function $3(e) {
      return null;
    }
    function N3() {
      return Sn;
    }
    function F3(e) {
      var t = e.findFiberByHostInstance, o = s.ReactCurrentDispatcher;
      return Qh({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: G_,
        overrideHookStateDeletePath: q_,
        overrideHookStateRenamePath: Q_,
        overrideProps: K_,
        overridePropsDeletePath: X_,
        overridePropsRenamePath: Z_,
        setErrorHandler: eD,
        setSuspenseHandler: tD,
        scheduleUpdate: J_,
        currentDispatcherRef: o,
        findHostInstanceByFiber: L3,
        findFiberByHostInstance: t || $3,
        // React Refresh
        findHostInstancesForRefresh: h3,
        scheduleRefresh: d3,
        scheduleRoot: p3,
        setRefreshHandler: f3,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: N3,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: iE
      });
    }
    var lD = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function cE(e) {
      this._internalRoot = e;
    }
    ob.prototype.render = cE.prototype.render = function(e) {
      var t = this._internalRoot;
      if (t === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? h("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : sb(arguments[1]) ? h("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && h("You passed a second argument to root.render(...) but it only accepts one argument.");
        var o = t.containerInfo;
        if (o.nodeType !== Jn) {
          var l = H_(t.current);
          l && l.parentNode !== o && h("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Cv(e, t, null, null);
    }, ob.prototype.unmount = cE.prototype.unmount = function() {
      typeof arguments[0] == "function" && h("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        S_() && h("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Bl(function() {
          Cv(null, e, null, null);
        }), sk(t);
      }
    };
    function V3(e, t) {
      if (!sb(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      uD(e);
      var o = !1, l = !1, f = "", m = lD;
      t != null && (t.hydrate ? v("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof t == "object" && t !== null && t.$$typeof === Zi && h(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), t.unstable_strictMode === !0 && (o = !0), t.identifierPrefix !== void 0 && (f = t.identifierPrefix), t.onRecoverableError !== void 0 && (m = t.onRecoverableError), t.transitionCallbacks !== void 0 && t.transitionCallbacks);
      var g = B_(e, t0, null, o, l, f, m);
      qg(g.current, e);
      var C = e.nodeType === Jn ? e.parentNode : e;
      return Am(C), new cE(g);
    }
    function ob(e) {
      this._internalRoot = e;
    }
    function j3(e) {
      e && Cg(e);
    }
    ob.prototype.unstable_scheduleHydration = j3;
    function B3(e, t, o) {
      if (!sb(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      uD(e), t === void 0 && h("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var l = o ?? null, f = o != null && o.hydratedSources || null, m = !1, g = !1, C = "", T = lD;
      o != null && (o.unstable_strictMode === !0 && (m = !0), o.identifierPrefix !== void 0 && (C = o.identifierPrefix), o.onRecoverableError !== void 0 && (T = o.onRecoverableError));
      var D = U_(t, null, e, t0, l, m, g, C, T);
      if (qg(D.current, e), Am(e), f)
        for (var M = 0; M < f.length; M++) {
          var U = f[M];
          QL(D, U);
        }
      return new ob(D);
    }
    function sb(e) {
      return !!(e && (e.nodeType === Ra || e.nodeType === Fi || e.nodeType === al || !Ye));
    }
    function Ev(e) {
      return !!(e && (e.nodeType === Ra || e.nodeType === Fi || e.nodeType === al || e.nodeType === Jn && e.nodeValue === " react-mount-point-unstable "));
    }
    function uD(e) {
      e.nodeType === Ra && e.tagName && e.tagName.toUpperCase() === "BODY" && h("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Bm(e) && (e._reactRootContainer ? h("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : h("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var U3 = s.ReactCurrentOwner, cD;
    cD = function(e) {
      if (e._reactRootContainer && e.nodeType !== Jn) {
        var t = H_(e._reactRootContainer.current);
        t && t.parentNode !== e && h("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var o = !!e._reactRootContainer, l = fE(e), f = !!(l && Bu(l));
      f && !o && h("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === Ra && e.tagName && e.tagName.toUpperCase() === "BODY" && h("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function fE(e) {
      return e ? e.nodeType === Fi ? e.documentElement : e.firstChild : null;
    }
    function fD() {
    }
    function I3(e, t, o, l, f) {
      if (f) {
        if (typeof l == "function") {
          var m = l;
          l = function() {
            var V = ib(g);
            m.call(V);
          };
        }
        var g = U_(
          t,
          l,
          e,
          Iu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          fD
        );
        e._reactRootContainer = g, qg(g.current, e);
        var C = e.nodeType === Jn ? e.parentNode : e;
        return Am(C), Bl(), g;
      } else {
        for (var T; T = e.lastChild; )
          e.removeChild(T);
        if (typeof l == "function") {
          var D = l;
          l = function() {
            var V = ib(M);
            D.call(V);
          };
        }
        var M = B_(
          e,
          Iu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          fD
        );
        e._reactRootContainer = M, qg(M.current, e);
        var U = e.nodeType === Jn ? e.parentNode : e;
        return Am(U), Bl(function() {
          Cv(t, M, o, l);
        }), M;
      }
    }
    function H3(e, t) {
      e !== null && typeof e != "function" && h("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e);
    }
    function lb(e, t, o, l, f) {
      cD(o), H3(f === void 0 ? null : f, "render");
      var m = o._reactRootContainer, g;
      if (!m)
        g = I3(o, t, e, f, l);
      else {
        if (g = m, typeof f == "function") {
          var C = f;
          f = function() {
            var T = ib(g);
            C.call(T);
          };
        }
        Cv(t, g, e, f);
      }
      return ib(g);
    }
    function W3(e) {
      {
        var t = U3.current;
        if (t !== null && t.stateNode !== null) {
          var o = t.stateNode._warnedAboutRefsInRender;
          o || h("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Zt(t.type) || "A component"), t.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === Ra ? e : D3(e, "findDOMNode");
    }
    function Y3(e, t, o) {
      if (h("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ev(t))
        throw new Error("Target container is not a DOM element.");
      {
        var l = Bm(t) && t._reactRootContainer === void 0;
        l && h("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return lb(null, e, t, !0, o);
    }
    function G3(e, t, o) {
      if (h("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ev(t))
        throw new Error("Target container is not a DOM element.");
      {
        var l = Bm(t) && t._reactRootContainer === void 0;
        l && h("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return lb(null, e, t, !1, o);
    }
    function q3(e, t, o, l) {
      if (h("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ev(o))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !$c(e))
        throw new Error("parentComponent must be a valid React Component");
      return lb(e, t, o, !1, l);
    }
    function Q3(e) {
      if (!Ev(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var t = Bm(e) && e._reactRootContainer === void 0;
        t && h("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var o = fE(e), l = o && !Bu(o);
          l && h("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Bl(function() {
          lb(null, null, e, !1, function() {
            e._reactRootContainer = null, sk(e);
          });
        }), !0;
      } else {
        {
          var f = fE(e), m = !!(f && Bu(f)), g = e.nodeType === Ra && Ev(e.parentNode) && !!e.parentNode._reactRootContainer;
          m && h("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", g ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Me(A3), vg(M3), Xc(O3), dm(gi), gg(qc), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && h("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Ky(ZP), ld(UC, BN, Bl);
    function K3(e, t) {
      var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!sb(t))
        throw new Error("Target container is not a DOM element.");
      return _3(e, t, null, o);
    }
    function X3(e, t, o, l) {
      return q3(e, t, o, l);
    }
    var dE = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Bu, cp, Qg, sd, zc, UC]
    };
    function Z3(e, t) {
      return dE.usingClientEntryPoint || h('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), V3(e, t);
    }
    function J3(e, t, o) {
      return dE.usingClientEntryPoint || h('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), B3(e, t, o);
    }
    function e4(e) {
      return S_() && h("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Bl(e);
    }
    var t4 = F3({
      findFiberByHostInstance: lf,
      bundleType: 1,
      version: iE,
      rendererPackageName: "react-dom"
    });
    if (!t4 && kn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var dD = window.location.protocol;
      /^(https?|file):$/.test(dD) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (dD === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    _i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = dE, _i.createPortal = K3, _i.createRoot = Z3, _i.findDOMNode = W3, _i.flushSync = e4, _i.hydrate = Y3, _i.hydrateRoot = J3, _i.render = G3, _i.unmountComponentAtNode = Q3, _i.unstable_batchedUpdates = UC, _i.unstable_renderSubtreeIntoContainer = X3, _i.version = iE, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), _i;
}
function nO() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(nO);
    } catch (n) {
      console.error(n);
    }
  }
}
process.env.NODE_ENV === "production" ? (nO(), uw.exports = FV()) : uw.exports = VV();
var rO = uw.exports, [aO, jV] = fy({
  strict: !1,
  name: "PortalContext"
}), Qw = "chakra-portal", BV = ".chakra-portal", UV = (n) => /* @__PURE__ */ Oe.jsx(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: n.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: n.children
  }
), IV = (n) => {
  const { appendToParentPortal: a, children: s } = n, [c, p] = jf(null), v = ga(null), [, h] = jf({});
  Qi(() => h({}), []);
  const b = jV(), x = LV();
  tS(() => {
    if (!c)
      return;
    const w = c.ownerDocument, k = a ? b ?? w.body : w.body;
    if (!k)
      return;
    v.current = w.createElement("div"), v.current.className = Qw, k.appendChild(v.current), h({});
    const _ = v.current;
    return () => {
      k.contains(_) && k.removeChild(_);
    };
  }, [c]);
  const E = x != null && x.zIndex ? /* @__PURE__ */ Oe.jsx(UV, { zIndex: x == null ? void 0 : x.zIndex, children: s }) : s;
  return v.current ? rO.createPortal(
    /* @__PURE__ */ Oe.jsx(aO, { value: v.current, children: E }),
    v.current
  ) : /* @__PURE__ */ Oe.jsx(
    "span",
    {
      ref: (w) => {
        w && p(w);
      }
    }
  );
}, HV = (n) => {
  const { children: a, containerRef: s, appendToParentPortal: c } = n, p = s.current, v = p ?? (typeof window < "u" ? document.body : void 0), h = Ki(() => {
    const x = p == null ? void 0 : p.ownerDocument.createElement("div");
    return x && (x.className = Qw), x;
  }, [p]), [, b] = jf({});
  return tS(() => b({}), []), tS(() => {
    if (!(!h || !v))
      return v.appendChild(h), () => {
        v.removeChild(h);
      };
  }, [h, v]), v && h ? rO.createPortal(
    /* @__PURE__ */ Oe.jsx(aO, { value: c ? h : null, children: a }),
    h
  ) : null;
};
function _S(n) {
  const a = {
    appendToParentPortal: !0,
    ...n
  }, { containerRef: s, ...c } = a;
  return s ? /* @__PURE__ */ Oe.jsx(HV, { containerRef: s, ...c }) : /* @__PURE__ */ Oe.jsx(IV, { ...c });
}
_S.className = Qw;
_S.selector = BV;
_S.displayName = "Portal";
function WV() {
  const n = ar(
    pc
  );
  if (!n)
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  return n;
}
var Kw = Ks({});
Kw.displayName = "ColorModeContext";
function Xw() {
  const n = ar(Kw);
  if (n === void 0)
    throw new Error("useColorMode must be used within a ColorModeProvider");
  return n;
}
var vb = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function YV(n = {}) {
  const { preventTransition: a = !0 } = n, s = {
    setDataset: (c) => {
      const p = a ? s.preventTransition() : void 0;
      document.documentElement.dataset.theme = c, document.documentElement.style.colorScheme = c, p == null || p();
    },
    setClassName(c) {
      document.body.classList.add(c ? vb.dark : vb.light), document.body.classList.remove(c ? vb.light : vb.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(c) {
      var p;
      return ((p = s.query().matches) != null ? p : c === "dark") ? "dark" : "light";
    },
    addListener(c) {
      const p = s.query(), v = (h) => {
        c(h.matches ? "dark" : "light");
      };
      return typeof p.addListener == "function" ? p.addListener(v) : p.addEventListener("change", v), () => {
        typeof p.removeListener == "function" ? p.removeListener(v) : p.removeEventListener("change", v);
      };
    },
    preventTransition() {
      const c = document.createElement("style");
      return c.appendChild(
        document.createTextNode(
          "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"
        )
      ), document.head.appendChild(c), () => {
        window.getComputedStyle(document.body), requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(c);
          });
        });
      };
    }
  };
  return s;
}
var GV = "chakra-ui-color-mode";
function qV(n) {
  return {
    ssr: !1,
    type: "localStorage",
    get(a) {
      if (!(globalThis != null && globalThis.document))
        return a;
      let s;
      try {
        s = localStorage.getItem(n) || a;
      } catch {
      }
      return s || a;
    },
    set(a) {
      try {
        localStorage.setItem(n, a);
      } catch {
      }
    }
  };
}
var QV = qV(GV), n2 = () => {
};
function r2(n, a) {
  return n.type === "cookie" && n.ssr ? n.get(a) : a;
}
function iO(n) {
  const {
    value: a,
    children: s,
    options: {
      useSystemColorMode: c,
      initialColorMode: p,
      disableTransitionOnChange: v
    } = {},
    colorModeManager: h = QV
  } = n, b = p === "dark" ? "dark" : "light", [x, E] = jf(
    () => r2(h, b)
  ), [w, k] = jf(
    () => r2(h)
  ), { getSystemTheme: _, setClassName: A, setDataset: L, addListener: $ } = Ki(
    () => YV({ preventTransition: v }),
    [v]
  ), Y = p === "system" && !x ? w : x, K = Zp(
    (ne) => {
      const H = ne === "system" ? _() : ne;
      E(H), A(H === "dark"), L(H), h.set(H);
    },
    [h, _, A, L]
  );
  tS(() => {
    p === "system" && k(_());
  }, []), Qi(() => {
    const ne = h.get();
    if (ne) {
      K(ne);
      return;
    }
    if (p === "system") {
      K("system");
      return;
    }
    K(b);
  }, [h, b, p, K]);
  const W = Zp(() => {
    K(Y === "dark" ? "light" : "dark");
  }, [Y, K]);
  Qi(() => {
    if (c)
      return $(K);
  }, [c, $, K]);
  const F = Ki(
    () => ({
      colorMode: a ?? Y,
      toggleColorMode: a ? n2 : W,
      setColorMode: a ? n2 : K,
      forced: a !== void 0
    }),
    [Y, W, K, a]
  );
  return /* @__PURE__ */ Oe.jsx(Kw.Provider, { value: F, children: s });
}
iO.displayName = "ColorModeProvider";
function KV() {
  const n = Xw(), a = WV();
  return { ...n, theme: a };
}
var hh = (...n) => n.filter(Boolean).join(" ");
function is(n) {
  const a = typeof n;
  return n != null && (a === "object" || a === "function") && !Array.isArray(n);
}
function cc(n, ...a) {
  return XV(n) ? n(...a) : n;
}
var XV = (n) => typeof n == "function", nS = { exports: {} };
nS.exports;
(function(n, a) {
  var s = 200, c = "__lodash_hash_undefined__", p = 800, v = 16, h = 9007199254740991, b = "[object Arguments]", x = "[object Array]", E = "[object AsyncFunction]", w = "[object Boolean]", k = "[object Date]", _ = "[object Error]", A = "[object Function]", L = "[object GeneratorFunction]", $ = "[object Map]", Y = "[object Number]", K = "[object Null]", W = "[object Object]", F = "[object Proxy]", ne = "[object RegExp]", H = "[object Set]", le = "[object String]", re = "[object Undefined]", De = "[object WeakMap]", Fe = "[object ArrayBuffer]", ot = "[object DataView]", vt = "[object Float32Array]", Rt = "[object Float64Array]", $e = "[object Int8Array]", Be = "[object Int16Array]", jt = "[object Int32Array]", tt = "[object Uint8Array]", Lt = "[object Uint8ClampedArray]", he = "[object Uint16Array]", Ce = "[object Uint32Array]", ve = /[\\^$.*+?()[\]{}|]/g, Ae = /^\[object .+?Constructor\]$/, Ye = /^(?:0|[1-9]\d*)$/, Ke = {};
  Ke[vt] = Ke[Rt] = Ke[$e] = Ke[Be] = Ke[jt] = Ke[tt] = Ke[Lt] = Ke[he] = Ke[Ce] = !0, Ke[b] = Ke[x] = Ke[Fe] = Ke[w] = Ke[ot] = Ke[k] = Ke[_] = Ke[A] = Ke[$] = Ke[Y] = Ke[W] = Ke[ne] = Ke[H] = Ke[le] = Ke[De] = !1;
  var cn = typeof ub == "object" && ub && ub.Object === Object && ub, Vn = typeof self == "object" && self && self.Object === Object && self, bt = cn || Vn || Function("return this")(), yn = a && !a.nodeType && a, Ot = yn && !0 && n && !n.nodeType && n, Bt = Ot && Ot.exports === yn, gn = Bt && cn.process, $t = function() {
    try {
      var O = Ot && Ot.require && Ot.require("util").types;
      return O || gn && gn.binding && gn.binding("util");
    } catch {
    }
  }(), ge = $t && $t.isTypedArray;
  function kn(O, j, ee) {
    switch (ee.length) {
      case 0:
        return O.call(j);
      case 1:
        return O.call(j, ee[0]);
      case 2:
        return O.call(j, ee[0], ee[1]);
      case 3:
        return O.call(j, ee[0], ee[1], ee[2]);
    }
    return O.apply(j, ee);
  }
  function Mn(O, j) {
    for (var ee = -1, Ee = Array(O); ++ee < O; )
      Ee[ee] = j(ee);
    return Ee;
  }
  function jn(O) {
    return function(j) {
      return O(j);
    };
  }
  function pr(O, j) {
    return O == null ? void 0 : O[j];
  }
  function hr(O, j) {
    return function(ee) {
      return O(j(ee));
    };
  }
  var ba = Array.prototype, Ua = Function.prototype, Sa = Object.prototype, xa = bt["__core-js_shared__"], Br = Ua.toString, On = Sa.hasOwnProperty, Ia = function() {
    var O = /[^.]+$/.exec(xa && xa.keys && xa.keys.IE_PROTO || "");
    return O ? "Symbol(src)_1." + O : "";
  }(), Ur = Sa.toString, Ha = Br.call(Object), Bn = RegExp(
    "^" + Br.call(On).replace(ve, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), mr = Bt ? bt.Buffer : void 0, zi = bt.Symbol, Ca = bt.Uint8Array, ye = mr ? mr.allocUnsafe : void 0, Ue = hr(Object.getPrototypeOf, Object), ht = Object.create, Ut = Sa.propertyIsEnumerable, bn = ba.splice, pn = zi ? zi.toStringTag : void 0, hn = function() {
    try {
      var O = Js(Object, "defineProperty");
      return O({}, "", {}), O;
    } catch {
    }
  }(), Ir = mr ? mr.isBuffer : void 0, Xt = Math.max, ta = Date.now, Gt = Js(bt, "Map"), Nt = Js(Object, "create"), ss = /* @__PURE__ */ function() {
    function O() {
    }
    return function(j) {
      if (!Rn(j))
        return {};
      if (ht)
        return ht(j);
      O.prototype = j;
      var ee = new O();
      return O.prototype = void 0, ee;
    };
  }();
  function na(O) {
    var j = -1, ee = O == null ? 0 : O.length;
    for (this.clear(); ++j < ee; ) {
      var Ee = O[j];
      this.set(Ee[0], Ee[1]);
    }
  }
  function ls() {
    this.__data__ = Nt ? Nt(null) : {}, this.size = 0;
  }
  function Xs(O) {
    var j = this.has(O) && delete this.__data__[O];
    return this.size -= j ? 1 : 0, j;
  }
  function tu(O) {
    var j = this.__data__;
    if (Nt) {
      var ee = j[O];
      return ee === c ? void 0 : ee;
    }
    return On.call(j, O) ? j[O] : void 0;
  }
  function Co(O) {
    var j = this.__data__;
    return Nt ? j[O] !== void 0 : On.call(j, O);
  }
  function us(O, j) {
    var ee = this.__data__;
    return this.size += this.has(O) ? 0 : 1, ee[O] = Nt && j === void 0 ? c : j, this;
  }
  na.prototype.clear = ls, na.prototype.delete = Xs, na.prototype.get = tu, na.prototype.has = Co, na.prototype.set = us;
  function kr(O) {
    var j = -1, ee = O == null ? 0 : O.length;
    for (this.clear(); ++j < ee; ) {
      var Ee = O[j];
      this.set(Ee[0], Ee[1]);
    }
  }
  function cs() {
    this.__data__ = [], this.size = 0;
  }
  function si(O) {
    var j = this.__data__, ee = Et(j, O);
    if (ee < 0)
      return !1;
    var Ee = j.length - 1;
    return ee == Ee ? j.pop() : bn.call(j, ee, 1), --this.size, !0;
  }
  function Zi(O) {
    var j = this.__data__, ee = Et(j, O);
    return ee < 0 ? void 0 : j[ee][1];
  }
  function ra(O) {
    return Et(this.__data__, O) > -1;
  }
  function Wa(O, j) {
    var ee = this.__data__, Ee = Et(ee, O);
    return Ee < 0 ? (++this.size, ee.push([O, j])) : ee[Ee][1] = j, this;
  }
  kr.prototype.clear = cs, kr.prototype.delete = si, kr.prototype.get = Zi, kr.prototype.has = ra, kr.prototype.set = Wa;
  function aa(O) {
    var j = -1, ee = O == null ? 0 : O.length;
    for (this.clear(); ++j < ee; ) {
      var Ee = O[j];
      this.set(Ee[0], Ee[1]);
    }
  }
  function P() {
    this.size = 0, this.__data__ = {
      hash: new na(),
      map: new (Gt || kr)(),
      string: new na()
    };
  }
  function ce(O) {
    var j = wo(this, O).delete(O);
    return this.size -= j ? 1 : 0, j;
  }
  function be(O) {
    return wo(this, O).get(O);
  }
  function He(O) {
    return wo(this, O).has(O);
  }
  function ct(O, j) {
    var ee = wo(this, O), Ee = ee.size;
    return ee.set(O, j), this.size += ee.size == Ee ? 0 : 1, this;
  }
  aa.prototype.clear = P, aa.prototype.delete = ce, aa.prototype.get = be, aa.prototype.has = He, aa.prototype.set = ct;
  function gt(O) {
    var j = this.__data__ = new kr(O);
    this.size = j.size;
  }
  function ft() {
    this.__data__ = new kr(), this.size = 0;
  }
  function Ge(O) {
    var j = this.__data__, ee = j.delete(O);
    return this.size = j.size, ee;
  }
  function Xn(O) {
    return this.__data__.get(O);
  }
  function mn(O) {
    return this.__data__.has(O);
  }
  function vn(O, j) {
    var ee = this.__data__;
    if (ee instanceof kr) {
      var Ee = ee.__data__;
      if (!Gt || Ee.length < s - 1)
        return Ee.push([O, j]), this.size = ++ee.size, this;
      ee = this.__data__ = new aa(Ee);
    }
    return ee.set(O, j), this.size = ee.size, this;
  }
  gt.prototype.clear = ft, gt.prototype.delete = Ge, gt.prototype.get = Xn, gt.prototype.has = mn, gt.prototype.set = vn;
  function Rr(O, j) {
    var ee = Wr(O), Ee = !ee && Hr(O), St = !ee && !Ee && Ht(O), Wt = !ee && !Ee && !St && ko(O), Mt = ee || Ee || St || Wt, yt = Mt ? Mn(O.length, String) : [], qt = yt.length;
    for (var Yr in O)
      (j || On.call(O, Yr)) && !(Mt && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Yr == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      St && (Yr == "offset" || Yr == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Wt && (Yr == "buffer" || Yr == "byteLength" || Yr == "byteOffset") || // Skip index properties.
      Ji(Yr, qt))) && yt.push(Yr);
    return yt;
  }
  function li(O, j, ee) {
    (ee !== void 0 && !Sn(O[j], ee) || ee === void 0 && !(j in O)) && yc(O, j, ee);
  }
  function nu(O, j, ee) {
    var Ee = O[j];
    (!(On.call(O, j) && Sn(Ee, ee)) || ee === void 0 && !(j in O)) && yc(O, j, ee);
  }
  function Et(O, j) {
    for (var ee = O.length; ee--; )
      if (Sn(O[ee][0], j))
        return ee;
    return -1;
  }
  function yc(O, j, ee) {
    j == "__proto__" && hn ? hn(O, j, {
      configurable: !0,
      enumerable: !0,
      value: ee,
      writable: !0
    }) : O[j] = ee;
  }
  var Pi = bc();
  function mt(O) {
    return O == null ? O === void 0 ? re : K : pn && pn in Object(O) ? au(O) : ou(O);
  }
  function Li(O) {
    return ka(O) && mt(O) == b;
  }
  function Hf(O) {
    if (!Rn(O) || It(O))
      return !1;
    var j = Cc(O) ? Bn : Ae;
    return j.test(tl(O));
  }
  function gc(O) {
    return ka(O) && Ta(O.length) && !!Ke[mt(O)];
  }
  function Zs(O) {
    if (!Rn(O))
      return qf(O);
    var j = iu(O), ee = [];
    for (var Ee in O)
      Ee == "constructor" && (j || !On.call(O, Ee)) || ee.push(Ee);
    return ee;
  }
  function Ea(O, j, ee, Ee, St) {
    O !== j && Pi(j, function(Wt, Mt) {
      if (St || (St = new gt()), Rn(Wt))
        Wf(O, j, Mt, ee, Ea, Ee, St);
      else {
        var yt = Ee ? Ee(su(O, Mt), Wt, Mt + "", O, j, St) : void 0;
        yt === void 0 && (yt = Wt), li(O, Mt, yt);
      }
    }, wc);
  }
  function Wf(O, j, ee, Ee, St, Wt, Mt) {
    var yt = su(O, ee), qt = su(j, ee), Yr = Mt.get(qt);
    if (Yr) {
      li(O, ee, Yr);
      return;
    }
    var Zn = Wt ? Wt(yt, qt, ee + "", O, j, Mt) : void 0, $i = Zn === void 0;
    if ($i) {
      var lu = Wr(qt), _r = !lu && Ht(qt), Ni = !lu && !_r && ko(qt);
      Zn = qt, lu || _r || Ni ? Wr(yt) ? Zn = yt : Yn(yt) ? Zn = fs(yt) : _r ? ($i = !1, Zn = Gf(qt, !0)) : Ni ? ($i = !1, Zn = ru(qt, !0)) : Zn = [] : Qf(qt) || Hr(qt) ? (Zn = yt, Hr(yt) ? Zn = Ec(yt) : (!Rn(yt) || Cc(yt)) && (Zn = Sc(qt))) : $i = !1;
    }
    $i && (Mt.set(qt, Zn), St(Zn, qt, Ee, Wt, Mt), Mt.delete(qt)), li(O, ee, Zn);
  }
  function wa(O, j) {
    return xc(Zt(O, j, Ro), O + "");
  }
  var Yf = hn ? function(O, j) {
    return hn(O, "toString", {
      configurable: !0,
      enumerable: !1,
      value: rl(j),
      writable: !0
    });
  } : Ro;
  function Gf(O, j) {
    if (j)
      return O.slice();
    var ee = O.length, Ee = ye ? ye(ee) : new O.constructor(ee);
    return O.copy(Ee), Ee;
  }
  function vh(O) {
    var j = new O.constructor(O.byteLength);
    return new Ca(j).set(new Ca(O)), j;
  }
  function ru(O, j) {
    var ee = j ? vh(O.buffer) : O.buffer;
    return new O.constructor(ee, O.byteOffset, O.length);
  }
  function fs(O, j) {
    var ee = -1, Ee = O.length;
    for (j || (j = Array(Ee)); ++ee < Ee; )
      j[ee] = O[ee];
    return j;
  }
  function Eo(O, j, ee, Ee) {
    var St = !ee;
    ee || (ee = {});
    for (var Wt = -1, Mt = j.length; ++Wt < Mt; ) {
      var yt = j[Wt], qt = Ee ? Ee(ee[yt], O[yt], yt, ee, O) : void 0;
      qt === void 0 && (qt = O[yt]), St ? yc(ee, yt, qt) : nu(ee, yt, qt);
    }
    return ee;
  }
  function Ya(O) {
    return wa(function(j, ee) {
      var Ee = -1, St = ee.length, Wt = St > 1 ? ee[St - 1] : void 0, Mt = St > 2 ? ee[2] : void 0;
      for (Wt = O.length > 3 && typeof Wt == "function" ? (St--, Wt) : void 0, Mt && yh(ee[0], ee[1], Mt) && (Wt = St < 3 ? void 0 : Wt, St = 1), j = Object(j); ++Ee < St; ) {
        var yt = ee[Ee];
        yt && O(j, yt, Ee, Wt);
      }
      return j;
    });
  }
  function bc(O) {
    return function(j, ee, Ee) {
      for (var St = -1, Wt = Object(j), Mt = Ee(j), yt = Mt.length; yt--; ) {
        var qt = Mt[O ? yt : ++St];
        if (ee(Wt[qt], qt, Wt) === !1)
          break;
      }
      return j;
    };
  }
  function wo(O, j) {
    var ee = O.__data__;
    return el(j) ? ee[typeof j == "string" ? "string" : "hash"] : ee.map;
  }
  function Js(O, j) {
    var ee = pr(O, j);
    return Hf(ee) ? ee : void 0;
  }
  function au(O) {
    var j = On.call(O, pn), ee = O[pn];
    try {
      O[pn] = void 0;
      var Ee = !0;
    } catch {
    }
    var St = Ur.call(O);
    return Ee && (j ? O[pn] = ee : delete O[pn]), St;
  }
  function Sc(O) {
    return typeof O.constructor == "function" && !iu(O) ? ss(Ue(O)) : {};
  }
  function Ji(O, j) {
    var ee = typeof O;
    return j = j ?? h, !!j && (ee == "number" || ee != "symbol" && Ye.test(O)) && O > -1 && O % 1 == 0 && O < j;
  }
  function yh(O, j, ee) {
    if (!Rn(ee))
      return !1;
    var Ee = typeof j;
    return (Ee == "number" ? To(ee) && Ji(j, ee.length) : Ee == "string" && j in ee) ? Sn(ee[j], O) : !1;
  }
  function el(O) {
    var j = typeof O;
    return j == "string" || j == "number" || j == "symbol" || j == "boolean" ? O !== "__proto__" : O === null;
  }
  function It(O) {
    return !!Ia && Ia in O;
  }
  function iu(O) {
    var j = O && O.constructor, ee = typeof j == "function" && j.prototype || Sa;
    return O === ee;
  }
  function qf(O) {
    var j = [];
    if (O != null)
      for (var ee in Object(O))
        j.push(ee);
    return j;
  }
  function ou(O) {
    return Ur.call(O);
  }
  function Zt(O, j, ee) {
    return j = Xt(j === void 0 ? O.length - 1 : j, 0), function() {
      for (var Ee = arguments, St = -1, Wt = Xt(Ee.length - j, 0), Mt = Array(Wt); ++St < Wt; )
        Mt[St] = Ee[j + St];
      St = -1;
      for (var yt = Array(j + 1); ++St < j; )
        yt[St] = Ee[St];
      return yt[j] = ee(Mt), kn(O, this, yt);
    };
  }
  function su(O, j) {
    if (!(j === "constructor" && typeof O[j] == "function") && j != "__proto__")
      return O[j];
  }
  var xc = st(Yf);
  function st(O) {
    var j = 0, ee = 0;
    return function() {
      var Ee = ta(), St = v - (Ee - ee);
      if (ee = Ee, St > 0) {
        if (++j >= p)
          return arguments[0];
      } else
        j = 0;
      return O.apply(void 0, arguments);
    };
  }
  function tl(O) {
    if (O != null) {
      try {
        return Br.call(O);
      } catch {
      }
      try {
        return O + "";
      } catch {
      }
    }
    return "";
  }
  function Sn(O, j) {
    return O === j || O !== O && j !== j;
  }
  var Hr = Li(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Li : function(O) {
    return ka(O) && On.call(O, "callee") && !Ut.call(O, "callee");
  }, Wr = Array.isArray;
  function To(O) {
    return O != null && Ta(O.length) && !Cc(O);
  }
  function Yn(O) {
    return ka(O) && To(O);
  }
  var Ht = Ir || _o;
  function Cc(O) {
    if (!Rn(O))
      return !1;
    var j = mt(O);
    return j == A || j == L || j == E || j == F;
  }
  function Ta(O) {
    return typeof O == "number" && O > -1 && O % 1 == 0 && O <= h;
  }
  function Rn(O) {
    var j = typeof O;
    return O != null && (j == "object" || j == "function");
  }
  function ka(O) {
    return O != null && typeof O == "object";
  }
  function Qf(O) {
    if (!ka(O) || mt(O) != W)
      return !1;
    var j = Ue(O);
    if (j === null)
      return !0;
    var ee = On.call(j, "constructor") && j.constructor;
    return typeof ee == "function" && ee instanceof ee && Br.call(ee) == Ha;
  }
  var ko = ge ? jn(ge) : gc;
  function Ec(O) {
    return Eo(O, wc(O));
  }
  function wc(O) {
    return To(O) ? Rr(O, !0) : Zs(O);
  }
  var nl = Ya(function(O, j, ee, Ee) {
    Ea(O, j, ee, Ee);
  });
  function rl(O) {
    return function() {
      return O;
    };
  }
  function Ro(O) {
    return O;
  }
  function _o() {
    return !1;
  }
  n.exports = nl;
})(nS, nS.exports);
var ZV = nS.exports;
const bo = /* @__PURE__ */ cM(ZV);
var JV = (n) => /!(important)?$/.test(n), a2 = (n) => typeof n == "string" ? n.replace(/!(important)?$/, "").trim() : n, ej = (n, a) => (s) => {
  const c = String(a), p = JV(c), v = a2(c), h = n ? `${n}.${v}` : v;
  let b = is(s.__cssMap) && h in s.__cssMap ? s.__cssMap[h].varRef : a;
  return b = a2(b), p ? `${b} !important` : b;
};
function Zw(n) {
  const { scale: a, transform: s, compose: c } = n;
  return (v, h) => {
    var b;
    const x = ej(a, v)(h);
    let E = (b = s == null ? void 0 : s(x, h)) != null ? b : x;
    return c && (E = c(E, h)), E;
  };
}
var yb = (...n) => (a) => n.reduce((s, c) => c(s), a);
function mo(n, a) {
  return (s) => {
    const c = { property: s, scale: n };
    return c.transform = Zw({
      scale: n,
      transform: a
    }), c;
  };
}
var tj = ({ rtl: n, ltr: a }) => (s) => s.direction === "rtl" ? n : a;
function nj(n) {
  const { property: a, scale: s, transform: c } = n;
  return {
    scale: s,
    property: tj(a),
    transform: s ? Zw({
      scale: s,
      compose: c
    }) : c
  };
}
var oO = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function rj() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...oO
  ].join(" ");
}
function aj() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...oO
  ].join(" ");
}
var ij = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
}, oj = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function sj(n) {
  return {
    "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
    "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
    "--chakra-ring-width": n,
    boxShadow: [
      "var(--chakra-ring-offset-shadow)",
      "var(--chakra-ring-shadow)",
      "var(--chakra-shadow, 0 0 #0000)"
    ].join(", ")
  };
}
var lj = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
}, cw = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
}, uj = new Set(Object.values(cw)), fw = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]), cj = (n) => n.trim();
function fj(n, a) {
  if (n == null || fw.has(n))
    return n;
  if (!(dw(n) || fw.has(n)))
    return `url('${n}')`;
  const p = /(^[a-z-A-Z]+)\((.*)\)/g.exec(n), v = p == null ? void 0 : p[1], h = p == null ? void 0 : p[2];
  if (!v || !h)
    return n;
  const b = v.includes("-gradient") ? v : `${v}-gradient`, [x, ...E] = h.split(",").map(cj).filter(Boolean);
  if ((E == null ? void 0 : E.length) === 0)
    return n;
  const w = x in cw ? cw[x] : x;
  E.unshift(w);
  const k = E.map((_) => {
    if (uj.has(_))
      return _;
    const A = _.indexOf(" "), [L, $] = A !== -1 ? [_.substr(0, A), _.substr(A + 1)] : [_], Y = dw($) ? $ : $ && $.split(" "), K = `colors.${L}`, W = K in a.__cssMap ? a.__cssMap[K].varRef : L;
    return Y ? [
      W,
      ...Array.isArray(Y) ? Y : [Y]
    ].join(" ") : W;
  });
  return `${b}(${k.join(", ")})`;
}
var dw = (n) => typeof n == "string" && n.includes("(") && n.includes(")"), dj = (n, a) => fj(n, a ?? {});
function pj(n) {
  return /^var\(--.+\)$/.test(n);
}
var hj = (n) => {
  const a = parseFloat(n.toString()), s = n.toString().replace(String(a), "");
  return { unitless: !s, value: a, unit: s };
}, Is = (n) => (a) => `${n}(${a})`, Pt = {
  filter(n) {
    return n !== "auto" ? n : ij;
  },
  backdropFilter(n) {
    return n !== "auto" ? n : oj;
  },
  ring(n) {
    return sj(Pt.px(n));
  },
  bgClip(n) {
    return n === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: n };
  },
  transform(n) {
    return n === "auto" ? rj() : n === "auto-gpu" ? aj() : n;
  },
  vh(n) {
    return n === "$100vh" ? "var(--chakra-vh)" : n;
  },
  px(n) {
    if (n == null)
      return n;
    const { unitless: a } = hj(n);
    return a || typeof n == "number" ? `${n}px` : n;
  },
  fraction(n) {
    return typeof n != "number" || n > 1 ? n : `${n * 100}%`;
  },
  float(n, a) {
    const s = { left: "right", right: "left" };
    return a.direction === "rtl" ? s[n] : n;
  },
  degree(n) {
    if (pj(n) || n == null)
      return n;
    const a = typeof n == "string" && !n.endsWith("deg");
    return typeof n == "number" || a ? `${n}deg` : n;
  },
  gradient: dj,
  blur: Is("blur"),
  opacity: Is("opacity"),
  brightness: Is("brightness"),
  contrast: Is("contrast"),
  dropShadow: Is("drop-shadow"),
  grayscale: Is("grayscale"),
  hueRotate: (n) => Is("hue-rotate")(Pt.degree(n)),
  invert: Is("invert"),
  saturate: Is("saturate"),
  sepia: Is("sepia"),
  bgImage(n) {
    return n == null || dw(n) || fw.has(n) ? n : `url(${n})`;
  },
  outline(n) {
    const a = String(n) === "0" || String(n) === "none";
    return n !== null && a ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: n };
  },
  flexDirection(n) {
    var a;
    const { space: s, divide: c } = (a = lj[n]) != null ? a : {}, p = { flexDirection: n };
    return s && (p[s] = 1), c && (p[c] = 1), p;
  }
}, I = {
  borderWidths: mo("borderWidths"),
  borderStyles: mo("borderStyles"),
  colors: mo("colors"),
  borders: mo("borders"),
  gradients: mo("gradients", Pt.gradient),
  radii: mo("radii", Pt.px),
  space: mo("space", yb(Pt.vh, Pt.px)),
  spaceT: mo("space", yb(Pt.vh, Pt.px)),
  degreeT(n) {
    return { property: n, transform: Pt.degree };
  },
  prop(n, a, s) {
    return {
      property: n,
      scale: a,
      ...a && {
        transform: Zw({ scale: a, transform: s })
      }
    };
  },
  propT(n, a) {
    return { property: n, transform: a };
  },
  sizes: mo("sizes", yb(Pt.vh, Pt.px)),
  sizesT: mo("sizes", yb(Pt.vh, Pt.fraction)),
  shadows: mo("shadows"),
  logical: nj,
  blur: mo("blur", Pt.blur)
}, Nb = {
  background: I.colors("background"),
  backgroundColor: I.colors("backgroundColor"),
  backgroundImage: I.gradients("backgroundImage"),
  backgroundSize: !0,
  backgroundPosition: !0,
  backgroundRepeat: !0,
  backgroundAttachment: !0,
  backgroundClip: { transform: Pt.bgClip },
  bgSize: I.prop("backgroundSize"),
  bgPosition: I.prop("backgroundPosition"),
  bg: I.colors("background"),
  bgColor: I.colors("backgroundColor"),
  bgPos: I.prop("backgroundPosition"),
  bgRepeat: I.prop("backgroundRepeat"),
  bgAttachment: I.prop("backgroundAttachment"),
  bgGradient: I.gradients("backgroundImage"),
  bgClip: { transform: Pt.bgClip }
};
Object.assign(Nb, {
  bgImage: Nb.backgroundImage,
  bgImg: Nb.backgroundImage
});
var Jt = {
  border: I.borders("border"),
  borderWidth: I.borderWidths("borderWidth"),
  borderStyle: I.borderStyles("borderStyle"),
  borderColor: I.colors("borderColor"),
  borderRadius: I.radii("borderRadius"),
  borderTop: I.borders("borderTop"),
  borderBlockStart: I.borders("borderBlockStart"),
  borderTopLeftRadius: I.radii("borderTopLeftRadius"),
  borderStartStartRadius: I.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: I.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: I.radii("borderTopRightRadius"),
  borderStartEndRadius: I.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: I.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: I.borders("borderRight"),
  borderInlineEnd: I.borders("borderInlineEnd"),
  borderBottom: I.borders("borderBottom"),
  borderBlockEnd: I.borders("borderBlockEnd"),
  borderBottomLeftRadius: I.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: I.radii("borderBottomRightRadius"),
  borderLeft: I.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: I.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: I.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: I.borders(["borderLeft", "borderRight"]),
  borderInline: I.borders("borderInline"),
  borderY: I.borders(["borderTop", "borderBottom"]),
  borderBlock: I.borders("borderBlock"),
  borderTopWidth: I.borderWidths("borderTopWidth"),
  borderBlockStartWidth: I.borderWidths("borderBlockStartWidth"),
  borderTopColor: I.colors("borderTopColor"),
  borderBlockStartColor: I.colors("borderBlockStartColor"),
  borderTopStyle: I.borderStyles("borderTopStyle"),
  borderBlockStartStyle: I.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: I.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: I.borderWidths("borderBlockEndWidth"),
  borderBottomColor: I.colors("borderBottomColor"),
  borderBlockEndColor: I.colors("borderBlockEndColor"),
  borderBottomStyle: I.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: I.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: I.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: I.borderWidths("borderInlineStartWidth"),
  borderLeftColor: I.colors("borderLeftColor"),
  borderInlineStartColor: I.colors("borderInlineStartColor"),
  borderLeftStyle: I.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: I.borderStyles("borderInlineStartStyle"),
  borderRightWidth: I.borderWidths("borderRightWidth"),
  borderInlineEndWidth: I.borderWidths("borderInlineEndWidth"),
  borderRightColor: I.colors("borderRightColor"),
  borderInlineEndColor: I.colors("borderInlineEndColor"),
  borderRightStyle: I.borderStyles("borderRightStyle"),
  borderInlineEndStyle: I.borderStyles("borderInlineEndStyle"),
  borderTopRadius: I.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: I.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: I.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: I.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(Jt, {
  rounded: Jt.borderRadius,
  roundedTop: Jt.borderTopRadius,
  roundedTopLeft: Jt.borderTopLeftRadius,
  roundedTopRight: Jt.borderTopRightRadius,
  roundedTopStart: Jt.borderStartStartRadius,
  roundedTopEnd: Jt.borderStartEndRadius,
  roundedBottom: Jt.borderBottomRadius,
  roundedBottomLeft: Jt.borderBottomLeftRadius,
  roundedBottomRight: Jt.borderBottomRightRadius,
  roundedBottomStart: Jt.borderEndStartRadius,
  roundedBottomEnd: Jt.borderEndEndRadius,
  roundedLeft: Jt.borderLeftRadius,
  roundedRight: Jt.borderRightRadius,
  roundedStart: Jt.borderInlineStartRadius,
  roundedEnd: Jt.borderInlineEndRadius,
  borderStart: Jt.borderInlineStart,
  borderEnd: Jt.borderInlineEnd,
  borderTopStartRadius: Jt.borderStartStartRadius,
  borderTopEndRadius: Jt.borderStartEndRadius,
  borderBottomStartRadius: Jt.borderEndStartRadius,
  borderBottomEndRadius: Jt.borderEndEndRadius,
  borderStartRadius: Jt.borderInlineStartRadius,
  borderEndRadius: Jt.borderInlineEndRadius,
  borderStartWidth: Jt.borderInlineStartWidth,
  borderEndWidth: Jt.borderInlineEndWidth,
  borderStartColor: Jt.borderInlineStartColor,
  borderEndColor: Jt.borderInlineEndColor,
  borderStartStyle: Jt.borderInlineStartStyle,
  borderEndStyle: Jt.borderInlineEndStyle
});
var mj = {
  color: I.colors("color"),
  textColor: I.colors("color"),
  fill: I.colors("fill"),
  stroke: I.colors("stroke")
}, pw = {
  boxShadow: I.shadows("boxShadow"),
  mixBlendMode: !0,
  blendMode: I.prop("mixBlendMode"),
  backgroundBlendMode: !0,
  bgBlendMode: I.prop("backgroundBlendMode"),
  opacity: !0
};
Object.assign(pw, {
  shadow: pw.boxShadow
});
var vj = {
  filter: { transform: Pt.filter },
  blur: I.blur("--chakra-blur"),
  brightness: I.propT("--chakra-brightness", Pt.brightness),
  contrast: I.propT("--chakra-contrast", Pt.contrast),
  hueRotate: I.propT("--chakra-hue-rotate", Pt.hueRotate),
  invert: I.propT("--chakra-invert", Pt.invert),
  saturate: I.propT("--chakra-saturate", Pt.saturate),
  dropShadow: I.propT("--chakra-drop-shadow", Pt.dropShadow),
  backdropFilter: { transform: Pt.backdropFilter },
  backdropBlur: I.blur("--chakra-backdrop-blur"),
  backdropBrightness: I.propT(
    "--chakra-backdrop-brightness",
    Pt.brightness
  ),
  backdropContrast: I.propT("--chakra-backdrop-contrast", Pt.contrast),
  backdropHueRotate: I.propT(
    "--chakra-backdrop-hue-rotate",
    Pt.hueRotate
  ),
  backdropInvert: I.propT("--chakra-backdrop-invert", Pt.invert),
  backdropSaturate: I.propT("--chakra-backdrop-saturate", Pt.saturate)
}, rS = {
  alignItems: !0,
  alignContent: !0,
  justifyItems: !0,
  justifyContent: !0,
  flexWrap: !0,
  flexDirection: { transform: Pt.flexDirection },
  flex: !0,
  flexFlow: !0,
  flexGrow: !0,
  flexShrink: !0,
  flexBasis: I.sizes("flexBasis"),
  justifySelf: !0,
  alignSelf: !0,
  order: !0,
  placeItems: !0,
  placeContent: !0,
  placeSelf: !0,
  gap: I.space("gap"),
  rowGap: I.space("rowGap"),
  columnGap: I.space("columnGap")
};
Object.assign(rS, {
  flexDir: rS.flexDirection
});
var sO = {
  gridGap: I.space("gridGap"),
  gridColumnGap: I.space("gridColumnGap"),
  gridRowGap: I.space("gridRowGap"),
  gridColumn: !0,
  gridRow: !0,
  gridAutoFlow: !0,
  gridAutoColumns: !0,
  gridColumnStart: !0,
  gridColumnEnd: !0,
  gridRowStart: !0,
  gridRowEnd: !0,
  gridAutoRows: !0,
  gridTemplate: !0,
  gridTemplateColumns: !0,
  gridTemplateRows: !0,
  gridTemplateAreas: !0,
  gridArea: !0
}, yj = {
  appearance: !0,
  cursor: !0,
  resize: !0,
  userSelect: !0,
  pointerEvents: !0,
  outline: { transform: Pt.outline },
  outlineOffset: !0,
  outlineColor: I.colors("outlineColor")
}, yo = {
  width: I.sizesT("width"),
  inlineSize: I.sizesT("inlineSize"),
  height: I.sizes("height"),
  blockSize: I.sizes("blockSize"),
  boxSize: I.sizes(["width", "height"]),
  minWidth: I.sizes("minWidth"),
  minInlineSize: I.sizes("minInlineSize"),
  minHeight: I.sizes("minHeight"),
  minBlockSize: I.sizes("minBlockSize"),
  maxWidth: I.sizes("maxWidth"),
  maxInlineSize: I.sizes("maxInlineSize"),
  maxHeight: I.sizes("maxHeight"),
  maxBlockSize: I.sizes("maxBlockSize"),
  overflow: !0,
  overflowX: !0,
  overflowY: !0,
  overscrollBehavior: !0,
  overscrollBehaviorX: !0,
  overscrollBehaviorY: !0,
  display: !0,
  aspectRatio: !0,
  hideFrom: {
    scale: "breakpoints",
    transform: (n, a) => {
      var s, c, p;
      return { [`@media screen and (min-width: ${(p = (c = (s = a.__breakpoints) == null ? void 0 : s.get(n)) == null ? void 0 : c.minW) != null ? p : n})`]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (n, a) => {
      var s, c, p;
      return { [`@media screen and (max-width: ${(p = (c = (s = a.__breakpoints) == null ? void 0 : s.get(n)) == null ? void 0 : c._minW) != null ? p : n})`]: { display: "none" } };
    }
  },
  verticalAlign: !0,
  boxSizing: !0,
  boxDecorationBreak: !0,
  float: I.propT("float", Pt.float),
  objectFit: !0,
  objectPosition: !0,
  visibility: !0,
  isolation: !0
};
Object.assign(yo, {
  w: yo.width,
  h: yo.height,
  minW: yo.minWidth,
  maxW: yo.maxWidth,
  minH: yo.minHeight,
  maxH: yo.maxHeight,
  overscroll: yo.overscrollBehavior,
  overscrollX: yo.overscrollBehaviorX,
  overscrollY: yo.overscrollBehaviorY
});
var gj = {
  listStyleType: !0,
  listStylePosition: !0,
  listStylePos: I.prop("listStylePosition"),
  listStyleImage: !0,
  listStyleImg: I.prop("listStyleImage")
};
function bj(n, a, s, c) {
  const p = typeof a == "string" ? a.split(".") : [a];
  for (c = 0; c < p.length && n; c += 1)
    n = n[p[c]];
  return n === void 0 ? s : n;
}
var Sj = (n) => {
  const a = /* @__PURE__ */ new WeakMap();
  return (c, p, v, h) => {
    if (typeof c > "u")
      return n(c, p, v);
    a.has(c) || a.set(c, /* @__PURE__ */ new Map());
    const b = a.get(c);
    if (b.has(p))
      return b.get(p);
    const x = n(c, p, v, h);
    return b.set(p, x), x;
  };
}, xj = Sj(bj), Cj = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
}, Ej = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
}, SE = (n, a, s) => {
  const c = {}, p = xj(n, a, {});
  for (const v in p)
    v in s && s[v] != null || (c[v] = p[v]);
  return c;
}, wj = {
  srOnly: {
    transform(n) {
      return n === !0 ? Cj : n === "focusable" ? Ej : {};
    }
  },
  layerStyle: {
    processResult: !0,
    transform: (n, a, s) => SE(a, `layerStyles.${n}`, s)
  },
  textStyle: {
    processResult: !0,
    transform: (n, a, s) => SE(a, `textStyles.${n}`, s)
  },
  apply: {
    processResult: !0,
    transform: (n, a, s) => SE(a, n, s)
  }
}, Uv = {
  position: !0,
  pos: I.prop("position"),
  zIndex: I.prop("zIndex", "zIndices"),
  inset: I.spaceT("inset"),
  insetX: I.spaceT(["left", "right"]),
  insetInline: I.spaceT("insetInline"),
  insetY: I.spaceT(["top", "bottom"]),
  insetBlock: I.spaceT("insetBlock"),
  top: I.spaceT("top"),
  insetBlockStart: I.spaceT("insetBlockStart"),
  bottom: I.spaceT("bottom"),
  insetBlockEnd: I.spaceT("insetBlockEnd"),
  left: I.spaceT("left"),
  insetInlineStart: I.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: I.spaceT("right"),
  insetInlineEnd: I.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(Uv, {
  insetStart: Uv.insetInlineStart,
  insetEnd: Uv.insetInlineEnd
});
var Tj = {
  ring: { transform: Pt.ring },
  ringColor: I.colors("--chakra-ring-color"),
  ringOffset: I.prop("--chakra-ring-offset-width"),
  ringOffsetColor: I.colors("--chakra-ring-offset-color"),
  ringInset: I.prop("--chakra-ring-inset")
}, Fn = {
  margin: I.spaceT("margin"),
  marginTop: I.spaceT("marginTop"),
  marginBlockStart: I.spaceT("marginBlockStart"),
  marginRight: I.spaceT("marginRight"),
  marginInlineEnd: I.spaceT("marginInlineEnd"),
  marginBottom: I.spaceT("marginBottom"),
  marginBlockEnd: I.spaceT("marginBlockEnd"),
  marginLeft: I.spaceT("marginLeft"),
  marginInlineStart: I.spaceT("marginInlineStart"),
  marginX: I.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: I.spaceT("marginInline"),
  marginY: I.spaceT(["marginTop", "marginBottom"]),
  marginBlock: I.spaceT("marginBlock"),
  padding: I.space("padding"),
  paddingTop: I.space("paddingTop"),
  paddingBlockStart: I.space("paddingBlockStart"),
  paddingRight: I.space("paddingRight"),
  paddingBottom: I.space("paddingBottom"),
  paddingBlockEnd: I.space("paddingBlockEnd"),
  paddingLeft: I.space("paddingLeft"),
  paddingInlineStart: I.space("paddingInlineStart"),
  paddingInlineEnd: I.space("paddingInlineEnd"),
  paddingX: I.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: I.space("paddingInline"),
  paddingY: I.space(["paddingTop", "paddingBottom"]),
  paddingBlock: I.space("paddingBlock")
};
Object.assign(Fn, {
  m: Fn.margin,
  mt: Fn.marginTop,
  mr: Fn.marginRight,
  me: Fn.marginInlineEnd,
  marginEnd: Fn.marginInlineEnd,
  mb: Fn.marginBottom,
  ml: Fn.marginLeft,
  ms: Fn.marginInlineStart,
  marginStart: Fn.marginInlineStart,
  mx: Fn.marginX,
  my: Fn.marginY,
  p: Fn.padding,
  pt: Fn.paddingTop,
  py: Fn.paddingY,
  px: Fn.paddingX,
  pb: Fn.paddingBottom,
  pl: Fn.paddingLeft,
  ps: Fn.paddingInlineStart,
  paddingStart: Fn.paddingInlineStart,
  pr: Fn.paddingRight,
  pe: Fn.paddingInlineEnd,
  paddingEnd: Fn.paddingInlineEnd
});
var kj = {
  textDecorationColor: I.colors("textDecorationColor"),
  textDecoration: !0,
  textDecor: { property: "textDecoration" },
  textDecorationLine: !0,
  textDecorationStyle: !0,
  textDecorationThickness: !0,
  textUnderlineOffset: !0,
  textShadow: I.shadows("textShadow")
}, Rj = {
  clipPath: !0,
  transform: I.propT("transform", Pt.transform),
  transformOrigin: !0,
  translateX: I.spaceT("--chakra-translate-x"),
  translateY: I.spaceT("--chakra-translate-y"),
  skewX: I.degreeT("--chakra-skew-x"),
  skewY: I.degreeT("--chakra-skew-y"),
  scaleX: I.prop("--chakra-scale-x"),
  scaleY: I.prop("--chakra-scale-y"),
  scale: I.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: I.degreeT("--chakra-rotate")
}, _j = {
  transition: !0,
  transitionDelay: !0,
  animation: !0,
  willChange: !0,
  transitionDuration: I.prop("transitionDuration", "transition.duration"),
  transitionProperty: I.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: I.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
}, Dj = {
  fontFamily: I.prop("fontFamily", "fonts"),
  fontSize: I.prop("fontSize", "fontSizes", Pt.px),
  fontWeight: I.prop("fontWeight", "fontWeights"),
  lineHeight: I.prop("lineHeight", "lineHeights"),
  letterSpacing: I.prop("letterSpacing", "letterSpacings"),
  textAlign: !0,
  fontStyle: !0,
  textIndent: !0,
  wordBreak: !0,
  overflowWrap: !0,
  textOverflow: !0,
  textTransform: !0,
  whiteSpace: !0,
  isTruncated: {
    transform(n) {
      if (n === !0)
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
}, Aj = {
  scrollBehavior: !0,
  scrollSnapAlign: !0,
  scrollSnapStop: !0,
  scrollSnapType: !0,
  // scroll margin
  scrollMargin: I.spaceT("scrollMargin"),
  scrollMarginTop: I.spaceT("scrollMarginTop"),
  scrollMarginBottom: I.spaceT("scrollMarginBottom"),
  scrollMarginLeft: I.spaceT("scrollMarginLeft"),
  scrollMarginRight: I.spaceT("scrollMarginRight"),
  scrollMarginX: I.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: I.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: I.spaceT("scrollPadding"),
  scrollPaddingTop: I.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: I.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: I.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: I.spaceT("scrollPaddingRight"),
  scrollPaddingX: I.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: I.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
function lO(n) {
  return is(n) && n.reference ? n.reference : String(n);
}
var DS = (n, ...a) => a.map(lO).join(` ${n} `).replace(/calc/g, ""), i2 = (...n) => `calc(${DS("+", ...n)})`, o2 = (...n) => `calc(${DS("-", ...n)})`, hw = (...n) => `calc(${DS("*", ...n)})`, s2 = (...n) => `calc(${DS("/", ...n)})`, l2 = (n) => {
  const a = lO(n);
  return a != null && !Number.isNaN(parseFloat(a)) ? String(a).startsWith("-") ? String(a).slice(1) : `-${a}` : hw(a, -1);
}, Df = Object.assign(
  (n) => ({
    add: (...a) => Df(i2(n, ...a)),
    subtract: (...a) => Df(o2(n, ...a)),
    multiply: (...a) => Df(hw(n, ...a)),
    divide: (...a) => Df(s2(n, ...a)),
    negate: () => Df(l2(n)),
    toString: () => n.toString()
  }),
  {
    add: i2,
    subtract: o2,
    multiply: hw,
    divide: s2,
    negate: l2
  }
);
function Mj(n, a = "-") {
  return n.replace(/\s+/g, a);
}
function Oj(n) {
  const a = Mj(n.toString());
  return Pj(zj(a));
}
function zj(n) {
  return n.includes("\\.") ? n : !Number.isInteger(parseFloat(n.toString())) ? n.replace(".", "\\.") : n;
}
function Pj(n) {
  return n.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function Lj(n, a = "") {
  return [a, n].filter(Boolean).join("-");
}
function $j(n, a) {
  return `var(${n}${a ? `, ${a}` : ""})`;
}
function Nj(n, a = "") {
  return Oj(`--${Lj(n, a)}`);
}
function et(n, a, s) {
  const c = Nj(n, s);
  return {
    variable: c,
    reference: $j(c, a)
  };
}
function Fj(n, a) {
  const s = {};
  for (const c of a) {
    if (Array.isArray(c)) {
      const [p, v] = c;
      s[p] = et(`${n}-${p}`, v);
      continue;
    }
    s[c] = et(`${n}-${c}`);
  }
  return s;
}
function Vj(n) {
  const a = n == null ? 0 : n.length;
  return a ? n[a - 1] : void 0;
}
function jj(n) {
  const a = parseFloat(n.toString()), s = n.toString().replace(String(a), "");
  return { unitless: !s, value: a, unit: s };
}
function mw(n) {
  if (n == null)
    return n;
  const { unitless: a } = jj(n);
  return a || typeof n == "number" ? `${n}px` : n;
}
var uO = (n, a) => parseInt(n[1], 10) > parseInt(a[1], 10) ? 1 : -1, Jw = (n) => Object.fromEntries(Object.entries(n).sort(uO));
function u2(n) {
  const a = Jw(n);
  return Object.assign(Object.values(a), a);
}
function Bj(n) {
  const a = Object.keys(Jw(n));
  return new Set(a);
}
function c2(n) {
  var a;
  if (!n)
    return n;
  n = (a = mw(n)) != null ? a : n;
  const s = -0.02;
  return typeof n == "number" ? `${n + s}` : n.replace(/(\d+\.?\d*)/u, (c) => `${parseFloat(c) + s}`);
}
function Pv(n, a) {
  const s = ["@media screen"];
  return n && s.push("and", `(min-width: ${mw(n)})`), a && s.push("and", `(max-width: ${mw(a)})`), s.join(" ");
}
function Uj(n) {
  var a;
  if (!n)
    return null;
  n.base = (a = n.base) != null ? a : "0px";
  const s = u2(n), c = Object.entries(n).sort(uO).map(([h, b], x, E) => {
    var w;
    let [, k] = (w = E[x + 1]) != null ? w : [];
    return k = parseFloat(k) > 0 ? c2(k) : void 0, {
      _minW: c2(b),
      breakpoint: h,
      minW: b,
      maxW: k,
      maxWQuery: Pv(null, k),
      minWQuery: Pv(b),
      minMaxQuery: Pv(b, k)
    };
  }), p = Bj(n), v = Array.from(p.values());
  return {
    keys: p,
    normalized: s,
    isResponsive(h) {
      const b = Object.keys(h);
      return b.length > 0 && b.every((x) => p.has(x));
    },
    asObject: Jw(n),
    asArray: u2(n),
    details: c,
    get(h) {
      return c.find((b) => b.breakpoint === h);
    },
    media: [
      null,
      ...s.map((h) => Pv(h)).slice(1)
    ],
    /**
     * Converts the object responsive syntax to array syntax
     *
     * @example
     * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
     */
    toArrayValue(h) {
      if (!is(h))
        throw new Error("toArrayValue: value must be an object");
      const b = v.map((x) => {
        var E;
        return (E = h[x]) != null ? E : null;
      });
      for (; Vj(b) === null; )
        b.pop();
      return b;
    },
    /**
     * Converts the array responsive syntax to object syntax
     *
     * @example
     * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
     */
    toObjectValue(h) {
      if (!Array.isArray(h))
        throw new Error("toObjectValue: value must be an array");
      return h.reduce((b, x, E) => {
        const w = v[E];
        return w != null && x != null && (b[w] = x), b;
      }, {});
    }
  };
}
var ma = {
  hover: (n, a) => `${n}:hover ${a}, ${n}[data-hover] ${a}`,
  focus: (n, a) => `${n}:focus ${a}, ${n}[data-focus] ${a}`,
  focusVisible: (n, a) => `${n}:focus-visible ${a}`,
  focusWithin: (n, a) => `${n}:focus-within ${a}`,
  active: (n, a) => `${n}:active ${a}, ${n}[data-active] ${a}`,
  disabled: (n, a) => `${n}:disabled ${a}, ${n}[data-disabled] ${a}`,
  invalid: (n, a) => `${n}:invalid ${a}, ${n}[data-invalid] ${a}`,
  checked: (n, a) => `${n}:checked ${a}, ${n}[data-checked] ${a}`,
  indeterminate: (n, a) => `${n}:indeterminate ${a}, ${n}[aria-checked=mixed] ${a}, ${n}[data-indeterminate] ${a}`,
  readOnly: (n, a) => `${n}:read-only ${a}, ${n}[readonly] ${a}, ${n}[data-read-only] ${a}`,
  expanded: (n, a) => `${n}:read-only ${a}, ${n}[aria-expanded=true] ${a}, ${n}[data-expanded] ${a}`,
  placeholderShown: (n, a) => `${n}:placeholder-shown ${a}`
}, rc = (n) => cO((a) => n(a, "&"), "[role=group]", "[data-group]", ".group"), Hl = (n) => cO((a) => n(a, "~ &"), "[data-peer]", ".peer"), cO = (n, ...a) => a.map(n).join(", "), AS = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",
  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",
  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within",
  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   * - `&[disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",
  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked]",
  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",
  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",
  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",
  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",
  /**
   * Styles for CSS selector `&::first-letter`
   *
   * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
   * @example
   * ```jsx
   * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
   * ```
   */
  _firstLetter: "&::first-letter",
  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",
  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",
  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",
  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: rc(ma.hover),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: Hl(ma.hover),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: rc(ma.focus),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: Hl(ma.focus),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: rc(ma.focusVisible),
  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: Hl(ma.focusVisible),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: rc(ma.active),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: Hl(ma.active),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: rc(ma.disabled),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: Hl(ma.disabled),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: rc(ma.invalid),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: Hl(ma.invalid),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: rc(ma.checked),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: Hl(ma.checked),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: rc(ma.focusWithin),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: Hl(ma.focusWithin),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: Hl(ma.placeholderShown),
  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder",
  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen",
  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",
  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  /**
   * Styles for the CSS Selector `&[data-orientation=horizontal]`
   */
  _horizontal: "&[data-orientation=horizontal]",
  /**
   * Styles for the CSS Selector `&[data-orientation=vertical]`
   */
  _vertical: "&[data-orientation=vertical]"
}, fO = Object.keys(
  AS
);
function f2(n, a) {
  return et(String(n).replace(/\./g, "-"), void 0, a);
}
function Ij(n, a) {
  let s = {};
  const c = {};
  for (const [p, v] of Object.entries(n)) {
    const { isSemantic: h, value: b } = v, { variable: x, reference: E } = f2(p, a == null ? void 0 : a.cssVarPrefix);
    if (!h) {
      if (p.startsWith("space")) {
        const _ = p.split("."), [A, ...L] = _, $ = `${A}.-${L.join(".")}`, Y = Df.negate(b), K = Df.negate(E);
        c[$] = {
          value: Y,
          var: x,
          varRef: K
        };
      }
      s[x] = b, c[p] = {
        value: b,
        var: x,
        varRef: E
      };
      continue;
    }
    const w = (_) => {
      const L = [String(p).split(".")[0], _].join(".");
      if (!n[L])
        return _;
      const { reference: Y } = f2(L, a == null ? void 0 : a.cssVarPrefix);
      return Y;
    }, k = is(b) ? b : { default: b };
    s = bo(
      s,
      Object.entries(k).reduce(
        (_, [A, L]) => {
          var $, Y;
          if (!L)
            return _;
          const K = w(`${L}`);
          if (A === "default")
            return _[x] = K, _;
          const W = (Y = ($ = AS) == null ? void 0 : $[A]) != null ? Y : A;
          return _[W] = { [x]: K }, _;
        },
        {}
      )
    ), c[p] = {
      value: E,
      var: x,
      varRef: E
    };
  }
  return {
    cssVars: s,
    cssMap: c
  };
}
function Hj(n, a = []) {
  const s = Object.assign({}, n);
  for (const c of a)
    c in s && delete s[c];
  return s;
}
function Wj(n, a) {
  const s = {};
  for (const c of a)
    c in n && (s[c] = n[c]);
  return s;
}
function Yj(n) {
  return typeof n == "object" && n != null && !Array.isArray(n);
}
function d2(n, a, s = {}) {
  const { stop: c, getKey: p } = s;
  function v(h, b = []) {
    var x;
    if (Yj(h) || Array.isArray(h)) {
      const E = {};
      for (const [w, k] of Object.entries(h)) {
        const _ = (x = p == null ? void 0 : p(w)) != null ? x : w, A = [...b, _];
        if (c != null && c(h, A))
          return a(h, b);
        E[_] = v(k, A);
      }
      return E;
    }
    return a(h, b);
  }
  return v(n);
}
var Gj = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function qj(n) {
  return Wj(n, Gj);
}
function Qj(n) {
  return n.semanticTokens;
}
function Kj(n) {
  const { __cssMap: a, __cssVars: s, __breakpoints: c, ...p } = n;
  return p;
}
var Xj = (n) => fO.includes(n) || n === "default";
function Zj({
  tokens: n,
  semanticTokens: a
}) {
  const s = {};
  return d2(n, (c, p) => {
    c != null && (s[p.join(".")] = { isSemantic: !1, value: c });
  }), d2(
    a,
    (c, p) => {
      c != null && (s[p.join(".")] = { isSemantic: !0, value: c });
    },
    {
      stop: (c) => Object.keys(c).every(Xj)
    }
  ), s;
}
function Jj(n) {
  var a;
  const s = Kj(n), c = qj(s), p = Qj(s), v = Zj({ tokens: c, semanticTokens: p }), h = (a = s.config) == null ? void 0 : a.cssVarPrefix, {
    /**
     * This is more like a dictionary of tokens users will type `green.500`,
     * and their equivalent css variable.
     */
    cssMap: b,
    /**
     * The extracted css variables will be stored here, and used in
     * the emotion's <Global/> component to attach variables to `:root`
     */
    cssVars: x
  } = Ij(v, { cssVarPrefix: h });
  return Object.assign(s, {
    __cssVars: { ...{
      "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-ring-offset-width": "0px",
      "--chakra-ring-offset-color": "#fff",
      "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
      "--chakra-ring-offset-shadow": "0 0 #0000",
      "--chakra-ring-shadow": "0 0 #0000",
      "--chakra-space-x-reverse": "0",
      "--chakra-space-y-reverse": "0"
    }, ...x },
    __cssMap: b,
    __breakpoints: Uj(s.breakpoints)
  }), s;
}
var eT = bo(
  {},
  Nb,
  Jt,
  mj,
  rS,
  yo,
  vj,
  Tj,
  yj,
  sO,
  wj,
  Uv,
  pw,
  Fn,
  Aj,
  Dj,
  kj,
  Rj,
  gj,
  _j
);
Object.assign({}, Fn, yo, rS, sO, Uv);
var eB = [...Object.keys(eT), ...fO], tB = { ...eT, ...AS }, nB = (n) => n in tB, rB = (n) => (a) => {
  if (!a.__breakpoints)
    return n;
  const { isResponsive: s, toArrayValue: c, media: p } = a.__breakpoints, v = {};
  for (const h in n) {
    let b = cc(n[h], a);
    if (b == null)
      continue;
    if (b = is(b) && s(b) ? c(b) : b, !Array.isArray(b)) {
      v[h] = b;
      continue;
    }
    const x = b.slice(0, p.length).length;
    for (let E = 0; E < x; E += 1) {
      const w = p == null ? void 0 : p[E];
      if (!w) {
        v[h] = b[E];
        continue;
      }
      v[w] = v[w] || {}, b[E] != null && (v[w][h] = b[E]);
    }
  }
  return v;
};
function aB(n) {
  const a = [];
  let s = "", c = !1;
  for (let p = 0; p < n.length; p++) {
    const v = n[p];
    v === "(" ? (c = !0, s += v) : v === ")" ? (c = !1, s += v) : v === "," && !c ? (a.push(s), s = "") : s += v;
  }
  return s = s.trim(), s && a.push(s), a;
}
function iB(n) {
  return /^var\(--.+\)$/.test(n);
}
var oB = (n, a) => n.startsWith("--") && typeof a == "string" && !iB(a), sB = (n, a) => {
  var s, c;
  if (a == null)
    return a;
  const p = (x) => {
    var E, w;
    return (w = (E = n.__cssMap) == null ? void 0 : E[x]) == null ? void 0 : w.varRef;
  }, v = (x) => {
    var E;
    return (E = p(x)) != null ? E : x;
  }, [h, b] = aB(a);
  return a = (c = (s = p(h)) != null ? s : v(b)) != null ? c : v(a), a;
};
function lB(n) {
  const { configs: a = {}, pseudos: s = {}, theme: c } = n, p = (v, h = !1) => {
    var b, x, E;
    const w = cc(v, c), k = rB(w)(c);
    let _ = {};
    for (let A in k) {
      const L = k[A];
      let $ = cc(L, c);
      A in s && (A = s[A]), oB(A, $) && ($ = sB(c, $));
      let Y = a[A];
      if (Y === !0 && (Y = { property: A }), is($)) {
        _[A] = (b = _[A]) != null ? b : {}, _[A] = bo(
          {},
          _[A],
          p($, !0)
        );
        continue;
      }
      let K = (E = (x = Y == null ? void 0 : Y.transform) == null ? void 0 : x.call(Y, $, c, w)) != null ? E : $;
      K = Y != null && Y.processResult ? p(K, !0) : K;
      const W = cc(Y == null ? void 0 : Y.property, c);
      if (!h && (Y != null && Y.static)) {
        const F = cc(Y.static, c);
        _ = bo({}, _, F);
      }
      if (W && Array.isArray(W)) {
        for (const F of W)
          _[F] = K;
        continue;
      }
      if (W) {
        W === "&" && is(K) ? _ = bo({}, _, K) : _[W] = K;
        continue;
      }
      if (is(K)) {
        _ = bo({}, _, K);
        continue;
      }
      _[A] = K;
    }
    return _;
  };
  return p;
}
var dO = (n) => (a) => lB({
  theme: a,
  pseudos: AS,
  configs: eT
})(n);
function An(n) {
  return {
    definePartsStyle(a) {
      return a;
    },
    defineMultiStyleConfig(a) {
      return { parts: n, ...a };
    }
  };
}
function uB(n, a) {
  if (Array.isArray(n))
    return n;
  if (is(n))
    return a(n);
  if (n != null)
    return [n];
}
function cB(n, a) {
  for (let s = a + 1; s < n.length; s++)
    if (n[s] != null)
      return s;
  return -1;
}
function fB(n) {
  const a = n.__breakpoints;
  return function(c, p, v, h) {
    var b, x;
    if (!a)
      return;
    const E = {}, w = uB(v, a.toArrayValue);
    if (!w)
      return E;
    const k = w.length, _ = k === 1, A = !!c.parts;
    for (let L = 0; L < k; L++) {
      const $ = a.details[L], Y = a.details[cB(w, L)], K = Pv($.minW, Y == null ? void 0 : Y._minW), W = cc((b = c[p]) == null ? void 0 : b[w[L]], h);
      if (W) {
        if (A) {
          (x = c.parts) == null || x.forEach((F) => {
            bo(E, {
              [F]: _ ? W[F] : { [K]: W[F] }
            });
          });
          continue;
        }
        if (!A) {
          _ ? bo(E, W) : E[K] = W;
          continue;
        }
        E[K] = W;
      }
    }
    return E;
  };
}
function dB(n) {
  return (a) => {
    var s;
    const { variant: c, size: p, theme: v } = a, h = fB(v);
    return bo(
      {},
      cc((s = n.baseStyle) != null ? s : {}, a),
      h(n, "sizes", p, a),
      h(n, "variants", c, a)
    );
  };
}
function tT(n) {
  return Hj(n, ["styleConfig", "size", "variant", "colorScheme"]);
}
var pB = [
  "borders",
  "breakpoints",
  "colors",
  "components",
  "config",
  "direction",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "space",
  "styles",
  "transition",
  "zIndices"
];
function hB(n) {
  return is(n) ? pB.every(
    (a) => Object.prototype.hasOwnProperty.call(n, a)
  ) : !1;
}
var mB = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
}, vB = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
}, yB = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
}, gB = {
  property: mB,
  easing: vB,
  duration: yB
}, bB = gB, SB = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
}, xB = SB, CB = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
}, EB = CB, wB = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
}, TB = wB, kB = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  },
  linkedin: {
    50: "#E8F4F9",
    100: "#CFEDFB",
    200: "#9BDAF3",
    300: "#68C7EC",
    400: "#34B3E4",
    500: "#00A0DC",
    600: "#008CC9",
    700: "#0077B5",
    800: "#005E93",
    900: "#004471"
  },
  facebook: {
    50: "#E8F4F9",
    100: "#D9DEE9",
    200: "#B7C2DA",
    300: "#6482C0",
    400: "#4267B2",
    500: "#385898",
    600: "#314E89",
    700: "#29487D",
    800: "#223B67",
    900: "#1E355B"
  },
  messenger: {
    50: "#D0E6FF",
    100: "#B9DAFF",
    200: "#A2CDFF",
    300: "#7AB8FF",
    400: "#2E90FF",
    500: "#0078FF",
    600: "#0063D1",
    700: "#0052AC",
    800: "#003C7E",
    900: "#002C5C"
  },
  whatsapp: {
    50: "#dffeec",
    100: "#b9f5d0",
    200: "#90edb3",
    300: "#65e495",
    400: "#3cdd78",
    500: "#22c35e",
    600: "#179848",
    700: "#0c6c33",
    800: "#01421c",
    900: "#001803"
  },
  twitter: {
    50: "#E5F4FD",
    100: "#C8E9FB",
    200: "#A8DCFA",
    300: "#83CDF7",
    400: "#57BBF5",
    500: "#1DA1F2",
    600: "#1A94DA",
    700: "#1681BF",
    800: "#136B9E",
    900: "#0D4D71"
  },
  telegram: {
    50: "#E3F2F9",
    100: "#C5E4F3",
    200: "#A2D4EC",
    300: "#7AC1E4",
    400: "#47A9DA",
    500: "#0088CC",
    600: "#007AB8",
    700: "#006BA1",
    800: "#005885",
    900: "#003F5E"
  }
}, RB = kB, _B = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
}, DB = _B, AB = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
}, MB = AB, OB = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
}, zB = OB, PB = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    3: ".75rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
}, pO = PB, hO = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
}, LB = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
}, $B = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
}, NB = {
  ...hO,
  ...LB,
  container: $B
}, mO = NB, vO = {
  breakpoints: TB,
  zIndices: xB,
  radii: DB,
  blur: zB,
  colors: RB,
  ...pO,
  sizes: mO,
  shadows: MB,
  space: hO,
  borders: EB,
  transition: bB
}, { defineMultiStyleConfig: FB, definePartsStyle: Lv } = An([
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
]), Yl = et("stepper-indicator-size"), Np = et("stepper-icon-size"), Fp = et("stepper-title-font-size"), $v = et("stepper-description-font-size"), _v = et("stepper-accent-color"), VB = Lv(({ colorScheme: n }) => ({
  stepper: {
    display: "flex",
    justifyContent: "space-between",
    gap: "4",
    "&[data-orientation=vertical]": {
      flexDirection: "column",
      alignItems: "flex-start"
    },
    "&[data-orientation=horizontal]": {
      flexDirection: "row",
      alignItems: "center"
    },
    [_v.variable]: `colors.${n}.500`,
    _dark: {
      [_v.variable]: `colors.${n}.200`
    }
  },
  title: {
    fontSize: Fp.reference,
    fontWeight: "medium"
  },
  description: {
    fontSize: $v.reference,
    color: "chakra-subtle-text"
  },
  number: {
    fontSize: Fp.reference
  },
  step: {
    flexShrink: 0,
    position: "relative",
    display: "flex",
    gap: "2",
    "&[data-orientation=horizontal]": {
      alignItems: "center"
    },
    flex: "1",
    "&:last-of-type:not([data-stretch])": {
      flex: "initial"
    }
  },
  icon: {
    flexShrink: 0,
    width: Np.reference,
    height: Np.reference
  },
  indicator: {
    flexShrink: 0,
    borderRadius: "full",
    width: Yl.reference,
    height: Yl.reference,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&[data-status=active]": {
      borderWidth: "2px",
      borderColor: _v.reference
    },
    "&[data-status=complete]": {
      bg: _v.reference,
      color: "chakra-inverse-text"
    },
    "&[data-status=incomplete]": {
      borderWidth: "2px"
    }
  },
  separator: {
    bg: "chakra-border-color",
    flex: "1",
    "&[data-status=complete]": {
      bg: _v.reference
    },
    "&[data-orientation=horizontal]": {
      width: "100%",
      height: "2px",
      marginStart: "2"
    },
    "&[data-orientation=vertical]": {
      width: "2px",
      position: "absolute",
      height: "100%",
      maxHeight: `calc(100% - ${Yl.reference} - 8px)`,
      top: `calc(${Yl.reference} + 4px)`,
      insetStart: `calc(${Yl.reference} / 2 - 1px)`
    }
  }
})), jB = FB({
  baseStyle: VB,
  sizes: {
    xs: Lv({
      stepper: {
        [Yl.variable]: "sizes.4",
        [Np.variable]: "sizes.3",
        [Fp.variable]: "fontSizes.xs",
        [$v.variable]: "fontSizes.xs"
      }
    }),
    sm: Lv({
      stepper: {
        [Yl.variable]: "sizes.6",
        [Np.variable]: "sizes.4",
        [Fp.variable]: "fontSizes.sm",
        [$v.variable]: "fontSizes.xs"
      }
    }),
    md: Lv({
      stepper: {
        [Yl.variable]: "sizes.8",
        [Np.variable]: "sizes.5",
        [Fp.variable]: "fontSizes.md",
        [$v.variable]: "fontSizes.sm"
      }
    }),
    lg: Lv({
      stepper: {
        [Yl.variable]: "sizes.10",
        [Np.variable]: "sizes.6",
        [Fp.variable]: "fontSizes.lg",
        [$v.variable]: "fontSizes.md"
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
function rn(n, a = {}) {
  let s = !1;
  function c() {
    if (!s) {
      s = !0;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function p(...w) {
    c();
    for (const k of w)
      a[k] = x(k);
    return rn(n, a);
  }
  function v(...w) {
    for (const k of w)
      k in a || (a[k] = x(k));
    return rn(n, a);
  }
  function h() {
    return Object.fromEntries(
      Object.entries(a).map(([k, _]) => [k, _.selector])
    );
  }
  function b() {
    return Object.fromEntries(
      Object.entries(a).map(([k, _]) => [k, _.className])
    );
  }
  function x(w) {
    const A = `chakra-${(["container", "root"].includes(w ?? "") ? [n] : [n, w]).filter(Boolean).join("__")}`;
    return {
      className: A,
      selector: `.${A}`,
      toString: () => w
    };
  }
  return {
    parts: p,
    toPart: x,
    extend: v,
    selectors: h,
    classnames: b,
    get keys() {
      return Object.keys(a);
    },
    __type: {}
  };
}
var BB = rn("accordion").parts("root", "container", "button", "panel").extend("icon"), UB = rn("alert").parts("title", "description", "container").extend("icon", "spinner"), IB = rn("avatar").parts("label", "badge", "container").extend("excessLabel", "group"), HB = rn("breadcrumb").parts("link", "item", "container").extend("separator");
rn("button").parts();
var WB = rn("checkbox").parts("control", "icon", "container").extend("label");
rn("progress").parts("track", "filledTrack").extend("label");
var YB = rn("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer"), GB = rn("editable").parts(
  "preview",
  "input",
  "textarea"
), qB = rn("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
), QB = rn("formError").parts("text", "icon"), KB = rn("input").parts(
  "addon",
  "field",
  "element",
  "group"
), XB = rn("list").parts("container", "item", "icon"), ZB = rn("menu").parts("button", "list", "item").extend("groupTitle", "icon", "command", "divider"), JB = rn("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer"), e6 = rn("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
rn("pininput").parts("field");
var t6 = rn("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton"), n6 = rn("progress").parts(
  "label",
  "filledTrack",
  "track"
), r6 = rn("radio").parts(
  "container",
  "control",
  "label"
), a6 = rn("select").parts("field", "icon"), i6 = rn("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
), o6 = rn("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
), s6 = rn("switch").parts(
  "container",
  "track",
  "thumb",
  "label"
), l6 = rn("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
), u6 = rn("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
), c6 = rn("tag").parts(
  "container",
  "label",
  "closeButton"
), f6 = rn("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
rn("stepper").parts(
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
);
function Of(n, a, s) {
  return Math.min(Math.max(n, s), a);
}
class d6 extends Error {
  constructor(a) {
    super(`Failed to parse color: "${a}"`);
  }
}
var Nv = d6;
function nT(n) {
  if (typeof n != "string")
    throw new Nv(n);
  if (n.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let a = n.trim();
  a = S6.test(n) ? m6(n) : n;
  const s = v6.exec(a);
  if (s) {
    const h = Array.from(s).slice(1);
    return [...h.slice(0, 3).map((b) => parseInt(ny(b, 2), 16)), parseInt(ny(h[3] || "f", 2), 16) / 255];
  }
  const c = y6.exec(a);
  if (c) {
    const h = Array.from(c).slice(1);
    return [...h.slice(0, 3).map((b) => parseInt(b, 16)), parseInt(h[3] || "ff", 16) / 255];
  }
  const p = g6.exec(a);
  if (p) {
    const h = Array.from(p).slice(1);
    return [...h.slice(0, 3).map((b) => parseInt(b, 10)), parseFloat(h[3] || "1")];
  }
  const v = b6.exec(a);
  if (v) {
    const [h, b, x, E] = Array.from(v).slice(1).map(parseFloat);
    if (Of(0, 100, b) !== b)
      throw new Nv(n);
    if (Of(0, 100, x) !== x)
      throw new Nv(n);
    return [...x6(h, b, x), Number.isNaN(E) ? 1 : E];
  }
  throw new Nv(n);
}
function p6(n) {
  let a = 5381, s = n.length;
  for (; s; )
    a = a * 33 ^ n.charCodeAt(--s);
  return (a >>> 0) % 2341;
}
const p2 = (n) => parseInt(n.replace(/_/g, ""), 36), h6 = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((n, a) => {
  const s = p2(a.substring(0, 3)), c = p2(a.substring(3)).toString(16);
  let p = "";
  for (let v = 0; v < 6 - c.length; v++)
    p += "0";
  return n[s] = `${p}${c}`, n;
}, {});
function m6(n) {
  const a = n.toLowerCase().trim(), s = h6[p6(a)];
  if (!s)
    throw new Nv(n);
  return `#${s}`;
}
const ny = (n, a) => Array.from(Array(a)).map(() => n).join(""), v6 = new RegExp(`^#${ny("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), y6 = new RegExp(`^#${ny("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), g6 = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${ny(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), b6 = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, S6 = /^[a-z]+$/i, h2 = (n) => Math.round(n * 255), x6 = (n, a, s) => {
  let c = s / 100;
  if (a === 0)
    return [c, c, c].map(h2);
  const p = (n % 360 + 360) % 360 / 60, v = (1 - Math.abs(2 * c - 1)) * (a / 100), h = v * (1 - Math.abs(p % 2 - 1));
  let b = 0, x = 0, E = 0;
  p >= 0 && p < 1 ? (b = v, x = h) : p >= 1 && p < 2 ? (b = h, x = v) : p >= 2 && p < 3 ? (x = v, E = h) : p >= 3 && p < 4 ? (x = h, E = v) : p >= 4 && p < 5 ? (b = h, E = v) : p >= 5 && p < 6 && (b = v, E = h);
  const w = c - v / 2, k = b + w, _ = x + w, A = E + w;
  return [k, _, A].map(h2);
};
function C6(n, a, s, c) {
  return `rgba(${Of(0, 255, n).toFixed()}, ${Of(0, 255, a).toFixed()}, ${Of(0, 255, s).toFixed()}, ${parseFloat(Of(0, 1, c).toFixed(3))})`;
}
function E6(n, a) {
  const [s, c, p, v] = nT(n);
  return C6(s, c, p, v - a);
}
function w6(n) {
  const [a, s, c, p] = nT(n);
  let v = (h) => {
    const b = Of(0, 255, h).toString(16);
    return b.length === 1 ? `0${b}` : b;
  };
  return `#${v(a)}${v(s)}${v(c)}${p < 1 ? v(Math.round(p * 255)) : ""}`;
}
function T6(n, a, s, c, p) {
  for (a = a.split ? a.split(".") : a, c = 0; c < a.length; c++)
    n = n ? n[a[c]] : p;
  return n === p ? s : n;
}
var k6 = (n) => Object.keys(n).length === 0, ii = (n, a, s) => {
  const c = T6(n, `colors.${a}`, a);
  try {
    return w6(c), c;
  } catch {
    return s ?? "#000000";
  }
}, R6 = (n) => {
  const [a, s, c] = nT(n);
  return (a * 299 + s * 587 + c * 114) / 1e3;
}, _6 = (n) => (a) => {
  const s = ii(a, n);
  return R6(s) < 128 ? "dark" : "light";
}, D6 = (n) => (a) => _6(n)(a) === "dark", sh = (n, a) => (s) => {
  const c = ii(s, n);
  return E6(c, 1 - a);
};
function m2(n = "1rem", a = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${a} 25%,
    transparent 25%,
    transparent 50%,
    ${a} 50%,
    ${a} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${n} ${n}`
  };
}
var A6 = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function M6(n) {
  const a = A6();
  return !n || k6(n) ? a : n.string && n.colors ? z6(n.string, n.colors) : n.string && !n.colors ? O6(n.string) : n.colors && !n.string ? P6(n.colors) : a;
}
function O6(n) {
  let a = 0;
  if (n.length === 0)
    return a.toString();
  for (let c = 0; c < n.length; c += 1)
    a = n.charCodeAt(c) + ((a << 5) - a), a = a & a;
  let s = "#";
  for (let c = 0; c < 3; c += 1) {
    const p = a >> c * 8 & 255;
    s += `00${p.toString(16)}`.substr(-2);
  }
  return s;
}
function z6(n, a) {
  let s = 0;
  if (n.length === 0)
    return a[0];
  for (let c = 0; c < n.length; c += 1)
    s = n.charCodeAt(c) + ((s << 5) - s), s = s & s;
  return s = (s % a.length + a.length) % a.length, a[s];
}
function P6(n) {
  return n[Math.floor(Math.random() * n.length)];
}
function Je(n, a) {
  return (s) => s.colorMode === "dark" ? a : n;
}
function rT(n) {
  const { orientation: a, vertical: s, horizontal: c } = n;
  return a ? a === "vertical" ? s : c : {};
}
function yO(n) {
  return is(n) && n.reference ? n.reference : String(n);
}
var MS = (n, ...a) => a.map(yO).join(` ${n} `).replace(/calc/g, ""), v2 = (...n) => `calc(${MS("+", ...n)})`, y2 = (...n) => `calc(${MS("-", ...n)})`, vw = (...n) => `calc(${MS("*", ...n)})`, g2 = (...n) => `calc(${MS("/", ...n)})`, b2 = (n) => {
  const a = yO(n);
  return a != null && !Number.isNaN(parseFloat(a)) ? String(a).startsWith("-") ? String(a).slice(1) : `-${a}` : vw(a, -1);
}, Gl = Object.assign(
  (n) => ({
    add: (...a) => Gl(v2(n, ...a)),
    subtract: (...a) => Gl(y2(n, ...a)),
    multiply: (...a) => Gl(vw(n, ...a)),
    divide: (...a) => Gl(g2(n, ...a)),
    negate: () => Gl(b2(n)),
    toString: () => n.toString()
  }),
  {
    add: v2,
    subtract: y2,
    multiply: vw,
    divide: g2,
    negate: b2
  }
);
function L6(n) {
  return !Number.isInteger(parseFloat(n.toString()));
}
function $6(n, a = "-") {
  return n.replace(/\s+/g, a);
}
function gO(n) {
  const a = $6(n.toString());
  return a.includes("\\.") ? n : L6(n) ? a.replace(".", "\\.") : n;
}
function N6(n, a = "") {
  return [a, gO(n)].filter(Boolean).join("-");
}
function F6(n, a) {
  return `var(${gO(n)}${a ? `, ${a}` : ""})`;
}
function V6(n, a = "") {
  return `--${N6(n, a)}`;
}
function jr(n, a) {
  const s = V6(n, a == null ? void 0 : a.prefix);
  return {
    variable: s,
    reference: F6(s, j6(a == null ? void 0 : a.fallback))
  };
}
function j6(n) {
  return typeof n == "string" ? n : n == null ? void 0 : n.reference;
}
var { defineMultiStyleConfig: B6, definePartsStyle: Fb } = An(s6.keys), Iv = jr("switch-track-width"), $f = jr("switch-track-height"), xE = jr("switch-track-diff"), U6 = Gl.subtract(Iv, $f), yw = jr("switch-thumb-x"), Dv = jr("switch-bg"), I6 = (n) => {
  const { colorScheme: a } = n;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [Iv.reference],
    height: [$f.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [Dv.variable]: "colors.gray.300",
    _dark: {
      [Dv.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [Dv.variable]: `colors.${a}.500`,
      _dark: {
        [Dv.variable]: `colors.${a}.200`
      }
    },
    bg: Dv.reference
  };
}, H6 = {
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [$f.reference],
  height: [$f.reference],
  _checked: {
    transform: `translateX(${yw.reference})`
  }
}, W6 = Fb((n) => ({
  container: {
    [xE.variable]: U6,
    [yw.variable]: xE.reference,
    _rtl: {
      [yw.variable]: Gl(xE).negate().toString()
    }
  },
  track: I6(n),
  thumb: H6
})), Y6 = {
  sm: Fb({
    container: {
      [Iv.variable]: "1.375rem",
      [$f.variable]: "sizes.3"
    }
  }),
  md: Fb({
    container: {
      [Iv.variable]: "1.875rem",
      [$f.variable]: "sizes.4"
    }
  }),
  lg: Fb({
    container: {
      [Iv.variable]: "2.875rem",
      [$f.variable]: "sizes.6"
    }
  })
}, G6 = B6({
  baseStyle: W6,
  sizes: Y6,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: q6, definePartsStyle: qp } = An(l6.keys), Q6 = qp({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
}), aS = {
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
}, K6 = qp((n) => {
  const { colorScheme: a } = n;
  return {
    th: {
      color: Je("gray.600", "gray.400")(n),
      borderBottom: "1px",
      borderColor: Je(`${a}.100`, `${a}.700`)(n),
      ...aS
    },
    td: {
      borderBottom: "1px",
      borderColor: Je(`${a}.100`, `${a}.700`)(n),
      ...aS
    },
    caption: {
      color: Je("gray.600", "gray.100")(n)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
}), X6 = qp((n) => {
  const { colorScheme: a } = n;
  return {
    th: {
      color: Je("gray.600", "gray.400")(n),
      borderBottom: "1px",
      borderColor: Je(`${a}.100`, `${a}.700`)(n),
      ...aS
    },
    td: {
      borderBottom: "1px",
      borderColor: Je(`${a}.100`, `${a}.700`)(n),
      ...aS
    },
    caption: {
      color: Je("gray.600", "gray.100")(n)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: Je(`${a}.100`, `${a}.700`)(n)
          },
          td: {
            background: Je(`${a}.100`, `${a}.700`)(n)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
}), Z6 = {
  simple: K6,
  striped: X6,
  unstyled: {}
}, J6 = {
  sm: qp({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: qp({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: qp({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
}, eU = q6({
  baseStyle: Q6,
  variants: Z6,
  sizes: J6,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
}), Di = et("tabs-color"), rs = et("tabs-bg"), gb = et("tabs-border-color"), { defineMultiStyleConfig: tU, definePartsStyle: qs } = An(u6.keys), nU = (n) => {
  const { orientation: a } = n;
  return {
    display: a === "vertical" ? "flex" : "block"
  };
}, rU = (n) => {
  const { isFitted: a } = n;
  return {
    flex: a ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
}, aU = (n) => {
  const { align: a = "start", orientation: s } = n;
  return {
    justifyContent: {
      end: "flex-end",
      center: "center",
      start: "flex-start"
    }[a],
    flexDirection: s === "vertical" ? "column" : "row"
  };
}, iU = {
  p: 4
}, oU = qs((n) => ({
  root: nU(n),
  tab: rU(n),
  tablist: aU(n),
  tabpanel: iU
})), sU = {
  sm: qs({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: qs({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: qs({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
}, lU = qs((n) => {
  const { colorScheme: a, orientation: s } = n, c = s === "vertical", p = c ? "borderStart" : "borderBottom", v = c ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [p]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [p]: "2px solid",
      borderColor: "transparent",
      [v]: "-2px",
      _selected: {
        [Di.variable]: `colors.${a}.600`,
        _dark: {
          [Di.variable]: `colors.${a}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [rs.variable]: "colors.gray.200",
        _dark: {
          [rs.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: { bg: "none" }
      },
      color: Di.reference,
      bg: rs.reference
    }
  };
}), uU = qs((n) => {
  const { colorScheme: a } = n;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [gb.variable]: "transparent",
      _selected: {
        [Di.variable]: `colors.${a}.600`,
        [gb.variable]: "colors.white",
        _dark: {
          [Di.variable]: `colors.${a}.300`,
          [gb.variable]: "colors.gray.800"
        },
        borderColor: "inherit",
        borderBottomColor: gb.reference
      },
      color: Di.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
}), cU = qs((n) => {
  const { colorScheme: a } = n;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [rs.variable]: "colors.gray.50",
      _dark: {
        [rs.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [rs.variable]: "colors.white",
        [Di.variable]: `colors.${a}.600`,
        _dark: {
          [rs.variable]: "colors.gray.800",
          [Di.variable]: `colors.${a}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: Di.reference,
      bg: rs.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
}), fU = qs((n) => {
  const { colorScheme: a, theme: s } = n;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: ii(s, `${a}.700`),
        bg: ii(s, `${a}.100`)
      }
    }
  };
}), dU = qs((n) => {
  const { colorScheme: a } = n;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [Di.variable]: "colors.gray.600",
      _dark: {
        [Di.variable]: "inherit"
      },
      _selected: {
        [Di.variable]: "colors.white",
        [rs.variable]: `colors.${a}.600`,
        _dark: {
          [Di.variable]: "colors.gray.800",
          [rs.variable]: `colors.${a}.300`
        }
      },
      color: Di.reference,
      bg: rs.reference
    }
  };
}), pU = qs({}), hU = {
  line: lU,
  enclosed: uU,
  "enclosed-colored": cU,
  "soft-rounded": fU,
  "solid-rounded": dU,
  unstyled: pU
}, mU = tU({
  baseStyle: oU,
  sizes: sU,
  variants: hU,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
}), dr = Fj("badge", ["bg", "color", "shadow"]), vU = {
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold",
  bg: dr.bg.reference,
  color: dr.color.reference,
  boxShadow: dr.shadow.reference
}, yU = (n) => {
  const { colorScheme: a, theme: s } = n, c = sh(`${a}.500`, 0.6)(s);
  return {
    [dr.bg.variable]: `colors.${a}.500`,
    [dr.color.variable]: "colors.white",
    _dark: {
      [dr.bg.variable]: c,
      [dr.color.variable]: "colors.whiteAlpha.800"
    }
  };
}, gU = (n) => {
  const { colorScheme: a, theme: s } = n, c = sh(`${a}.200`, 0.16)(s);
  return {
    [dr.bg.variable]: `colors.${a}.100`,
    [dr.color.variable]: `colors.${a}.800`,
    _dark: {
      [dr.bg.variable]: c,
      [dr.color.variable]: `colors.${a}.200`
    }
  };
}, bU = (n) => {
  const { colorScheme: a, theme: s } = n, c = sh(`${a}.200`, 0.8)(s);
  return {
    [dr.color.variable]: `colors.${a}.500`,
    _dark: {
      [dr.color.variable]: c
    },
    [dr.shadow.variable]: `inset 0 0 0px 1px ${dr.color.reference}`
  };
}, SU = {
  solid: yU,
  subtle: gU,
  outline: bU
}, Hv = {
  baseStyle: vU,
  variants: SU,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
}, { defineMultiStyleConfig: xU, definePartsStyle: Nf } = An(c6.keys), S2 = et("tag-bg"), x2 = et("tag-color"), CE = et("tag-shadow"), Vb = et("tag-min-height"), jb = et("tag-min-width"), Bb = et("tag-font-size"), Ub = et("tag-padding-inline"), CU = {
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  [x2.variable]: dr.color.reference,
  [S2.variable]: dr.bg.reference,
  [CE.variable]: dr.shadow.reference,
  color: x2.reference,
  bg: S2.reference,
  boxShadow: CE.reference,
  borderRadius: "md",
  minH: Vb.reference,
  minW: jb.reference,
  fontSize: Bb.reference,
  px: Ub.reference,
  _focusVisible: {
    [CE.variable]: "shadows.outline"
  }
}, EU = {
  lineHeight: 1.2,
  overflow: "visible"
}, wU = {
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
}, TU = Nf({
  container: CU,
  label: EU,
  closeButton: wU
}), kU = {
  sm: Nf({
    container: {
      [Vb.variable]: "sizes.5",
      [jb.variable]: "sizes.5",
      [Bb.variable]: "fontSizes.xs",
      [Ub.variable]: "space.2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: Nf({
    container: {
      [Vb.variable]: "sizes.6",
      [jb.variable]: "sizes.6",
      [Bb.variable]: "fontSizes.sm",
      [Ub.variable]: "space.2"
    }
  }),
  lg: Nf({
    container: {
      [Vb.variable]: "sizes.8",
      [jb.variable]: "sizes.8",
      [Bb.variable]: "fontSizes.md",
      [Ub.variable]: "space.3"
    }
  })
}, RU = {
  subtle: Nf((n) => {
    var a;
    return {
      container: (a = Hv.variants) == null ? void 0 : a.subtle(n)
    };
  }),
  solid: Nf((n) => {
    var a;
    return {
      container: (a = Hv.variants) == null ? void 0 : a.solid(n)
    };
  }),
  outline: Nf((n) => {
    var a;
    return {
      container: (a = Hv.variants) == null ? void 0 : a.outline(n)
    };
  })
}, _U = xU({
  variants: RU,
  baseStyle: TU,
  sizes: kU,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
}), { definePartsStyle: ql, defineMultiStyleConfig: DU } = An(KB.keys), Vp = et("input-height"), jp = et("input-font-size"), Bp = et("input-padding"), Up = et("input-border-radius"), AU = ql({
  addon: {
    height: Vp.reference,
    fontSize: jp.reference,
    px: Bp.reference,
    borderRadius: Up.reference
  },
  field: {
    width: "100%",
    height: Vp.reference,
    fontSize: jp.reference,
    px: Bp.reference,
    borderRadius: Up.reference,
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
}), ac = {
  lg: {
    [jp.variable]: "fontSizes.lg",
    [Bp.variable]: "space.4",
    [Up.variable]: "radii.md",
    [Vp.variable]: "sizes.12"
  },
  md: {
    [jp.variable]: "fontSizes.md",
    [Bp.variable]: "space.4",
    [Up.variable]: "radii.md",
    [Vp.variable]: "sizes.10"
  },
  sm: {
    [jp.variable]: "fontSizes.sm",
    [Bp.variable]: "space.3",
    [Up.variable]: "radii.sm",
    [Vp.variable]: "sizes.8"
  },
  xs: {
    [jp.variable]: "fontSizes.xs",
    [Bp.variable]: "space.2",
    [Up.variable]: "radii.sm",
    [Vp.variable]: "sizes.6"
  }
}, MU = {
  lg: ql({
    field: ac.lg,
    group: ac.lg
  }),
  md: ql({
    field: ac.md,
    group: ac.md
  }),
  sm: ql({
    field: ac.sm,
    group: ac.sm
  }),
  xs: ql({
    field: ac.xs,
    group: ac.xs
  })
};
function aT(n) {
  const { focusBorderColor: a, errorBorderColor: s } = n;
  return {
    focusBorderColor: a || Je("blue.500", "blue.300")(n),
    errorBorderColor: s || Je("red.500", "red.300")(n)
  };
}
var OU = ql((n) => {
  const { theme: a } = n, { focusBorderColor: s, errorBorderColor: c } = aT(n);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: Je("gray.300", "whiteAlpha.400")(n)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: ii(a, c),
        boxShadow: `0 0 0 1px ${ii(a, c)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: ii(a, s),
        boxShadow: `0 0 0 1px ${ii(a, s)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: Je("inherit", "whiteAlpha.50")(n),
      bg: Je("gray.100", "whiteAlpha.300")(n)
    }
  };
}), zU = ql((n) => {
  const { theme: a } = n, { focusBorderColor: s, errorBorderColor: c } = aT(n);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: Je("gray.100", "whiteAlpha.50")(n),
      _hover: {
        bg: Je("gray.200", "whiteAlpha.100")(n)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: ii(a, c)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: ii(a, s)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: Je("gray.100", "whiteAlpha.50")(n)
    }
  };
}), PU = ql((n) => {
  const { theme: a } = n, { focusBorderColor: s, errorBorderColor: c } = aT(n);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: ii(a, c),
        boxShadow: `0px 1px 0px 0px ${ii(a, c)}`
      },
      _focusVisible: {
        borderColor: ii(a, s),
        boxShadow: `0px 1px 0px 0px ${ii(a, s)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
}), LU = ql({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
}), $U = {
  outline: OU,
  filled: zU,
  flushed: PU,
  unstyled: LU
}, nn = DU({
  baseStyle: AU,
  sizes: MU,
  variants: $U,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
}), C2, NU = {
  ...(C2 = nn.baseStyle) == null ? void 0 : C2.field,
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
}, E2, w2, FU = {
  outline: (n) => {
    var a, s;
    return (s = (a = nn.variants) == null ? void 0 : a.outline(n).field) != null ? s : {};
  },
  flushed: (n) => {
    var a, s;
    return (s = (a = nn.variants) == null ? void 0 : a.flushed(n).field) != null ? s : {};
  },
  filled: (n) => {
    var a, s;
    return (s = (a = nn.variants) == null ? void 0 : a.filled(n).field) != null ? s : {};
  },
  unstyled: (w2 = (E2 = nn.variants) == null ? void 0 : E2.unstyled.field) != null ? w2 : {}
}, T2, k2, R2, _2, D2, A2, M2, O2, VU = {
  xs: (k2 = (T2 = nn.sizes) == null ? void 0 : T2.xs.field) != null ? k2 : {},
  sm: (_2 = (R2 = nn.sizes) == null ? void 0 : R2.sm.field) != null ? _2 : {},
  md: (A2 = (D2 = nn.sizes) == null ? void 0 : D2.md.field) != null ? A2 : {},
  lg: (O2 = (M2 = nn.sizes) == null ? void 0 : M2.lg.field) != null ? O2 : {}
}, jU = {
  baseStyle: NU,
  sizes: VU,
  variants: FU,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
}, bb = jr("tooltip-bg"), EE = jr("tooltip-fg"), BU = jr("popper-arrow-bg"), UU = {
  bg: bb.reference,
  color: EE.reference,
  [bb.variable]: "colors.gray.700",
  [EE.variable]: "colors.whiteAlpha.900",
  _dark: {
    [bb.variable]: "colors.gray.300",
    [EE.variable]: "colors.gray.900"
  },
  [BU.variable]: bb.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
}, IU = {
  baseStyle: UU
}, { defineMultiStyleConfig: HU, definePartsStyle: Fv } = An(n6.keys), WU = (n) => {
  const { colorScheme: a, theme: s, isIndeterminate: c, hasStripe: p } = n, v = Je(
    m2(),
    m2("1rem", "rgba(0,0,0,0.1)")
  )(n), h = Je(`${a}.500`, `${a}.200`)(n), b = `linear-gradient(
    to right,
    transparent 0%,
    ${ii(s, h)} 50%,
    transparent 100%
  )`;
  return {
    ...!c && p && v,
    ...c ? { bgImage: b } : { bgColor: h }
  };
}, YU = {
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
}, GU = (n) => ({
  bg: Je("gray.100", "whiteAlpha.300")(n)
}), qU = (n) => ({
  transitionProperty: "common",
  transitionDuration: "slow",
  ...WU(n)
}), QU = Fv((n) => ({
  label: YU,
  filledTrack: qU(n),
  track: GU(n)
})), KU = {
  xs: Fv({
    track: { h: "1" }
  }),
  sm: Fv({
    track: { h: "2" }
  }),
  md: Fv({
    track: { h: "3" }
  }),
  lg: Fv({
    track: { h: "4" }
  })
}, XU = HU({
  sizes: KU,
  baseStyle: QU,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), ZU = (n) => typeof n == "function";
function oi(n, ...a) {
  return ZU(n) ? n(...a) : n;
}
var { definePartsStyle: Ib, defineMultiStyleConfig: JU } = An(WB.keys), Wv = et("checkbox-size"), e8 = (n) => {
  const { colorScheme: a } = n;
  return {
    w: Wv.reference,
    h: Wv.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: Je(`${a}.500`, `${a}.200`)(n),
      borderColor: Je(`${a}.500`, `${a}.200`)(n),
      color: Je("white", "gray.900")(n),
      _hover: {
        bg: Je(`${a}.600`, `${a}.300`)(n),
        borderColor: Je(`${a}.600`, `${a}.300`)(n)
      },
      _disabled: {
        borderColor: Je("gray.200", "transparent")(n),
        bg: Je("gray.200", "whiteAlpha.300")(n),
        color: Je("gray.500", "whiteAlpha.500")(n)
      }
    },
    _indeterminate: {
      bg: Je(`${a}.500`, `${a}.200`)(n),
      borderColor: Je(`${a}.500`, `${a}.200`)(n),
      color: Je("white", "gray.900")(n)
    },
    _disabled: {
      bg: Je("gray.100", "whiteAlpha.100")(n),
      borderColor: Je("gray.100", "transparent")(n)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: Je("red.500", "red.300")(n)
    }
  };
}, t8 = {
  _disabled: { cursor: "not-allowed" }
}, n8 = {
  userSelect: "none",
  _disabled: { opacity: 0.4 }
}, r8 = {
  transitionProperty: "transform",
  transitionDuration: "normal"
}, a8 = Ib((n) => ({
  icon: r8,
  container: t8,
  control: oi(e8, n),
  label: n8
})), i8 = {
  sm: Ib({
    control: { [Wv.variable]: "sizes.3" },
    label: { fontSize: "sm" },
    icon: { fontSize: "3xs" }
  }),
  md: Ib({
    control: { [Wv.variable]: "sizes.4" },
    label: { fontSize: "md" },
    icon: { fontSize: "2xs" }
  }),
  lg: Ib({
    control: { [Wv.variable]: "sizes.5" },
    label: { fontSize: "lg" },
    icon: { fontSize: "2xs" }
  })
}, iS = JU({
  baseStyle: a8,
  sizes: i8,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: o8, definePartsStyle: Hb } = An(r6.keys), s8 = (n) => {
  var a;
  const s = (a = oi(iS.baseStyle, n)) == null ? void 0 : a.control;
  return {
    ...s,
    borderRadius: "full",
    _checked: {
      ...s == null ? void 0 : s._checked,
      _before: {
        content: '""',
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
}, l8 = Hb((n) => {
  var a, s, c, p;
  return {
    label: (s = (a = iS).baseStyle) == null ? void 0 : s.call(a, n).label,
    container: (p = (c = iS).baseStyle) == null ? void 0 : p.call(c, n).container,
    control: s8(n)
  };
}), u8 = {
  md: Hb({
    control: { w: "4", h: "4" },
    label: { fontSize: "md" }
  }),
  lg: Hb({
    control: { w: "5", h: "5" },
    label: { fontSize: "lg" }
  }),
  sm: Hb({
    control: { width: "3", height: "3" },
    label: { fontSize: "sm" }
  })
}, c8 = o8({
  baseStyle: l8,
  sizes: u8,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: f8, definePartsStyle: d8 } = An(a6.keys), Sb = et("select-bg"), z2, p8 = {
  ...(z2 = nn.baseStyle) == null ? void 0 : z2.field,
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: Sb.reference,
  [Sb.variable]: "colors.white",
  _dark: {
    [Sb.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: Sb.reference
  }
}, h8 = {
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
}, m8 = d8({
  field: p8,
  icon: h8
}), xb = {
  paddingInlineEnd: "8"
}, P2, L2, $2, N2, F2, V2, j2, B2, v8 = {
  lg: {
    ...(P2 = nn.sizes) == null ? void 0 : P2.lg,
    field: {
      ...(L2 = nn.sizes) == null ? void 0 : L2.lg.field,
      ...xb
    }
  },
  md: {
    ...($2 = nn.sizes) == null ? void 0 : $2.md,
    field: {
      ...(N2 = nn.sizes) == null ? void 0 : N2.md.field,
      ...xb
    }
  },
  sm: {
    ...(F2 = nn.sizes) == null ? void 0 : F2.sm,
    field: {
      ...(V2 = nn.sizes) == null ? void 0 : V2.sm.field,
      ...xb
    }
  },
  xs: {
    ...(j2 = nn.sizes) == null ? void 0 : j2.xs,
    field: {
      ...(B2 = nn.sizes) == null ? void 0 : B2.xs.field,
      ...xb
    },
    icon: {
      insetEnd: "1"
    }
  }
}, y8 = f8({
  baseStyle: m8,
  sizes: v8,
  variants: nn.variants,
  defaultProps: nn.defaultProps
}), wE = et("skeleton-start-color"), TE = et("skeleton-end-color"), g8 = {
  [wE.variable]: "colors.gray.100",
  [TE.variable]: "colors.gray.400",
  _dark: {
    [wE.variable]: "colors.gray.800",
    [TE.variable]: "colors.gray.600"
  },
  background: wE.reference,
  borderColor: TE.reference,
  opacity: 0.7,
  borderRadius: "sm"
}, b8 = {
  baseStyle: g8
}, kE = et("skip-link-bg"), S8 = {
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [kE.variable]: "colors.white",
    _dark: {
      [kE.variable]: "colors.gray.700"
    },
    bg: kE.reference
  }
}, x8 = {
  baseStyle: S8
}, { defineMultiStyleConfig: C8, definePartsStyle: OS } = An(i6.keys), ry = et("slider-thumb-size"), ay = et("slider-track-size"), uc = et("slider-bg"), E8 = (n) => {
  const { orientation: a } = n;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...rT({
      orientation: a,
      vertical: { h: "100%" },
      horizontal: { w: "100%" }
    })
  };
}, w8 = (n) => ({
  ...rT({
    orientation: n.orientation,
    horizontal: { h: ay.reference },
    vertical: { w: ay.reference }
  }),
  overflow: "hidden",
  borderRadius: "sm",
  [uc.variable]: "colors.gray.200",
  _dark: {
    [uc.variable]: "colors.whiteAlpha.200"
  },
  _disabled: {
    [uc.variable]: "colors.gray.300",
    _dark: {
      [uc.variable]: "colors.whiteAlpha.300"
    }
  },
  bg: uc.reference
}), T8 = (n) => {
  const { orientation: a } = n;
  return {
    ...rT({
      orientation: a,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        _active: {
          transform: "translateX(-50%) scale(1.15)"
        }
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        _active: {
          transform: "translateY(-50%) scale(1.15)"
        }
      }
    }),
    w: ry.reference,
    h: ry.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
}, k8 = (n) => {
  const { colorScheme: a } = n;
  return {
    width: "inherit",
    height: "inherit",
    [uc.variable]: `colors.${a}.500`,
    _dark: {
      [uc.variable]: `colors.${a}.200`
    },
    bg: uc.reference
  };
}, R8 = OS((n) => ({
  container: E8(n),
  track: w8(n),
  thumb: T8(n),
  filledTrack: k8(n)
})), _8 = OS({
  container: {
    [ry.variable]: "sizes.4",
    [ay.variable]: "sizes.1"
  }
}), D8 = OS({
  container: {
    [ry.variable]: "sizes.3.5",
    [ay.variable]: "sizes.1"
  }
}), A8 = OS({
  container: {
    [ry.variable]: "sizes.2.5",
    [ay.variable]: "sizes.0.5"
  }
}), M8 = {
  lg: _8,
  md: D8,
  sm: A8
}, O8 = C8({
  baseStyle: R8,
  sizes: M8,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), Af = jr("spinner-size"), z8 = {
  width: [Af.reference],
  height: [Af.reference]
}, P8 = {
  xs: {
    [Af.variable]: "sizes.3"
  },
  sm: {
    [Af.variable]: "sizes.4"
  },
  md: {
    [Af.variable]: "sizes.6"
  },
  lg: {
    [Af.variable]: "sizes.8"
  },
  xl: {
    [Af.variable]: "sizes.12"
  }
}, L8 = {
  baseStyle: z8,
  sizes: P8,
  defaultProps: {
    size: "md"
  }
}, { defineMultiStyleConfig: $8, definePartsStyle: bO } = An(o6.keys), N8 = {
  fontWeight: "medium"
}, F8 = {
  opacity: 0.8,
  marginBottom: "2"
}, V8 = {
  verticalAlign: "baseline",
  fontWeight: "semibold"
}, j8 = {
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
}, B8 = bO({
  container: {},
  label: N8,
  helpText: F8,
  number: V8,
  icon: j8
}), U8 = {
  md: bO({
    label: { fontSize: "sm" },
    helpText: { fontSize: "sm" },
    number: { fontSize: "2xl" }
  })
}, I8 = $8({
  baseStyle: B8,
  sizes: U8,
  defaultProps: {
    size: "md"
  }
}), RE = et("kbd-bg"), H8 = {
  [RE.variable]: "colors.gray.100",
  _dark: {
    [RE.variable]: "colors.whiteAlpha.100"
  },
  bg: RE.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
}, W8 = {
  baseStyle: H8
}, Y8 = {
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
}, G8 = {
  baseStyle: Y8
}, { defineMultiStyleConfig: q8, definePartsStyle: Q8 } = An(XB.keys), K8 = {
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
}, X8 = Q8({
  icon: K8
}), Z8 = q8({
  baseStyle: X8
}), { defineMultiStyleConfig: J8, definePartsStyle: eI } = An(ZB.keys), Hs = et("menu-bg"), _E = et("menu-shadow"), tI = {
  [Hs.variable]: "#fff",
  [_E.variable]: "shadows.sm",
  _dark: {
    [Hs.variable]: "colors.gray.700",
    [_E.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: 1,
  borderRadius: "md",
  borderWidth: "1px",
  bg: Hs.reference,
  boxShadow: _E.reference
}, nI = {
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [Hs.variable]: "colors.gray.100",
    _dark: {
      [Hs.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [Hs.variable]: "colors.gray.200",
    _dark: {
      [Hs.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [Hs.variable]: "colors.gray.100",
    _dark: {
      [Hs.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: Hs.reference
}, rI = {
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
}, aI = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0
}, iI = {
  opacity: 0.6
}, oI = {
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
}, sI = {
  transitionProperty: "common",
  transitionDuration: "normal"
}, lI = eI({
  button: sI,
  list: tI,
  item: nI,
  groupTitle: rI,
  icon: aI,
  command: iI,
  divider: oI
}), uI = J8({
  baseStyle: lI
}), { defineMultiStyleConfig: cI, definePartsStyle: gw } = An(JB.keys), DE = et("modal-bg"), AE = et("modal-shadow"), fI = {
  bg: "blackAlpha.600",
  zIndex: "modal"
}, dI = (n) => {
  const { isCentered: a, scrollBehavior: s } = n;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: a ? "center" : "flex-start",
    overflow: s === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
}, pI = (n) => {
  const { isCentered: a, scrollBehavior: s } = n;
  return {
    borderRadius: "md",
    color: "inherit",
    my: a ? "auto" : "16",
    mx: a ? "auto" : void 0,
    zIndex: "modal",
    maxH: s === "inside" ? "calc(100% - 7.5rem)" : void 0,
    [DE.variable]: "colors.white",
    [AE.variable]: "shadows.lg",
    _dark: {
      [DE.variable]: "colors.gray.700",
      [AE.variable]: "shadows.dark-lg"
    },
    bg: DE.reference,
    boxShadow: AE.reference
  };
}, hI = {
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
}, mI = {
  position: "absolute",
  top: "2",
  insetEnd: "3"
}, vI = (n) => {
  const { scrollBehavior: a } = n;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: a === "inside" ? "auto" : void 0
  };
}, yI = {
  px: "6",
  py: "4"
}, gI = gw((n) => ({
  overlay: fI,
  dialogContainer: oi(dI, n),
  dialog: oi(pI, n),
  header: hI,
  closeButton: mI,
  body: oi(vI, n),
  footer: yI
}));
function ts(n) {
  return gw(n === "full" ? {
    dialog: {
      maxW: "100vw",
      minH: "$100vh",
      my: "0",
      borderRadius: "0"
    }
  } : {
    dialog: { maxW: n }
  });
}
var bI = {
  xs: ts("xs"),
  sm: ts("sm"),
  md: ts("md"),
  lg: ts("lg"),
  xl: ts("xl"),
  "2xl": ts("2xl"),
  "3xl": ts("3xl"),
  "4xl": ts("4xl"),
  "5xl": ts("5xl"),
  "6xl": ts("6xl"),
  full: ts("full")
}, SI = cI({
  baseStyle: gI,
  sizes: bI,
  defaultProps: { size: "md" }
}), { defineMultiStyleConfig: xI, definePartsStyle: SO } = An(e6.keys), iT = jr("number-input-stepper-width"), xO = jr("number-input-input-padding"), CI = Gl(iT).add("0.5rem").toString(), ME = jr("number-input-bg"), OE = jr("number-input-color"), zE = jr("number-input-border-color"), EI = {
  [iT.variable]: "sizes.6",
  [xO.variable]: CI
}, wI = (n) => {
  var a, s;
  return (s = (a = oi(nn.baseStyle, n)) == null ? void 0 : a.field) != null ? s : {};
}, TI = {
  width: iT.reference
}, kI = {
  borderStart: "1px solid",
  borderStartColor: zE.reference,
  color: OE.reference,
  bg: ME.reference,
  [OE.variable]: "colors.chakra-body-text",
  [zE.variable]: "colors.chakra-border-color",
  _dark: {
    [OE.variable]: "colors.whiteAlpha.800",
    [zE.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [ME.variable]: "colors.gray.200",
    _dark: {
      [ME.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
}, RI = SO((n) => {
  var a;
  return {
    root: EI,
    field: (a = oi(wI, n)) != null ? a : {},
    stepperGroup: TI,
    stepper: kI
  };
});
function Cb(n) {
  var a, s, c;
  const p = (a = nn.sizes) == null ? void 0 : a[n], v = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  }, h = (c = (s = p.field) == null ? void 0 : s.fontSize) != null ? c : "md", b = pO.fontSizes[h];
  return SO({
    field: {
      ...p.field,
      paddingInlineEnd: xO.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: Gl(b).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: v[n]
      },
      _last: {
        borderBottomEndRadius: v[n],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
var _I = {
  xs: Cb("xs"),
  sm: Cb("sm"),
  md: Cb("md"),
  lg: Cb("lg")
}, DI = xI({
  baseStyle: RI,
  sizes: _I,
  variants: nn.variants,
  defaultProps: nn.defaultProps
}), U2, AI = {
  ...(U2 = nn.baseStyle) == null ? void 0 : U2.field,
  textAlign: "center"
}, MI = {
  lg: {
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  },
  md: {
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  },
  sm: {
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  },
  xs: {
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  }
}, I2, H2, OI = {
  outline: (n) => {
    var a, s, c;
    return (c = (s = oi((a = nn.variants) == null ? void 0 : a.outline, n)) == null ? void 0 : s.field) != null ? c : {};
  },
  flushed: (n) => {
    var a, s, c;
    return (c = (s = oi((a = nn.variants) == null ? void 0 : a.flushed, n)) == null ? void 0 : s.field) != null ? c : {};
  },
  filled: (n) => {
    var a, s, c;
    return (c = (s = oi((a = nn.variants) == null ? void 0 : a.filled, n)) == null ? void 0 : s.field) != null ? c : {};
  },
  unstyled: (H2 = (I2 = nn.variants) == null ? void 0 : I2.unstyled.field) != null ? H2 : {}
}, zI = {
  baseStyle: AI,
  sizes: MI,
  variants: OI,
  defaultProps: nn.defaultProps
}, { defineMultiStyleConfig: PI, definePartsStyle: LI } = An(t6.keys), Eb = jr("popper-bg"), $I = jr("popper-arrow-bg"), W2 = jr("popper-arrow-shadow-color"), NI = { zIndex: 10 }, FI = {
  [Eb.variable]: "colors.white",
  bg: Eb.reference,
  [$I.variable]: Eb.reference,
  [W2.variable]: "colors.gray.200",
  _dark: {
    [Eb.variable]: "colors.gray.700",
    [W2.variable]: "colors.whiteAlpha.300"
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
}, VI = {
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
}, jI = {
  px: 3,
  py: 2
}, BI = {
  px: 3,
  py: 2,
  borderTopWidth: "1px"
}, UI = {
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
}, II = LI({
  popper: NI,
  content: FI,
  header: VI,
  body: jI,
  footer: BI,
  closeButton: UI
}), HI = PI({
  baseStyle: II
}), { definePartsStyle: bw, defineMultiStyleConfig: WI } = An(YB.keys), PE = et("drawer-bg"), LE = et("drawer-box-shadow");
function $p(n) {
  return bw(n === "full" ? {
    dialog: { maxW: "100vw", h: "100vh" }
  } : {
    dialog: { maxW: n }
  });
}
var YI = {
  bg: "blackAlpha.600",
  zIndex: "modal"
}, GI = {
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
}, qI = (n) => {
  const { isFullHeight: a } = n;
  return {
    ...a && { height: "100vh" },
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [PE.variable]: "colors.white",
    [LE.variable]: "shadows.lg",
    _dark: {
      [PE.variable]: "colors.gray.700",
      [LE.variable]: "shadows.dark-lg"
    },
    bg: PE.reference,
    boxShadow: LE.reference
  };
}, QI = {
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
}, KI = {
  position: "absolute",
  top: "2",
  insetEnd: "3"
}, XI = {
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
}, ZI = {
  px: "6",
  py: "4"
}, JI = bw((n) => ({
  overlay: YI,
  dialogContainer: GI,
  dialog: oi(qI, n),
  header: QI,
  closeButton: KI,
  body: XI,
  footer: ZI
})), e9 = {
  xs: $p("xs"),
  sm: $p("md"),
  md: $p("lg"),
  lg: $p("2xl"),
  xl: $p("4xl"),
  full: $p("full")
}, t9 = WI({
  baseStyle: JI,
  sizes: e9,
  defaultProps: {
    size: "xs"
  }
}), { definePartsStyle: n9, defineMultiStyleConfig: r9 } = An(GB.keys), a9 = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
}, i9 = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, o9 = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, s9 = n9({
  preview: a9,
  input: i9,
  textarea: o9
}), l9 = r9({
  baseStyle: s9
}), { definePartsStyle: u9, defineMultiStyleConfig: c9 } = An(qB.keys), Qp = et("form-control-color"), f9 = {
  marginStart: "1",
  [Qp.variable]: "colors.red.500",
  _dark: {
    [Qp.variable]: "colors.red.300"
  },
  color: Qp.reference
}, d9 = {
  mt: "2",
  [Qp.variable]: "colors.gray.600",
  _dark: {
    [Qp.variable]: "colors.whiteAlpha.600"
  },
  color: Qp.reference,
  lineHeight: "normal",
  fontSize: "sm"
}, p9 = u9({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: f9,
  helperText: d9
}), h9 = c9({
  baseStyle: p9
}), { definePartsStyle: m9, defineMultiStyleConfig: v9 } = An(QB.keys), Kp = et("form-error-color"), y9 = {
  [Kp.variable]: "colors.red.500",
  _dark: {
    [Kp.variable]: "colors.red.300"
  },
  color: Kp.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
}, g9 = {
  marginEnd: "0.5em",
  [Kp.variable]: "colors.red.500",
  _dark: {
    [Kp.variable]: "colors.red.300"
  },
  color: Kp.reference
}, b9 = m9({
  text: y9,
  icon: g9
}), S9 = v9({
  baseStyle: b9
}), x9 = {
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
}, C9 = {
  baseStyle: x9
}, E9 = {
  fontFamily: "heading",
  fontWeight: "bold"
}, w9 = {
  "4xl": {
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  },
  "3xl": {
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  },
  "2xl": {
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  },
  xl: {
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  },
  lg: {
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  },
  md: {
    fontSize: "xl",
    lineHeight: 1.2
  },
  sm: {
    fontSize: "md",
    lineHeight: 1.2
  },
  xs: {
    fontSize: "sm",
    lineHeight: 1.2
  }
}, T9 = {
  baseStyle: E9,
  sizes: w9,
  defaultProps: {
    size: "xl"
  }
}, { defineMultiStyleConfig: k9, definePartsStyle: R9 } = An(HB.keys), $E = et("breadcrumb-link-decor"), _9 = {
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  outline: "none",
  color: "inherit",
  textDecoration: $E.reference,
  [$E.variable]: "none",
  "&:not([aria-current=page])": {
    cursor: "pointer",
    _hover: {
      [$E.variable]: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
}, D9 = R9({
  link: _9
}), A9 = k9({
  baseStyle: D9
}), M9 = {
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
}, CO = (n) => {
  const { colorScheme: a, theme: s } = n;
  if (a === "gray")
    return {
      color: Je("gray.800", "whiteAlpha.900")(n),
      _hover: {
        bg: Je("gray.100", "whiteAlpha.200")(n)
      },
      _active: { bg: Je("gray.200", "whiteAlpha.300")(n) }
    };
  const c = sh(`${a}.200`, 0.12)(s), p = sh(`${a}.200`, 0.24)(s);
  return {
    color: Je(`${a}.600`, `${a}.200`)(n),
    bg: "transparent",
    _hover: {
      bg: Je(`${a}.50`, c)(n)
    },
    _active: {
      bg: Je(`${a}.100`, p)(n)
    }
  };
}, O9 = (n) => {
  const { colorScheme: a } = n, s = Je("gray.200", "whiteAlpha.300")(n);
  return {
    border: "1px solid",
    borderColor: a === "gray" ? s : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
    ...oi(CO, n)
  };
}, z9 = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
}, P9 = (n) => {
  var a;
  const { colorScheme: s } = n;
  if (s === "gray") {
    const x = Je("gray.100", "whiteAlpha.200")(n);
    return {
      bg: x,
      color: Je("gray.800", "whiteAlpha.900")(n),
      _hover: {
        bg: Je("gray.200", "whiteAlpha.300")(n),
        _disabled: {
          bg: x
        }
      },
      _active: { bg: Je("gray.300", "whiteAlpha.400")(n) }
    };
  }
  const {
    bg: c = `${s}.500`,
    color: p = "white",
    hoverBg: v = `${s}.600`,
    activeBg: h = `${s}.700`
  } = (a = z9[s]) != null ? a : {}, b = Je(c, `${s}.200`)(n);
  return {
    bg: b,
    color: Je(p, "gray.800")(n),
    _hover: {
      bg: Je(v, `${s}.300`)(n),
      _disabled: {
        bg: b
      }
    },
    _active: { bg: Je(h, `${s}.400`)(n) }
  };
}, L9 = (n) => {
  const { colorScheme: a } = n;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: Je(`${a}.500`, `${a}.200`)(n),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: Je(`${a}.700`, `${a}.500`)(n)
    }
  };
}, $9 = {
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
}, N9 = {
  ghost: CO,
  outline: O9,
  solid: P9,
  link: L9,
  unstyled: $9
}, F9 = {
  lg: {
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  },
  md: {
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  },
  sm: {
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  },
  xs: {
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  }
}, V9 = {
  baseStyle: M9,
  variants: N9,
  sizes: F9,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
}, { definePartsStyle: Ff, defineMultiStyleConfig: j9 } = An(f6.keys), oS = et("card-bg"), Kl = et("card-padding"), EO = et("card-shadow"), Wb = et("card-radius"), wO = et("card-border-width", "0"), TO = et("card-border-color"), B9 = Ff({
  container: {
    [oS.variable]: "colors.chakra-body-bg",
    backgroundColor: oS.reference,
    boxShadow: EO.reference,
    borderRadius: Wb.reference,
    color: "chakra-body-text",
    borderWidth: wO.reference,
    borderColor: TO.reference
  },
  body: {
    padding: Kl.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: Kl.reference
  },
  footer: {
    padding: Kl.reference
  }
}), U9 = {
  sm: Ff({
    container: {
      [Wb.variable]: "radii.base",
      [Kl.variable]: "space.3"
    }
  }),
  md: Ff({
    container: {
      [Wb.variable]: "radii.md",
      [Kl.variable]: "space.5"
    }
  }),
  lg: Ff({
    container: {
      [Wb.variable]: "radii.xl",
      [Kl.variable]: "space.7"
    }
  })
}, I9 = {
  elevated: Ff({
    container: {
      [EO.variable]: "shadows.base",
      _dark: {
        [oS.variable]: "colors.gray.700"
      }
    }
  }),
  outline: Ff({
    container: {
      [wO.variable]: "1px",
      [TO.variable]: "colors.chakra-border-color"
    }
  }),
  filled: Ff({
    container: {
      [oS.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      [Kl.variable]: 0
    },
    header: {
      [Kl.variable]: 0
    },
    footer: {
      [Kl.variable]: 0
    }
  }
}, H9 = j9({
  baseStyle: B9,
  variants: I9,
  sizes: U9,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
}), Yv = jr("close-button-size"), Av = jr("close-button-bg"), W9 = {
  w: [Yv.reference],
  h: [Yv.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [Av.variable]: "colors.blackAlpha.100",
    _dark: {
      [Av.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [Av.variable]: "colors.blackAlpha.200",
    _dark: {
      [Av.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: Av.reference
}, Y9 = {
  lg: {
    [Yv.variable]: "sizes.10",
    fontSize: "md"
  },
  md: {
    [Yv.variable]: "sizes.8",
    fontSize: "xs"
  },
  sm: {
    [Yv.variable]: "sizes.6",
    fontSize: "2xs"
  }
}, G9 = {
  baseStyle: W9,
  sizes: Y9,
  defaultProps: {
    size: "md"
  }
}, { variants: q9, defaultProps: Q9 } = Hv, K9 = {
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm",
  bg: dr.bg.reference,
  color: dr.color.reference,
  boxShadow: dr.shadow.reference
}, X9 = {
  baseStyle: K9,
  variants: q9,
  defaultProps: Q9
}, Z9 = {
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
}, J9 = {
  baseStyle: Z9
}, eH = {
  opacity: 0.6,
  borderColor: "inherit"
}, tH = {
  borderStyle: "solid"
}, nH = {
  borderStyle: "dashed"
}, rH = {
  solid: tH,
  dashed: nH
}, aH = {
  baseStyle: eH,
  variants: rH,
  defaultProps: {
    variant: "solid"
  }
}, { definePartsStyle: iH, defineMultiStyleConfig: oH } = An(BB.keys), sH = {
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
}, lH = {
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
}, uH = {
  pt: "2",
  px: "4",
  pb: "5"
}, cH = {
  fontSize: "1.25em"
}, fH = iH({
  container: sH,
  button: lH,
  panel: uH,
  icon: cH
}), dH = oH({ baseStyle: fH }), { definePartsStyle: dy, defineMultiStyleConfig: pH } = An(UB.keys), Gi = et("alert-fg"), Jl = et("alert-bg"), hH = dy({
  container: {
    bg: Jl.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: Gi.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: Gi.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function oT(n) {
  const { theme: a, colorScheme: s } = n, c = sh(`${s}.200`, 0.16)(a);
  return {
    light: `colors.${s}.100`,
    dark: c
  };
}
var mH = dy((n) => {
  const { colorScheme: a } = n, s = oT(n);
  return {
    container: {
      [Gi.variable]: `colors.${a}.600`,
      [Jl.variable]: s.light,
      _dark: {
        [Gi.variable]: `colors.${a}.200`,
        [Jl.variable]: s.dark
      }
    }
  };
}), vH = dy((n) => {
  const { colorScheme: a } = n, s = oT(n);
  return {
    container: {
      [Gi.variable]: `colors.${a}.600`,
      [Jl.variable]: s.light,
      _dark: {
        [Gi.variable]: `colors.${a}.200`,
        [Jl.variable]: s.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: Gi.reference
    }
  };
}), yH = dy((n) => {
  const { colorScheme: a } = n, s = oT(n);
  return {
    container: {
      [Gi.variable]: `colors.${a}.600`,
      [Jl.variable]: s.light,
      _dark: {
        [Gi.variable]: `colors.${a}.200`,
        [Jl.variable]: s.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: Gi.reference
    }
  };
}), gH = dy((n) => {
  const { colorScheme: a } = n;
  return {
    container: {
      [Gi.variable]: "colors.white",
      [Jl.variable]: `colors.${a}.600`,
      _dark: {
        [Gi.variable]: "colors.gray.900",
        [Jl.variable]: `colors.${a}.200`
      },
      color: Gi.reference
    }
  };
}), bH = {
  subtle: mH,
  "left-accent": vH,
  "top-accent": yH,
  solid: gH
}, SH = pH({
  baseStyle: hH,
  variants: bH,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
}), { definePartsStyle: kO, defineMultiStyleConfig: xH } = An(IB.keys), Xp = et("avatar-border-color"), Gv = et("avatar-bg"), iy = et("avatar-font-size"), lh = et("avatar-size"), CH = {
  borderRadius: "full",
  border: "0.2em solid",
  borderColor: Xp.reference,
  [Xp.variable]: "white",
  _dark: {
    [Xp.variable]: "colors.gray.800"
  }
}, EH = {
  bg: Gv.reference,
  fontSize: iy.reference,
  width: lh.reference,
  height: lh.reference,
  lineHeight: "1",
  [Gv.variable]: "colors.gray.200",
  _dark: {
    [Gv.variable]: "colors.whiteAlpha.400"
  }
}, wH = (n) => {
  const { name: a, theme: s } = n, c = a ? M6({ string: a }) : "colors.gray.400", p = D6(c)(s);
  let v = "white";
  return p || (v = "gray.800"), {
    bg: Gv.reference,
    fontSize: iy.reference,
    color: v,
    borderColor: Xp.reference,
    verticalAlign: "top",
    width: lh.reference,
    height: lh.reference,
    "&:not([data-loaded])": {
      [Gv.variable]: c
    },
    [Xp.variable]: "colors.white",
    _dark: {
      [Xp.variable]: "colors.gray.800"
    }
  };
}, TH = {
  fontSize: iy.reference,
  lineHeight: "1"
}, kH = kO((n) => ({
  badge: oi(CH, n),
  excessLabel: oi(EH, n),
  container: oi(wH, n),
  label: TH
}));
function ic(n) {
  const a = n !== "100%" ? mO[n] : void 0;
  return kO({
    container: {
      [lh.variable]: a ?? n,
      [iy.variable]: `calc(${a ?? n} / 2.5)`
    },
    excessLabel: {
      [lh.variable]: a ?? n,
      [iy.variable]: `calc(${a ?? n} / 2.5)`
    }
  });
}
var RH = {
  "2xs": ic(4),
  xs: ic(6),
  sm: ic(8),
  md: ic(12),
  lg: ic(16),
  xl: ic(24),
  "2xl": ic(32),
  full: ic("100%")
}, _H = xH({
  baseStyle: kH,
  sizes: RH,
  defaultProps: {
    size: "md"
  }
}), DH = {
  Accordion: dH,
  Alert: SH,
  Avatar: _H,
  Badge: Hv,
  Breadcrumb: A9,
  Button: V9,
  Checkbox: iS,
  CloseButton: G9,
  Code: X9,
  Container: J9,
  Divider: aH,
  Drawer: t9,
  Editable: l9,
  Form: h9,
  FormError: S9,
  FormLabel: C9,
  Heading: T9,
  Input: nn,
  Kbd: W8,
  Link: G8,
  List: Z8,
  Menu: uI,
  Modal: SI,
  NumberInput: DI,
  PinInput: zI,
  Popover: HI,
  Progress: XU,
  Radio: c8,
  Select: y8,
  Skeleton: b8,
  SkipLink: x8,
  Slider: O8,
  Spinner: L8,
  Stat: I8,
  Switch: G6,
  Table: eU,
  Tabs: mU,
  Tag: _U,
  Textarea: jU,
  Tooltip: IU,
  Card: H9,
  Stepper: jB
}, RO = {
  colors: {
    "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
    "chakra-body-bg": { _light: "white", _dark: "gray.800" },
    "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
    "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
    "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
    "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
    "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
  }
}, _O = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color"
    }
  }
}, DO = "ltr", AO = {
  useSystemColorMode: !1,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
}, AH = {
  semanticTokens: RO,
  direction: DO,
  ...vO,
  components: DH,
  styles: _O,
  config: AO
}, MH = {
  semanticTokens: RO,
  direction: DO,
  components: {},
  ...vO,
  styles: _O,
  config: AO
};
function Vv(n) {
  return typeof n == "function";
}
function OH(...n) {
  return (a) => n.reduce((s, c) => c(s), a);
}
var zH = (n) => function(...s) {
  let c = [...s], p = s[s.length - 1];
  return hB(p) && // this ensures backward compatibility
  // previously only `extendTheme(override, activeTheme?)` was allowed
  c.length > 1 ? c = c.slice(0, c.length - 1) : p = n, OH(
    ...c.map(
      (v) => (h) => Vv(v) ? v(h) : LH(h, v)
    )
  )(p);
}, PH = zH(MH);
function LH(...n) {
  return bo({}, ...n, MO);
}
function MO(n, a, s, c) {
  if ((Vv(n) || Vv(a)) && Object.prototype.hasOwnProperty.call(c, s))
    return (...p) => {
      const v = Vv(n) ? n(...p) : n, h = Vv(a) ? a(...p) : a;
      return bo({}, v, h, MO);
    };
}
function $H(n, a) {
  const s = {};
  return Object.keys(n).forEach((c) => {
    a.includes(c) || (s[c] = n[c]);
  }), s;
}
function NH(n, a, s, c) {
  const p = typeof a == "string" ? a.split(".") : [a];
  for (c = 0; c < p.length && n; c += 1)
    n = n[p[c]];
  return n === void 0 ? s : n;
}
var FH = (n) => {
  const a = /* @__PURE__ */ new WeakMap();
  return (c, p, v, h) => {
    if (typeof c > "u")
      return n(c, p, v);
    a.has(c) || a.set(c, /* @__PURE__ */ new Map());
    const b = a.get(c);
    if (b.has(p))
      return b.get(p);
    const x = n(c, p, v, h);
    return b.set(p, x), x;
  };
}, OO = FH(NH);
function zO(n, a) {
  const s = {};
  return Object.keys(n).forEach((c) => {
    const p = n[c];
    a(p, c, n) && (s[c] = p);
  }), s;
}
var PO = (n) => zO(n, (a) => a != null);
function VH(n) {
  return typeof n == "function";
}
process.env.NODE_ENV;
process.env.NODE_ENV;
function LO(n, ...a) {
  return VH(n) ? n(...a) : n;
}
var jH = typeof Element < "u", BH = typeof Map == "function", UH = typeof Set == "function", IH = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function Yb(n, a) {
  if (n === a)
    return !0;
  if (n && a && typeof n == "object" && typeof a == "object") {
    if (n.constructor !== a.constructor)
      return !1;
    var s, c, p;
    if (Array.isArray(n)) {
      if (s = n.length, s != a.length)
        return !1;
      for (c = s; c-- !== 0; )
        if (!Yb(n[c], a[c]))
          return !1;
      return !0;
    }
    var v;
    if (BH && n instanceof Map && a instanceof Map) {
      if (n.size !== a.size)
        return !1;
      for (v = n.entries(); !(c = v.next()).done; )
        if (!a.has(c.value[0]))
          return !1;
      for (v = n.entries(); !(c = v.next()).done; )
        if (!Yb(c.value[1], a.get(c.value[0])))
          return !1;
      return !0;
    }
    if (UH && n instanceof Set && a instanceof Set) {
      if (n.size !== a.size)
        return !1;
      for (v = n.entries(); !(c = v.next()).done; )
        if (!a.has(c.value[0]))
          return !1;
      return !0;
    }
    if (IH && ArrayBuffer.isView(n) && ArrayBuffer.isView(a)) {
      if (s = n.length, s != a.length)
        return !1;
      for (c = s; c-- !== 0; )
        if (n[c] !== a[c])
          return !1;
      return !0;
    }
    if (n.constructor === RegExp)
      return n.source === a.source && n.flags === a.flags;
    if (n.valueOf !== Object.prototype.valueOf && typeof n.valueOf == "function" && typeof a.valueOf == "function")
      return n.valueOf() === a.valueOf();
    if (n.toString !== Object.prototype.toString && typeof n.toString == "function" && typeof a.toString == "function")
      return n.toString() === a.toString();
    if (p = Object.keys(n), s = p.length, s !== Object.keys(a).length)
      return !1;
    for (c = s; c-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(a, p[c]))
        return !1;
    if (jH && n instanceof Element)
      return !1;
    for (c = s; c-- !== 0; )
      if (!((p[c] === "_owner" || p[c] === "__v" || p[c] === "__o") && n.$$typeof) && !Yb(n[p[c]], a[p[c]]))
        return !1;
    return !0;
  }
  return n !== n && a !== a;
}
var HH = function(a, s) {
  try {
    return Yb(a, s);
  } catch (c) {
    if ((c.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw c;
  }
};
const WH = /* @__PURE__ */ cM(HH);
function $O(n, a = {}) {
  var s;
  const { styleConfig: c, ...p } = a, { theme: v, colorMode: h } = KV(), b = n ? OO(v, `components.${n}`) : void 0, x = c || b, E = bo(
    { theme: v, colorMode: h },
    (s = x == null ? void 0 : x.defaultProps) != null ? s : {},
    PO($H(p, ["children"]))
  ), w = ga({});
  if (x) {
    const _ = dB(x)(E);
    WH(w.current, _) || (w.current = _);
  }
  return w.current;
}
function sT(n, a = {}) {
  return $O(n, a);
}
function YH(n, a = {}) {
  return $O(n, a);
}
var GH = /* @__PURE__ */ new Set([
  ...eB,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]), qH = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function QH(n) {
  return qH.has(n) || !GH.has(n);
}
function KH(n, ...a) {
  if (n == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const s = { ...n };
  for (const c of a)
    if (c != null)
      for (const p in c)
        Object.prototype.hasOwnProperty.call(c, p) && (p in s && delete s[p], s[p] = c[p]);
  return s;
}
var XH = dM, ZH = function(a) {
  return a !== "theme";
}, Y2 = function(a) {
  return typeof a == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  a.charCodeAt(0) > 96 ? XH : ZH;
}, G2 = function(a, s, c) {
  var p;
  if (s) {
    var v = s.shouldForwardProp;
    p = a.__emotion_forwardProp && v ? function(h) {
      return a.__emotion_forwardProp(h) && v(h);
    } : v;
  }
  return typeof p != "function" && c && (p = a.__emotion_forwardProp), p;
}, q2 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, JH = function(a) {
  var s = a.cache, c = a.serialized, p = a.isStringTag;
  return TS(s, c, p), Gw(function() {
    return kS(s, c, p);
  }), null;
}, e7 = function n(a, s) {
  if (process.env.NODE_ENV !== "production" && a === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var c = a.__emotion_real === a, p = c && a.__emotion_base || a, v, h;
  s !== void 0 && (v = s.label, h = s.target);
  var b = G2(a, s, c), x = b || Y2(p), E = !x("as");
  return function() {
    var w = arguments, k = c && a.__emotion_styles !== void 0 ? a.__emotion_styles.slice(0) : [];
    if (v !== void 0 && k.push("label:" + v + ";"), w[0] == null || w[0].raw === void 0)
      k.push.apply(k, w);
    else {
      process.env.NODE_ENV !== "production" && w[0][0] === void 0 && console.error(q2), k.push(w[0][0]);
      for (var _ = w.length, A = 1; A < _; A++)
        process.env.NODE_ENV !== "production" && w[0][A] === void 0 && console.error(q2), k.push(w[A], w[0][A]);
    }
    var L = RS(function($, Y, K) {
      var W = E && $.as || p, F = "", ne = [], H = $;
      if ($.theme == null) {
        H = {};
        for (var le in $)
          H[le] = $[le];
        H.theme = kt.useContext(pc);
      }
      typeof $.className == "string" ? F = Ww(Y.registered, ne, $.className) : $.className != null && (F = $.className + " ");
      var re = oh(k.concat(ne), Y.registered, H);
      F += Y.key + "-" + re.name, h !== void 0 && (F += " " + h);
      var De = E && b === void 0 ? Y2(W) : x, Fe = {};
      for (var ot in $)
        E && ot === "as" || // $FlowFixMe
        De(ot) && (Fe[ot] = $[ot]);
      return Fe.className = F, Fe.ref = K, /* @__PURE__ */ kt.createElement(kt.Fragment, null, /* @__PURE__ */ kt.createElement(JH, {
        cache: Y,
        serialized: re,
        isStringTag: typeof W == "string"
      }), /* @__PURE__ */ kt.createElement(W, Fe));
    });
    return L.displayName = v !== void 0 ? v : "Styled(" + (typeof p == "string" ? p : p.displayName || p.name || "Component") + ")", L.defaultProps = a.defaultProps, L.__emotion_real = L, L.__emotion_base = p, L.__emotion_styles = k, L.__emotion_forwardProp = b, Object.defineProperty(L, "toString", {
      value: function() {
        return h === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + h;
      }
    }), L.withComponent = function($, Y) {
      return n($, Jb({}, s, Y, {
        shouldForwardProp: G2(L, Y, !0)
      })).apply(void 0, k);
    }, L;
  };
}, t7 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], sS = e7.bind();
t7.forEach(function(n) {
  sS[n] = sS(n);
});
var Q2, n7 = (Q2 = sS.default) != null ? Q2 : sS, r7 = ({ baseStyle: n }) => (a) => {
  const { theme: s, css: c, __css: p, sx: v, ...h } = a, b = zO(h, (k, _) => nB(_)), x = LO(n, a), E = KH(
    {},
    p,
    x,
    PO(b),
    v
  ), w = dO(E)(a.theme);
  return c ? [w, c] : w;
};
function NE(n, a) {
  const { baseStyle: s, ...c } = a ?? {};
  c.shouldForwardProp || (c.shouldForwardProp = QH);
  const p = r7({ baseStyle: s }), v = n7(
    n,
    c
  )(p);
  return qi.forwardRef(function(x, E) {
    const { colorMode: w, forced: k } = Xw();
    return qi.createElement(v, {
      ref: E,
      "data-theme": k ? w : void 0,
      ...x
    });
  });
}
function a7() {
  const n = /* @__PURE__ */ new Map();
  return new Proxy(NE, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(a, s, c) {
      return NE(...c);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(a, s) {
      return n.has(s) || n.set(s, NE(s)), n.get(s);
    }
  });
}
var os = a7();
function mh(n) {
  return zw(n);
}
function i7(n = {}) {
  const {
    strict: a = !0,
    errorMessage: s = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name: c
  } = n, p = Ks(void 0);
  p.displayName = c;
  function v() {
    var h;
    const b = ar(p);
    if (!b && a) {
      const x = new Error(s);
      throw x.name = "ContextError", (h = Error.captureStackTrace) == null || h.call(Error, x, v), x;
    }
    return b;
  }
  return [
    p.Provider,
    v,
    p
  ];
}
function o7(n) {
  const { cssVarsRoot: a, theme: s, children: c } = n, p = Ki(() => Jj(s), [s]);
  return /* @__PURE__ */ Oe.jsxs(vV, { theme: p, children: [
    /* @__PURE__ */ Oe.jsx(s7, { root: a }),
    c
  ] });
}
function s7({ root: n = ":host, :root" }) {
  const a = [n, "[data-theme]"].join(",");
  return /* @__PURE__ */ Oe.jsx(cy, { styles: (s) => ({ [a]: s.__cssVars }) });
}
i7({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function l7() {
  const { colorMode: n } = Xw();
  return /* @__PURE__ */ Oe.jsx(
    cy,
    {
      styles: (a) => {
        const s = OO(a, "styles.global"), c = LO(s, { theme: a, colorMode: n });
        return c ? dO(c)(a) : void 0;
      }
    }
  );
}
var NO = Ks({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
NO.displayName = "EnvironmentContext";
function FO(n) {
  const { children: a, environment: s, disabled: c } = n, p = ga(null), v = Ki(() => s || {
    getDocument: () => {
      var b, x;
      return (x = (b = p.current) == null ? void 0 : b.ownerDocument) != null ? x : document;
    },
    getWindow: () => {
      var b, x;
      return (x = (b = p.current) == null ? void 0 : b.ownerDocument.defaultView) != null ? x : window;
    }
  }, [s]), h = !c || !s;
  return /* @__PURE__ */ Oe.jsxs(NO.Provider, { value: v, children: [
    a,
    h && /* @__PURE__ */ Oe.jsx("span", { id: "__chakra_env", hidden: !0, ref: p })
  ] });
}
FO.displayName = "EnvironmentProvider";
var u7 = (n) => {
  const {
    children: a,
    colorModeManager: s,
    portalZIndex: c,
    resetScope: p,
    resetCSS: v = !0,
    theme: h = {},
    environment: b,
    cssVarsRoot: x,
    disableEnvironment: E,
    disableGlobalStyle: w
  } = n, k = /* @__PURE__ */ Oe.jsx(
    FO,
    {
      environment: b,
      disabled: E,
      children: a
    }
  );
  return /* @__PURE__ */ Oe.jsx(o7, { theme: h, cssVarsRoot: x, children: /* @__PURE__ */ Oe.jsxs(
    iO,
    {
      colorModeManager: s,
      options: h.config,
      children: [
        v ? /* @__PURE__ */ Oe.jsx(OV, { scope: p }) : /* @__PURE__ */ Oe.jsx(MV, {}),
        !w && /* @__PURE__ */ Oe.jsx(l7, {}),
        c ? /* @__PURE__ */ Oe.jsx(eO, { zIndex: c, children: k }) : k
      ]
    }
  ) });
}, c7 = (n, a) => n.find((s) => s.id === a);
function K2(n, a) {
  const s = VO(n, a), c = s ? n[s].findIndex((p) => p.id === a) : -1;
  return {
    position: s,
    index: c
  };
}
function VO(n, a) {
  for (const [s, c] of Object.entries(n))
    if (c7(c, a))
      return s;
}
function f7(n) {
  const a = n.includes("right"), s = n.includes("left");
  let c = "center";
  return a && (c = "flex-end"), s && (c = "flex-start"), {
    display: "flex",
    flexDirection: "column",
    alignItems: c
  };
}
function d7(n) {
  const s = n === "top" || n === "bottom" ? "0 auto" : void 0, c = n.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0, p = n.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0, v = n.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)", h = n.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin: s,
    top: c,
    bottom: p,
    right: v,
    left: h
  };
}
function p7(n, a = []) {
  const s = ga(n);
  return Qi(() => {
    s.current = n;
  }), Zp((...c) => {
    var p;
    return (p = s.current) == null ? void 0 : p.call(s, ...c);
  }, a);
}
function h7(n, a) {
  const s = p7(n);
  Qi(() => {
    if (a == null)
      return;
    let c = null;
    return c = window.setTimeout(() => {
      s();
    }, a), () => {
      c && window.clearTimeout(c);
    };
  }, [a, s]);
}
function X2(n, a) {
  const s = ga(!1), c = ga(!1);
  Qi(() => {
    if (s.current && c.current)
      return n();
    c.current = !0;
  }, a), Qi(() => (s.current = !0, () => {
    s.current = !1;
  }), []);
}
const jO = Ks({
  transformPagePoint: (n) => n,
  isStatic: !1,
  reducedMotion: "never"
}), zS = Ks({}), py = Ks(null), PS = typeof document < "u", lT = PS ? lM : Qi, BO = Ks({ strict: !1 }), uT = (n) => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), m7 = "framerAppearId", UO = "data-" + uT(m7), IO = {
  skipAnimations: !1,
  useManualTiming: !1
};
class Z2 {
  constructor() {
    this.order = [], this.scheduled = /* @__PURE__ */ new Set();
  }
  add(a) {
    if (!this.scheduled.has(a))
      return this.scheduled.add(a), this.order.push(a), !0;
  }
  remove(a) {
    const s = this.order.indexOf(a);
    s !== -1 && (this.order.splice(s, 1), this.scheduled.delete(a));
  }
  clear() {
    this.order.length = 0, this.scheduled.clear();
  }
}
function v7(n) {
  let a = new Z2(), s = new Z2(), c = 0, p = !1, v = !1;
  const h = /* @__PURE__ */ new WeakSet(), b = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (x, E = !1, w = !1) => {
      const k = w && p, _ = k ? a : s;
      return E && h.add(x), _.add(x) && k && p && (c = a.order.length), x;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (x) => {
      s.remove(x), h.delete(x);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (x) => {
      if (p) {
        v = !0;
        return;
      }
      if (p = !0, [a, s] = [s, a], s.clear(), c = a.order.length, c)
        for (let E = 0; E < c; E++) {
          const w = a.order[E];
          h.has(w) && (b.schedule(w), n()), w(x);
        }
      p = !1, v && (v = !1, b.process(x));
    }
  };
  return b;
}
const wb = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], y7 = 40;
function HO(n, a) {
  let s = !1, c = !0;
  const p = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, v = wb.reduce((k, _) => (k[_] = v7(() => s = !0), k), {}), h = (k) => {
    v[k].process(p);
  }, b = () => {
    const k = performance.now();
    s = !1, p.delta = c ? 1e3 / 60 : Math.max(Math.min(k - p.timestamp, y7), 1), p.timestamp = k, p.isProcessing = !0, wb.forEach(h), p.isProcessing = !1, s && a && (c = !1, n(b));
  }, x = () => {
    s = !0, c = !0, p.isProcessing || n(b);
  };
  return { schedule: wb.reduce((k, _) => {
    const A = v[_];
    return k[_] = (L, $ = !1, Y = !1) => (s || x(), A.schedule(L, $, Y)), k;
  }, {}), cancel: (k) => wb.forEach((_) => v[_].cancel(k)), state: p, steps: v };
}
const { schedule: cT, cancel: oQ } = HO(queueMicrotask, !1);
function g7(n, a, s, c) {
  const { visualElement: p } = ar(zS), v = ar(BO), h = ar(py), b = ar(jO).reducedMotion, x = ga();
  c = c || v.renderer, !x.current && c && (x.current = c(n, {
    visualState: a,
    parent: p,
    props: s,
    presenceContext: h,
    blockInitialAnimation: h ? h.initial === !1 : !1,
    reducedMotionConfig: b
  }));
  const E = x.current;
  uM(() => {
    E && E.update(s, h);
  });
  const w = ga(!!(s[UO] && !window.HandoffComplete));
  return lT(() => {
    E && (cT.postRender(E.render), w.current && E.animationState && E.animationState.animateChanges());
  }), Qi(() => {
    E && (E.updateFeatures(), !w.current && E.animationState && E.animationState.animateChanges(), w.current && (w.current = !1, window.HandoffComplete = !0));
  }), E;
}
function Ip(n) {
  return n && typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current");
}
function b7(n, a, s) {
  return Zp(
    (c) => {
      c && n.mount && n.mount(c), a && (c ? a.mount(c) : a.unmount()), s && (typeof s == "function" ? s(c) : Ip(s) && (s.current = c));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [a]
  );
}
function oy(n) {
  return typeof n == "string" || Array.isArray(n);
}
function LS(n) {
  return n !== null && typeof n == "object" && typeof n.start == "function";
}
const fT = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], dT = ["initial", ...fT];
function $S(n) {
  return LS(n.animate) || dT.some((a) => oy(n[a]));
}
function WO(n) {
  return !!($S(n) || n.variants);
}
function S7(n, a) {
  if ($S(n)) {
    const { initial: s, animate: c } = n;
    return {
      initial: s === !1 || oy(s) ? s : void 0,
      animate: oy(c) ? c : void 0
    };
  }
  return n.inherit !== !1 ? a : {};
}
function x7(n) {
  const { initial: a, animate: s } = S7(n, ar(zS));
  return Ki(() => ({ initial: a, animate: s }), [J2(a), J2(s)]);
}
function J2(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const eA = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, sy = {};
for (const n in eA)
  sy[n] = {
    isEnabled: (a) => eA[n].some((s) => !!a[s])
  };
function C7(n) {
  for (const a in n)
    sy[a] = {
      ...sy[a],
      ...n[a]
    };
}
const pT = Ks({}), YO = Ks({}), E7 = Symbol.for("motionComponentSymbol");
function w7({ preloadedFeatures: n, createVisualElement: a, useRender: s, useVisualState: c, Component: p }) {
  n && C7(n);
  function v(b, x) {
    let E;
    const w = {
      ...ar(jO),
      ...b,
      layoutId: T7(b)
    }, { isStatic: k } = w, _ = x7(b), A = c(b, k);
    if (!k && PS) {
      _.visualElement = g7(p, A, w, a);
      const L = ar(YO), $ = ar(BO).strict;
      _.visualElement && (E = _.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        w,
        $,
        n,
        L
      ));
    }
    return kt.createElement(
      zS.Provider,
      { value: _ },
      E && _.visualElement ? kt.createElement(E, { visualElement: _.visualElement, ...w }) : null,
      s(p, b, b7(A, _.visualElement, x), A, k, _.visualElement)
    );
  }
  const h = zw(v);
  return h[E7] = p, h;
}
function T7({ layoutId: n }) {
  const a = ar(pT).id;
  return a && n !== void 0 ? a + "-" + n : n;
}
function k7(n) {
  function a(c, p = {}) {
    return w7(n(c, p));
  }
  if (typeof Proxy > "u")
    return a;
  const s = /* @__PURE__ */ new Map();
  return new Proxy(a, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (c, p) => (s.has(p) || s.set(p, a(p)), s.get(p))
  });
}
const R7 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function hT(n) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof n != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    n.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(R7.indexOf(n) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(n))
    )
  );
}
const lS = {};
function _7(n) {
  Object.assign(lS, n);
}
const hy = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Uf = new Set(hy);
function GO(n, { layout: a, layoutId: s }) {
  return Uf.has(n) || n.startsWith("origin") || (a || s !== void 0) && (!!lS[n] || n === "opacity");
}
const Oi = (n) => !!(n && n.getVelocity), D7 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, A7 = hy.length;
function M7(n, { enableHardwareAcceleration: a = !0, allowTransformNone: s = !0 }, c, p) {
  let v = "";
  for (let h = 0; h < A7; h++) {
    const b = hy[h];
    if (n[b] !== void 0) {
      const x = D7[b] || b;
      v += `${x}(${n[b]}) `;
    }
  }
  return a && !n.z && (v += "translateZ(0)"), v = v.trim(), p ? v = p(n, c ? "" : v) : s && c && (v = "none"), v;
}
const qO = (n) => (a) => typeof a == "string" && a.startsWith(n), QO = qO("--"), Sw = qO("var(--"), O7 = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, z7 = (n, a) => a && typeof n == "number" ? a.transform(n) : n, hc = (n, a, s) => Math.min(Math.max(s, n), a), If = {
  test: (n) => typeof n == "number",
  parse: parseFloat,
  transform: (n) => n
}, qv = {
  ...If,
  transform: (n) => hc(0, 1, n)
}, Tb = {
  ...If,
  default: 1
}, Qv = (n) => Math.round(n * 1e5) / 1e5, NS = /(-)?([\d]*\.?[\d])+/g, KO = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, P7 = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function my(n) {
  return typeof n == "string";
}
const vy = (n) => ({
  test: (a) => my(a) && a.endsWith(n) && a.split(" ").length === 1,
  parse: parseFloat,
  transform: (a) => `${a}${n}`
}), sc = vy("deg"), Qs = vy("%"), it = vy("px"), L7 = vy("vh"), $7 = vy("vw"), tA = {
  ...Qs,
  parse: (n) => Qs.parse(n) / 100,
  transform: (n) => Qs.transform(n * 100)
}, nA = {
  ...If,
  transform: Math.round
}, XO = {
  // Border props
  borderWidth: it,
  borderTopWidth: it,
  borderRightWidth: it,
  borderBottomWidth: it,
  borderLeftWidth: it,
  borderRadius: it,
  radius: it,
  borderTopLeftRadius: it,
  borderTopRightRadius: it,
  borderBottomRightRadius: it,
  borderBottomLeftRadius: it,
  // Positioning props
  width: it,
  maxWidth: it,
  height: it,
  maxHeight: it,
  size: it,
  top: it,
  right: it,
  bottom: it,
  left: it,
  // Spacing props
  padding: it,
  paddingTop: it,
  paddingRight: it,
  paddingBottom: it,
  paddingLeft: it,
  margin: it,
  marginTop: it,
  marginRight: it,
  marginBottom: it,
  marginLeft: it,
  // Transform props
  rotate: sc,
  rotateX: sc,
  rotateY: sc,
  rotateZ: sc,
  scale: Tb,
  scaleX: Tb,
  scaleY: Tb,
  scaleZ: Tb,
  skew: sc,
  skewX: sc,
  skewY: sc,
  distance: it,
  translateX: it,
  translateY: it,
  translateZ: it,
  x: it,
  y: it,
  z: it,
  perspective: it,
  transformPerspective: it,
  opacity: qv,
  originX: tA,
  originY: tA,
  originZ: it,
  // Misc
  zIndex: nA,
  // SVG
  fillOpacity: qv,
  strokeOpacity: qv,
  numOctaves: nA
};
function mT(n, a, s, c) {
  const { style: p, vars: v, transform: h, transformOrigin: b } = n;
  let x = !1, E = !1, w = !0;
  for (const k in a) {
    const _ = a[k];
    if (QO(k)) {
      v[k] = _;
      continue;
    }
    const A = XO[k], L = z7(_, A);
    if (Uf.has(k)) {
      if (x = !0, h[k] = L, !w)
        continue;
      _ !== (A.default || 0) && (w = !1);
    } else
      k.startsWith("origin") ? (E = !0, b[k] = L) : p[k] = L;
  }
  if (a.transform || (x || c ? p.transform = M7(n.transform, s, w, c) : p.transform && (p.transform = "none")), E) {
    const { originX: k = "50%", originY: _ = "50%", originZ: A = 0 } = b;
    p.transformOrigin = `${k} ${_} ${A}`;
  }
}
const vT = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function ZO(n, a, s) {
  for (const c in a)
    !Oi(a[c]) && !GO(c, s) && (n[c] = a[c]);
}
function N7({ transformTemplate: n }, a, s) {
  return Ki(() => {
    const c = vT();
    return mT(c, a, { enableHardwareAcceleration: !s }, n), Object.assign({}, c.vars, c.style);
  }, [a]);
}
function F7(n, a, s) {
  const c = n.style || {}, p = {};
  return ZO(p, c, n), Object.assign(p, N7(n, a, s)), p;
}
function V7(n, a, s) {
  const c = {}, p = F7(n, a, s);
  return n.drag && n.dragListener !== !1 && (c.draggable = !1, p.userSelect = p.WebkitUserSelect = p.WebkitTouchCallout = "none", p.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (c.tabIndex = 0), c.style = p, c;
}
const j7 = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function uS(n) {
  return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || n.startsWith("onLayout") || j7.has(n);
}
let JO = (n) => !uS(n);
function B7(n) {
  n && (JO = (a) => a.startsWith("on") ? !uS(a) : n(a));
}
try {
  B7(require("@emotion/is-prop-valid").default);
} catch {
}
function U7(n, a, s) {
  const c = {};
  for (const p in n)
    p === "values" && typeof n.values == "object" || (JO(p) || s === !0 && uS(p) || !a && !uS(p) || // If trying to use native HTML drag events, forward drag listeners
    n.draggable && p.startsWith("onDrag")) && (c[p] = n[p]);
  return c;
}
function rA(n, a, s) {
  return typeof n == "string" ? n : it.transform(a + s * n);
}
function I7(n, a, s) {
  const c = rA(a, n.x, n.width), p = rA(s, n.y, n.height);
  return `${c} ${p}`;
}
const H7 = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, W7 = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Y7(n, a, s = 1, c = 0, p = !0) {
  n.pathLength = 1;
  const v = p ? H7 : W7;
  n[v.offset] = it.transform(-c);
  const h = it.transform(a), b = it.transform(s);
  n[v.array] = `${h} ${b}`;
}
function yT(n, {
  attrX: a,
  attrY: s,
  attrScale: c,
  originX: p,
  originY: v,
  pathLength: h,
  pathSpacing: b = 1,
  pathOffset: x = 0,
  // This is object creation, which we try to avoid per-frame.
  ...E
}, w, k, _) {
  if (mT(n, E, w, _), k) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  n.attrs = n.style, n.style = {};
  const { attrs: A, style: L, dimensions: $ } = n;
  A.transform && ($ && (L.transform = A.transform), delete A.transform), $ && (p !== void 0 || v !== void 0 || L.transform) && (L.transformOrigin = I7($, p !== void 0 ? p : 0.5, v !== void 0 ? v : 0.5)), a !== void 0 && (A.x = a), s !== void 0 && (A.y = s), c !== void 0 && (A.scale = c), h !== void 0 && Y7(A, h, b, x, !1);
}
const ez = () => ({
  ...vT(),
  attrs: {}
}), gT = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function G7(n, a, s, c) {
  const p = Ki(() => {
    const v = ez();
    return yT(v, a, { enableHardwareAcceleration: !1 }, gT(c), n.transformTemplate), {
      ...v.attrs,
      style: { ...v.style }
    };
  }, [a]);
  if (n.style) {
    const v = {};
    ZO(v, n.style, n), p.style = { ...v, ...p.style };
  }
  return p;
}
function q7(n = !1) {
  return (s, c, p, { latestValues: v }, h) => {
    const x = (hT(s) ? G7 : V7)(c, v, h, s), w = {
      ...U7(c, typeof s == "string", n),
      ...x,
      ref: p
    }, { children: k } = c, _ = Ki(() => Oi(k) ? k.get() : k, [k]);
    return sM(s, {
      ...w,
      children: _
    });
  };
}
function tz(n, { style: a, vars: s }, c, p) {
  Object.assign(n.style, a, p && p.getProjectionStyles(c));
  for (const v in s)
    n.style.setProperty(v, s[v]);
}
const nz = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function rz(n, a, s, c) {
  tz(n, a, void 0, c);
  for (const p in a.attrs)
    n.setAttribute(nz.has(p) ? p : uT(p), a.attrs[p]);
}
function bT(n, a) {
  const { style: s } = n, c = {};
  for (const p in s)
    (Oi(s[p]) || a.style && Oi(a.style[p]) || GO(p, n)) && (c[p] = s[p]);
  return c;
}
function az(n, a) {
  const s = bT(n, a);
  for (const c in n)
    if (Oi(n[c]) || Oi(a[c])) {
      const p = hy.indexOf(c) !== -1 ? "attr" + c.charAt(0).toUpperCase() + c.substring(1) : c;
      s[p] = n[c];
    }
  return s;
}
function ST(n, a, s, c = {}, p = {}) {
  return typeof a == "function" && (a = a(s !== void 0 ? s : n.custom, c, p)), typeof a == "string" && (a = n.variants && n.variants[a]), typeof a == "function" && (a = a(s !== void 0 ? s : n.custom, c, p)), a;
}
function iz(n) {
  const a = ga(null);
  return a.current === null && (a.current = n()), a.current;
}
const cS = (n) => Array.isArray(n), Q7 = (n) => !!(n && typeof n == "object" && n.mix && n.toValue), K7 = (n) => cS(n) ? n[n.length - 1] || 0 : n;
function Gb(n) {
  const a = Oi(n) ? n.get() : n;
  return Q7(a) ? a.toValue() : a;
}
function X7({ scrapeMotionValuesFromProps: n, createRenderState: a, onMount: s }, c, p, v) {
  const h = {
    latestValues: Z7(c, p, v, n),
    renderState: a()
  };
  return s && (h.mount = (b) => s(c, b, h)), h;
}
const oz = (n) => (a, s) => {
  const c = ar(zS), p = ar(py), v = () => X7(n, a, c, p);
  return s ? v() : iz(v);
};
function Z7(n, a, s, c) {
  const p = {}, v = c(n, {});
  for (const _ in v)
    p[_] = Gb(v[_]);
  let { initial: h, animate: b } = n;
  const x = $S(n), E = WO(n);
  a && E && !x && n.inherit !== !1 && (h === void 0 && (h = a.initial), b === void 0 && (b = a.animate));
  let w = s ? s.initial === !1 : !1;
  w = w || h === !1;
  const k = w ? b : h;
  return k && typeof k != "boolean" && !LS(k) && (Array.isArray(k) ? k : [k]).forEach((A) => {
    const L = ST(n, A);
    if (!L)
      return;
    const { transitionEnd: $, transition: Y, ...K } = L;
    for (const W in K) {
      let F = K[W];
      if (Array.isArray(F)) {
        const ne = w ? F.length - 1 : 0;
        F = F[ne];
      }
      F !== null && (p[W] = F);
    }
    for (const W in $)
      p[W] = $[W];
  }), p;
}
const rr = (n) => n, { schedule: Wn, cancel: eu, state: va, steps: FE } = HO(typeof requestAnimationFrame < "u" ? requestAnimationFrame : rr, !0), J7 = {
  useVisualState: oz({
    scrapeMotionValuesFromProps: az,
    createRenderState: ez,
    onMount: (n, a, { renderState: s, latestValues: c }) => {
      Wn.read(() => {
        try {
          s.dimensions = typeof a.getBBox == "function" ? a.getBBox() : a.getBoundingClientRect();
        } catch {
          s.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Wn.render(() => {
        yT(s, c, { enableHardwareAcceleration: !1 }, gT(a.tagName), n.transformTemplate), rz(a, s);
      });
    }
  })
}, eW = {
  useVisualState: oz({
    scrapeMotionValuesFromProps: bT,
    createRenderState: vT
  })
};
function tW(n, { forwardMotionProps: a = !1 }, s, c) {
  return {
    ...hT(n) ? J7 : eW,
    preloadedFeatures: s,
    useRender: q7(a),
    createVisualElement: c,
    Component: n
  };
}
function Ql(n, a, s, c = { passive: !0 }) {
  return n.addEventListener(a, s, c), () => n.removeEventListener(a, s);
}
const sz = (n) => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1;
function FS(n, a = "page") {
  return {
    point: {
      x: n[a + "X"],
      y: n[a + "Y"]
    }
  };
}
const nW = (n) => (a) => sz(a) && n(a, FS(a));
function Xl(n, a, s, c) {
  return Ql(n, a, nW(s), c);
}
const rW = (n, a) => (s) => a(n(s)), fc = (...n) => n.reduce(rW);
function lz(n) {
  let a = null;
  return () => {
    const s = () => {
      a = null;
    };
    return a === null ? (a = n, s) : !1;
  };
}
const aA = lz("dragHorizontal"), iA = lz("dragVertical");
function uz(n) {
  let a = !1;
  if (n === "y")
    a = iA();
  else if (n === "x")
    a = aA();
  else {
    const s = aA(), c = iA();
    s && c ? a = () => {
      s(), c();
    } : (s && s(), c && c());
  }
  return a;
}
function cz() {
  const n = uz(!0);
  return n ? (n(), !1) : !0;
}
class vc {
  constructor(a) {
    this.isMounted = !1, this.node = a;
  }
  update() {
  }
}
function oA(n, a) {
  const s = "pointer" + (a ? "enter" : "leave"), c = "onHover" + (a ? "Start" : "End"), p = (v, h) => {
    if (v.pointerType === "touch" || cz())
      return;
    const b = n.getProps();
    n.animationState && b.whileHover && n.animationState.setActive("whileHover", a), b[c] && Wn.update(() => b[c](v, h));
  };
  return Xl(n.current, s, p, {
    passive: !n.getProps()[c]
  });
}
class aW extends vc {
  mount() {
    this.unmount = fc(oA(this.node, !0), oA(this.node, !1));
  }
  unmount() {
  }
}
class iW extends vc {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let a = !1;
    try {
      a = this.node.current.matches(":focus-visible");
    } catch {
      a = !0;
    }
    !a || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = fc(Ql(this.node.current, "focus", () => this.onFocus()), Ql(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const fz = (n, a) => a ? n === a ? !0 : fz(n, a.parentElement) : !1;
function VE(n, a) {
  if (!a)
    return;
  const s = new PointerEvent("pointer" + n);
  a(s, FS(s));
}
class oW extends vc {
  constructor() {
    super(...arguments), this.removeStartListeners = rr, this.removeEndListeners = rr, this.removeAccessibleListeners = rr, this.startPointerPress = (a, s) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const c = this.node.getProps(), v = Xl(window, "pointerup", (b, x) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: E, onTapCancel: w, globalTapTarget: k } = this.node.getProps();
        Wn.update(() => {
          !k && !fz(this.node.current, b.target) ? w && w(b, x) : E && E(b, x);
        });
      }, { passive: !(c.onTap || c.onPointerUp) }), h = Xl(window, "pointercancel", (b, x) => this.cancelPress(b, x), { passive: !(c.onTapCancel || c.onPointerCancel) });
      this.removeEndListeners = fc(v, h), this.startPress(a, s);
    }, this.startAccessiblePress = () => {
      const a = (v) => {
        if (v.key !== "Enter" || this.isPressing)
          return;
        const h = (b) => {
          b.key !== "Enter" || !this.checkPressEnd() || VE("up", (x, E) => {
            const { onTap: w } = this.node.getProps();
            w && Wn.update(() => w(x, E));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Ql(this.node.current, "keyup", h), VE("down", (b, x) => {
          this.startPress(b, x);
        });
      }, s = Ql(this.node.current, "keydown", a), c = () => {
        this.isPressing && VE("cancel", (v, h) => this.cancelPress(v, h));
      }, p = Ql(this.node.current, "blur", c);
      this.removeAccessibleListeners = fc(s, p);
    };
  }
  startPress(a, s) {
    this.isPressing = !0;
    const { onTapStart: c, whileTap: p } = this.node.getProps();
    p && this.node.animationState && this.node.animationState.setActive("whileTap", !0), c && Wn.update(() => c(a, s));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !cz();
  }
  cancelPress(a, s) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: c } = this.node.getProps();
    c && Wn.update(() => c(a, s));
  }
  mount() {
    const a = this.node.getProps(), s = Xl(a.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(a.onTapStart || a.onPointerStart) }), c = Ql(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = fc(s, c);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const xw = /* @__PURE__ */ new WeakMap(), jE = /* @__PURE__ */ new WeakMap(), sW = (n) => {
  const a = xw.get(n.target);
  a && a(n);
}, lW = (n) => {
  n.forEach(sW);
};
function uW({ root: n, ...a }) {
  const s = n || document;
  jE.has(s) || jE.set(s, {});
  const c = jE.get(s), p = JSON.stringify(a);
  return c[p] || (c[p] = new IntersectionObserver(lW, { root: n, ...a })), c[p];
}
function cW(n, a, s) {
  const c = uW(a);
  return xw.set(n, s), c.observe(n), () => {
    xw.delete(n), c.unobserve(n);
  };
}
const fW = {
  some: 0,
  all: 1
};
class dW extends vc {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: a = {} } = this.node.getProps(), { root: s, margin: c, amount: p = "some", once: v } = a, h = {
      root: s ? s.current : void 0,
      rootMargin: c,
      threshold: typeof p == "number" ? p : fW[p]
    }, b = (x) => {
      const { isIntersecting: E } = x;
      if (this.isInView === E || (this.isInView = E, v && !E && this.hasEnteredView))
        return;
      E && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", E);
      const { onViewportEnter: w, onViewportLeave: k } = this.node.getProps(), _ = E ? w : k;
      _ && _(x);
    };
    return cW(this.node.current, h, b);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: a, prevProps: s } = this.node;
    ["amount", "margin", "root"].some(pW(a, s)) && this.startObserver();
  }
  unmount() {
  }
}
function pW({ viewport: n = {} }, { viewport: a = {} } = {}) {
  return (s) => n[s] !== a[s];
}
const hW = {
  inView: {
    Feature: dW
  },
  tap: {
    Feature: oW
  },
  focus: {
    Feature: iW
  },
  hover: {
    Feature: aW
  }
};
function dz(n, a) {
  if (!Array.isArray(a))
    return !1;
  const s = a.length;
  if (s !== n.length)
    return !1;
  for (let c = 0; c < s; c++)
    if (a[c] !== n[c])
      return !1;
  return !0;
}
function mW(n) {
  const a = {};
  return n.values.forEach((s, c) => a[c] = s.get()), a;
}
function vW(n) {
  const a = {};
  return n.values.forEach((s, c) => a[c] = s.getVelocity()), a;
}
function VS(n, a, s) {
  const c = n.getProps();
  return ST(c, a, s !== void 0 ? s : c.custom, mW(n), vW(n));
}
let yy = rr, xo = rr;
process.env.NODE_ENV !== "production" && (yy = (n, a) => {
  !n && typeof console < "u" && console.warn(a);
}, xo = (n, a) => {
  if (!n)
    throw new Error(a);
});
const dc = (n) => n * 1e3, Zl = (n) => n / 1e3, yW = {
  current: !1
}, pz = (n) => Array.isArray(n) && typeof n[0] == "number";
function hz(n) {
  return !!(!n || typeof n == "string" && mz[n] || pz(n) || Array.isArray(n) && n.every(hz));
}
const jv = ([n, a, s, c]) => `cubic-bezier(${n}, ${a}, ${s}, ${c})`, mz = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: jv([0, 0.65, 0.55, 1]),
  circOut: jv([0.55, 0, 1, 0.45]),
  backIn: jv([0.31, 0.01, 0.66, -0.59]),
  backOut: jv([0.33, 1.53, 0.69, 0.99])
};
function vz(n) {
  if (n)
    return pz(n) ? jv(n) : Array.isArray(n) ? n.map(vz) : mz[n];
}
function gW(n, a, s, { delay: c = 0, duration: p, repeat: v = 0, repeatType: h = "loop", ease: b, times: x } = {}) {
  const E = { [a]: s };
  x && (E.offset = x);
  const w = vz(b);
  return Array.isArray(w) && (E.easing = w), n.animate(E, {
    delay: c,
    duration: p,
    easing: Array.isArray(w) ? "linear" : w,
    fill: "both",
    iterations: v + 1,
    direction: h === "reverse" ? "alternate" : "normal"
  });
}
function bW(n, { repeat: a, repeatType: s = "loop" }) {
  const c = a && s !== "loop" && a % 2 === 1 ? 0 : n.length - 1;
  return n[c];
}
const yz = (n, a, s) => (((1 - 3 * s + 3 * a) * n + (3 * s - 6 * a)) * n + 3 * a) * n, SW = 1e-7, xW = 12;
function CW(n, a, s, c, p) {
  let v, h, b = 0;
  do
    h = a + (s - a) / 2, v = yz(h, c, p) - n, v > 0 ? s = h : a = h;
  while (Math.abs(v) > SW && ++b < xW);
  return h;
}
function gy(n, a, s, c) {
  if (n === a && s === c)
    return rr;
  const p = (v) => CW(v, 0, 1, n, s);
  return (v) => v === 0 || v === 1 ? v : yz(p(v), a, c);
}
const EW = gy(0.42, 0, 1, 1), wW = gy(0, 0, 0.58, 1), gz = gy(0.42, 0, 0.58, 1), TW = (n) => Array.isArray(n) && typeof n[0] != "number", bz = (n) => (a) => a <= 0.5 ? n(2 * a) / 2 : (2 - n(2 * (1 - a))) / 2, Sz = (n) => (a) => 1 - n(1 - a), xT = (n) => 1 - Math.sin(Math.acos(n)), xz = Sz(xT), kW = bz(xT), Cz = gy(0.33, 1.53, 0.69, 0.99), CT = Sz(Cz), RW = bz(CT), _W = (n) => (n *= 2) < 1 ? 0.5 * CT(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))), sA = {
  linear: rr,
  easeIn: EW,
  easeInOut: gz,
  easeOut: wW,
  circIn: xT,
  circInOut: kW,
  circOut: xz,
  backIn: CT,
  backInOut: RW,
  backOut: Cz,
  anticipate: _W
}, lA = (n) => {
  if (Array.isArray(n)) {
    xo(n.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [a, s, c, p] = n;
    return gy(a, s, c, p);
  } else if (typeof n == "string")
    return xo(sA[n] !== void 0, `Invalid easing type '${n}'`), sA[n];
  return n;
}, ET = (n, a) => (s) => !!(my(s) && P7.test(s) && s.startsWith(n) || a && Object.prototype.hasOwnProperty.call(s, a)), Ez = (n, a, s) => (c) => {
  if (!my(c))
    return c;
  const [p, v, h, b] = c.match(NS);
  return {
    [n]: parseFloat(p),
    [a]: parseFloat(v),
    [s]: parseFloat(h),
    alpha: b !== void 0 ? parseFloat(b) : 1
  };
}, DW = (n) => hc(0, 255, n), BE = {
  ...If,
  transform: (n) => Math.round(DW(n))
}, zf = {
  test: ET("rgb", "red"),
  parse: Ez("red", "green", "blue"),
  transform: ({ red: n, green: a, blue: s, alpha: c = 1 }) => "rgba(" + BE.transform(n) + ", " + BE.transform(a) + ", " + BE.transform(s) + ", " + Qv(qv.transform(c)) + ")"
};
function AW(n) {
  let a = "", s = "", c = "", p = "";
  return n.length > 5 ? (a = n.substring(1, 3), s = n.substring(3, 5), c = n.substring(5, 7), p = n.substring(7, 9)) : (a = n.substring(1, 2), s = n.substring(2, 3), c = n.substring(3, 4), p = n.substring(4, 5), a += a, s += s, c += c, p += p), {
    red: parseInt(a, 16),
    green: parseInt(s, 16),
    blue: parseInt(c, 16),
    alpha: p ? parseInt(p, 16) / 255 : 1
  };
}
const Cw = {
  test: ET("#"),
  parse: AW,
  transform: zf.transform
}, Hp = {
  test: ET("hsl", "hue"),
  parse: Ez("hue", "saturation", "lightness"),
  transform: ({ hue: n, saturation: a, lightness: s, alpha: c = 1 }) => "hsla(" + Math.round(n) + ", " + Qs.transform(Qv(a)) + ", " + Qs.transform(Qv(s)) + ", " + Qv(qv.transform(c)) + ")"
}, ai = {
  test: (n) => zf.test(n) || Cw.test(n) || Hp.test(n),
  parse: (n) => zf.test(n) ? zf.parse(n) : Hp.test(n) ? Hp.parse(n) : Cw.parse(n),
  transform: (n) => my(n) ? n : n.hasOwnProperty("red") ? zf.transform(n) : Hp.transform(n)
}, Kn = (n, a, s) => -s * n + s * a + n;
function UE(n, a, s) {
  return s < 0 && (s += 1), s > 1 && (s -= 1), s < 1 / 6 ? n + (a - n) * 6 * s : s < 1 / 2 ? a : s < 2 / 3 ? n + (a - n) * (2 / 3 - s) * 6 : n;
}
function MW({ hue: n, saturation: a, lightness: s, alpha: c }) {
  n /= 360, a /= 100, s /= 100;
  let p = 0, v = 0, h = 0;
  if (!a)
    p = v = h = s;
  else {
    const b = s < 0.5 ? s * (1 + a) : s + a - s * a, x = 2 * s - b;
    p = UE(x, b, n + 1 / 3), v = UE(x, b, n), h = UE(x, b, n - 1 / 3);
  }
  return {
    red: Math.round(p * 255),
    green: Math.round(v * 255),
    blue: Math.round(h * 255),
    alpha: c
  };
}
const IE = (n, a, s) => {
  const c = n * n;
  return Math.sqrt(Math.max(0, s * (a * a - c) + c));
}, OW = [Cw, zf, Hp], zW = (n) => OW.find((a) => a.test(n));
function uA(n) {
  const a = zW(n);
  xo(!!a, `'${n}' is not an animatable color. Use the equivalent color code instead.`);
  let s = a.parse(n);
  return a === Hp && (s = MW(s)), s;
}
const wz = (n, a) => {
  const s = uA(n), c = uA(a), p = { ...s };
  return (v) => (p.red = IE(s.red, c.red, v), p.green = IE(s.green, c.green, v), p.blue = IE(s.blue, c.blue, v), p.alpha = Kn(s.alpha, c.alpha, v), zf.transform(p));
};
function PW(n) {
  var a, s;
  return isNaN(n) && my(n) && (((a = n.match(NS)) === null || a === void 0 ? void 0 : a.length) || 0) + (((s = n.match(KO)) === null || s === void 0 ? void 0 : s.length) || 0) > 0;
}
const Tz = {
  regex: O7,
  countKey: "Vars",
  token: "${v}",
  parse: rr
}, kz = {
  regex: KO,
  countKey: "Colors",
  token: "${c}",
  parse: ai.parse
}, Rz = {
  regex: NS,
  countKey: "Numbers",
  token: "${n}",
  parse: If.parse
};
function HE(n, { regex: a, countKey: s, token: c, parse: p }) {
  const v = n.tokenised.match(a);
  v && (n["num" + s] = v.length, n.tokenised = n.tokenised.replace(a, c), n.values.push(...v.map(p)));
}
function fS(n) {
  const a = n.toString(), s = {
    value: a,
    tokenised: a,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  return s.value.includes("var(--") && HE(s, Tz), HE(s, kz), HE(s, Rz), s;
}
function _z(n) {
  return fS(n).values;
}
function Dz(n) {
  const { values: a, numColors: s, numVars: c, tokenised: p } = fS(n), v = a.length;
  return (h) => {
    let b = p;
    for (let x = 0; x < v; x++)
      x < c ? b = b.replace(Tz.token, h[x]) : x < c + s ? b = b.replace(kz.token, ai.transform(h[x])) : b = b.replace(Rz.token, Qv(h[x]));
    return b;
  };
}
const LW = (n) => typeof n == "number" ? 0 : n;
function $W(n) {
  const a = _z(n);
  return Dz(n)(a.map(LW));
}
const mc = {
  test: PW,
  parse: _z,
  createTransformer: Dz,
  getAnimatableNone: $W
}, Az = (n, a) => (s) => `${s > 0 ? a : n}`;
function Mz(n, a) {
  return typeof n == "number" ? (s) => Kn(n, a, s) : ai.test(n) ? wz(n, a) : n.startsWith("var(") ? Az(n, a) : zz(n, a);
}
const Oz = (n, a) => {
  const s = [...n], c = s.length, p = n.map((v, h) => Mz(v, a[h]));
  return (v) => {
    for (let h = 0; h < c; h++)
      s[h] = p[h](v);
    return s;
  };
}, NW = (n, a) => {
  const s = { ...n, ...a }, c = {};
  for (const p in s)
    n[p] !== void 0 && a[p] !== void 0 && (c[p] = Mz(n[p], a[p]));
  return (p) => {
    for (const v in c)
      s[v] = c[v](p);
    return s;
  };
}, zz = (n, a) => {
  const s = mc.createTransformer(a), c = fS(n), p = fS(a);
  return c.numVars === p.numVars && c.numColors === p.numColors && c.numNumbers >= p.numNumbers ? fc(Oz(c.values, p.values), s) : (yy(!0, `Complex values '${n}' and '${a}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Az(n, a));
}, ly = (n, a, s) => {
  const c = a - n;
  return c === 0 ? 1 : (s - n) / c;
}, cA = (n, a) => (s) => Kn(n, a, s);
function FW(n) {
  return typeof n == "number" ? cA : typeof n == "string" ? ai.test(n) ? wz : zz : Array.isArray(n) ? Oz : typeof n == "object" ? NW : cA;
}
function VW(n, a, s) {
  const c = [], p = s || FW(n[0]), v = n.length - 1;
  for (let h = 0; h < v; h++) {
    let b = p(n[h], n[h + 1]);
    if (a) {
      const x = Array.isArray(a) ? a[h] || rr : a;
      b = fc(x, b);
    }
    c.push(b);
  }
  return c;
}
function Pz(n, a, { clamp: s = !0, ease: c, mixer: p } = {}) {
  const v = n.length;
  if (xo(v === a.length, "Both input and output ranges must be the same length"), v === 1)
    return () => a[0];
  n[0] > n[v - 1] && (n = [...n].reverse(), a = [...a].reverse());
  const h = VW(a, c, p), b = h.length, x = (E) => {
    let w = 0;
    if (b > 1)
      for (; w < n.length - 2 && !(E < n[w + 1]); w++)
        ;
    const k = ly(n[w], n[w + 1], E);
    return h[w](k);
  };
  return s ? (E) => x(hc(n[0], n[v - 1], E)) : x;
}
function jW(n, a) {
  const s = n[n.length - 1];
  for (let c = 1; c <= a; c++) {
    const p = ly(0, a, c);
    n.push(Kn(s, 1, p));
  }
}
function BW(n) {
  const a = [0];
  return jW(a, n.length - 1), a;
}
function UW(n, a) {
  return n.map((s) => s * a);
}
function IW(n, a) {
  return n.map(() => a || gz).splice(0, n.length - 1);
}
function dS({ duration: n = 300, keyframes: a, times: s, ease: c = "easeInOut" }) {
  const p = TW(c) ? c.map(lA) : lA(c), v = {
    done: !1,
    value: a[0]
  }, h = UW(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    s && s.length === a.length ? s : BW(a),
    n
  ), b = Pz(h, a, {
    ease: Array.isArray(p) ? p : IW(a, p)
  });
  return {
    calculatedDuration: n,
    next: (x) => (v.value = b(x), v.done = x >= n, v)
  };
}
function Lz(n, a) {
  return a ? n * (1e3 / a) : 0;
}
const HW = 5;
function $z(n, a, s) {
  const c = Math.max(a - HW, 0);
  return Lz(s - n(c), a - c);
}
const WE = 1e-3, WW = 0.01, fA = 10, YW = 0.05, GW = 1;
function qW({ duration: n = 800, bounce: a = 0.25, velocity: s = 0, mass: c = 1 }) {
  let p, v;
  yy(n <= dc(fA), "Spring duration must be 10 seconds or less");
  let h = 1 - a;
  h = hc(YW, GW, h), n = hc(WW, fA, Zl(n)), h < 1 ? (p = (E) => {
    const w = E * h, k = w * n, _ = w - s, A = Ew(E, h), L = Math.exp(-k);
    return WE - _ / A * L;
  }, v = (E) => {
    const k = E * h * n, _ = k * s + s, A = Math.pow(h, 2) * Math.pow(E, 2) * n, L = Math.exp(-k), $ = Ew(Math.pow(E, 2), h);
    return (-p(E) + WE > 0 ? -1 : 1) * ((_ - A) * L) / $;
  }) : (p = (E) => {
    const w = Math.exp(-E * n), k = (E - s) * n + 1;
    return -WE + w * k;
  }, v = (E) => {
    const w = Math.exp(-E * n), k = (s - E) * (n * n);
    return w * k;
  });
  const b = 5 / n, x = KW(p, v, b);
  if (n = dc(n), isNaN(x))
    return {
      stiffness: 100,
      damping: 10,
      duration: n
    };
  {
    const E = Math.pow(x, 2) * c;
    return {
      stiffness: E,
      damping: h * 2 * Math.sqrt(c * E),
      duration: n
    };
  }
}
const QW = 12;
function KW(n, a, s) {
  let c = s;
  for (let p = 1; p < QW; p++)
    c = c - n(c) / a(c);
  return c;
}
function Ew(n, a) {
  return n * Math.sqrt(1 - a * a);
}
const XW = ["duration", "bounce"], ZW = ["stiffness", "damping", "mass"];
function dA(n, a) {
  return a.some((s) => n[s] !== void 0);
}
function JW(n) {
  let a = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...n
  };
  if (!dA(n, ZW) && dA(n, XW)) {
    const s = qW(n);
    a = {
      ...a,
      ...s,
      mass: 1
    }, a.isResolvedFromDuration = !0;
  }
  return a;
}
function Nz({ keyframes: n, restDelta: a, restSpeed: s, ...c }) {
  const p = n[0], v = n[n.length - 1], h = { done: !1, value: p }, { stiffness: b, damping: x, mass: E, duration: w, velocity: k, isResolvedFromDuration: _ } = JW({
    ...c,
    velocity: -Zl(c.velocity || 0)
  }), A = k || 0, L = x / (2 * Math.sqrt(b * E)), $ = v - p, Y = Zl(Math.sqrt(b / E)), K = Math.abs($) < 5;
  s || (s = K ? 0.01 : 2), a || (a = K ? 5e-3 : 0.5);
  let W;
  if (L < 1) {
    const F = Ew(Y, L);
    W = (ne) => {
      const H = Math.exp(-L * Y * ne);
      return v - H * ((A + L * Y * $) / F * Math.sin(F * ne) + $ * Math.cos(F * ne));
    };
  } else if (L === 1)
    W = (F) => v - Math.exp(-Y * F) * ($ + (A + Y * $) * F);
  else {
    const F = Y * Math.sqrt(L * L - 1);
    W = (ne) => {
      const H = Math.exp(-L * Y * ne), le = Math.min(F * ne, 300);
      return v - H * ((A + L * Y * $) * Math.sinh(le) + F * $ * Math.cosh(le)) / F;
    };
  }
  return {
    calculatedDuration: _ && w || null,
    next: (F) => {
      const ne = W(F);
      if (_)
        h.done = F >= w;
      else {
        let H = A;
        F !== 0 && (L < 1 ? H = $z(W, F, ne) : H = 0);
        const le = Math.abs(H) <= s, re = Math.abs(v - ne) <= a;
        h.done = le && re;
      }
      return h.value = h.done ? v : ne, h;
    }
  };
}
function pA({ keyframes: n, velocity: a = 0, power: s = 0.8, timeConstant: c = 325, bounceDamping: p = 10, bounceStiffness: v = 500, modifyTarget: h, min: b, max: x, restDelta: E = 0.5, restSpeed: w }) {
  const k = n[0], _ = {
    done: !1,
    value: k
  }, A = (De) => b !== void 0 && De < b || x !== void 0 && De > x, L = (De) => b === void 0 ? x : x === void 0 || Math.abs(b - De) < Math.abs(x - De) ? b : x;
  let $ = s * a;
  const Y = k + $, K = h === void 0 ? Y : h(Y);
  K !== Y && ($ = K - k);
  const W = (De) => -$ * Math.exp(-De / c), F = (De) => K + W(De), ne = (De) => {
    const Fe = W(De), ot = F(De);
    _.done = Math.abs(Fe) <= E, _.value = _.done ? K : ot;
  };
  let H, le;
  const re = (De) => {
    A(_.value) && (H = De, le = Nz({
      keyframes: [_.value, L(_.value)],
      velocity: $z(F, De, _.value),
      damping: p,
      stiffness: v,
      restDelta: E,
      restSpeed: w
    }));
  };
  return re(0), {
    calculatedDuration: null,
    next: (De) => {
      let Fe = !1;
      return !le && H === void 0 && (Fe = !0, ne(De), re(De)), H !== void 0 && De > H ? le.next(De - H) : (!Fe && ne(De), _);
    }
  };
}
let qb;
function eY() {
  qb = void 0;
}
const Vf = {
  now: () => (qb === void 0 && Vf.set(va.isProcessing || IO.useManualTiming ? va.timestamp : performance.now()), qb),
  set: (n) => {
    qb = n, queueMicrotask(eY);
  }
}, tY = (n) => {
  const a = ({ timestamp: s }) => n(s);
  return {
    start: () => Wn.update(a, !0),
    stop: () => eu(a),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => va.isProcessing ? va.timestamp : Vf.now()
  };
}, hA = 2e4;
function mA(n) {
  let a = 0;
  const s = 50;
  let c = n.next(a);
  for (; !c.done && a < hA; )
    a += s, c = n.next(a);
  return a >= hA ? 1 / 0 : a;
}
const nY = {
  decay: pA,
  inertia: pA,
  tween: dS,
  keyframes: dS,
  spring: Nz
};
function pS({ autoplay: n = !0, delay: a = 0, driver: s = tY, keyframes: c, type: p = "keyframes", repeat: v = 0, repeatDelay: h = 0, repeatType: b = "loop", onPlay: x, onStop: E, onComplete: w, onUpdate: k, ..._ }) {
  let A = 1, L = !1, $, Y;
  const K = () => {
    Y = new Promise((Ae) => {
      $ = Ae;
    });
  };
  K();
  let W;
  const F = nY[p] || dS;
  let ne;
  F !== dS && typeof c[0] != "number" && (process.env.NODE_ENV !== "production" && xo(c.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${c}`), ne = Pz([0, 100], c, {
    clamp: !1
  }), c = [0, 100]);
  const H = F({ ..._, keyframes: c });
  let le;
  b === "mirror" && (le = F({
    ..._,
    keyframes: [...c].reverse(),
    velocity: -(_.velocity || 0)
  }));
  let re = "idle", De = null, Fe = null, ot = null;
  H.calculatedDuration === null && v && (H.calculatedDuration = mA(H));
  const { calculatedDuration: vt } = H;
  let Rt = 1 / 0, $e = 1 / 0;
  vt !== null && (Rt = vt + h, $e = Rt * (v + 1) - h);
  let Be = 0;
  const jt = (Ae) => {
    if (Fe === null)
      return;
    A > 0 && (Fe = Math.min(Fe, Ae)), A < 0 && (Fe = Math.min(Ae - $e / A, Fe)), De !== null ? Be = De : Be = Math.round(Ae - Fe) * A;
    const Ye = Be - a * (A >= 0 ? 1 : -1), Ke = A >= 0 ? Ye < 0 : Ye > $e;
    Be = Math.max(Ye, 0), re === "finished" && De === null && (Be = $e);
    let cn = Be, Vn = H;
    if (v) {
      const Bt = Math.min(Be, $e) / Rt;
      let gn = Math.floor(Bt), $t = Bt % 1;
      !$t && Bt >= 1 && ($t = 1), $t === 1 && gn--, gn = Math.min(gn, v + 1), !!(gn % 2) && (b === "reverse" ? ($t = 1 - $t, h && ($t -= h / Rt)) : b === "mirror" && (Vn = le)), cn = hc(0, 1, $t) * Rt;
    }
    const bt = Ke ? { done: !1, value: c[0] } : Vn.next(cn);
    ne && (bt.value = ne(bt.value));
    let { done: yn } = bt;
    !Ke && vt !== null && (yn = A >= 0 ? Be >= $e : Be <= 0);
    const Ot = De === null && (re === "finished" || re === "running" && yn);
    return k && k(bt.value), Ot && he(), bt;
  }, tt = () => {
    W && W.stop(), W = void 0;
  }, Lt = () => {
    re = "idle", tt(), $(), K(), Fe = ot = null;
  }, he = () => {
    re = "finished", w && w(), tt(), $();
  }, Ce = () => {
    if (L)
      return;
    W || (W = s(jt));
    const Ae = W.now();
    x && x(), De !== null ? Fe = Ae - De : (!Fe || re === "finished") && (Fe = Ae), re === "finished" && K(), ot = Fe, De = null, re = "running", W.start();
  };
  n && Ce();
  const ve = {
    then(Ae, Ye) {
      return Y.then(Ae, Ye);
    },
    get time() {
      return Zl(Be);
    },
    set time(Ae) {
      Ae = dc(Ae), Be = Ae, De !== null || !W || A === 0 ? De = Ae : Fe = W.now() - Ae / A;
    },
    get duration() {
      const Ae = H.calculatedDuration === null ? mA(H) : H.calculatedDuration;
      return Zl(Ae);
    },
    get speed() {
      return A;
    },
    set speed(Ae) {
      Ae === A || !W || (A = Ae, ve.time = Zl(Be));
    },
    get state() {
      return re;
    },
    play: Ce,
    pause: () => {
      re = "paused", De = Be;
    },
    stop: () => {
      L = !0, re !== "idle" && (re = "idle", E && E(), Lt());
    },
    cancel: () => {
      ot !== null && jt(ot), Lt();
    },
    complete: () => {
      re = "finished";
    },
    sample: (Ae) => (Fe = 0, jt(Ae))
  };
  return ve;
}
function rY(n) {
  let a;
  return () => (a === void 0 && (a = n()), a);
}
const aY = rY(() => Object.hasOwnProperty.call(Element.prototype, "animate")), iY = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), kb = 10, oY = 2e4, sY = (n, a) => a.type === "spring" || n === "backgroundColor" || !hz(a.ease);
function lY(n, a, { onUpdate: s, onComplete: c, ...p }) {
  if (!(aY() && iY.has(a) && !p.repeatDelay && p.repeatType !== "mirror" && p.damping !== 0 && p.type !== "inertia"))
    return !1;
  let h = !1, b, x, E = !1;
  const w = () => {
    x = new Promise((F) => {
      b = F;
    });
  };
  w();
  let { keyframes: k, duration: _ = 300, ease: A, times: L } = p;
  if (sY(a, p)) {
    const F = pS({
      ...p,
      repeat: 0,
      delay: 0
    });
    let ne = { done: !1, value: k[0] };
    const H = [];
    let le = 0;
    for (; !ne.done && le < oY; )
      ne = F.sample(le), H.push(ne.value), le += kb;
    L = void 0, k = H, _ = le - kb, A = "linear";
  }
  const $ = gW(n.owner.current, a, k, {
    ...p,
    duration: _,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: A,
    times: L
  }), Y = () => {
    E = !1, $.cancel();
  }, K = () => {
    E = !0, Wn.update(Y), b(), w();
  };
  return $.onfinish = () => {
    E || (n.set(bW(k, p)), c && c(), K());
  }, {
    then(F, ne) {
      return x.then(F, ne);
    },
    attachTimeline(F) {
      return $.timeline = F, $.onfinish = null, rr;
    },
    get time() {
      return Zl($.currentTime || 0);
    },
    set time(F) {
      $.currentTime = dc(F);
    },
    get speed() {
      return $.playbackRate;
    },
    set speed(F) {
      $.playbackRate = F;
    },
    get duration() {
      return Zl(_);
    },
    play: () => {
      h || ($.play(), eu(Y));
    },
    pause: () => $.pause(),
    stop: () => {
      if (h = !0, $.playState === "idle")
        return;
      const { currentTime: F } = $;
      if (F) {
        const ne = pS({
          ...p,
          autoplay: !1
        });
        n.setWithVelocity(ne.sample(F - kb).value, ne.sample(F).value, kb);
      }
      K();
    },
    complete: () => {
      E || $.finish();
    },
    cancel: K
  };
}
function uY({ keyframes: n, delay: a, onUpdate: s, onComplete: c }) {
  const p = () => (s && s(n[n.length - 1]), c && c(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: rr,
    pause: rr,
    stop: rr,
    then: (v) => (v(), Promise.resolve()),
    cancel: rr,
    complete: rr
  });
  return a ? pS({
    keyframes: [0, 1],
    duration: 0,
    delay: a,
    onComplete: p
  }) : p();
}
const cY = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, fY = (n) => ({
  type: "spring",
  stiffness: 550,
  damping: n === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), dY = {
  type: "keyframes",
  duration: 0.8
}, pY = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, hY = (n, { keyframes: a }) => a.length > 2 ? dY : Uf.has(n) ? n.startsWith("scale") ? fY(a[1]) : cY : pY, ww = (n, a) => n === "zIndex" ? !1 : !!(typeof a == "number" || Array.isArray(a) || typeof a == "string" && // It's animatable if we have a string
(mc.test(a) || a === "0") && // And it contains numbers and/or colors
!a.startsWith("url(")), mY = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function vY(n) {
  const [a, s] = n.slice(0, -1).split("(");
  if (a === "drop-shadow")
    return n;
  const [c] = s.match(NS) || [];
  if (!c)
    return n;
  const p = s.replace(c, "");
  let v = mY.has(a) ? 1 : 0;
  return c !== s && (v *= 100), a + "(" + v + p + ")";
}
const yY = /([a-z-]*)\(.*?\)/g, Tw = {
  ...mc,
  getAnimatableNone: (n) => {
    const a = n.match(yY);
    return a ? a.map(vY).join(" ") : n;
  }
}, gY = {
  ...XO,
  // Color props
  color: ai,
  backgroundColor: ai,
  outlineColor: ai,
  fill: ai,
  stroke: ai,
  // Border props
  borderColor: ai,
  borderTopColor: ai,
  borderRightColor: ai,
  borderBottomColor: ai,
  borderLeftColor: ai,
  filter: Tw,
  WebkitFilter: Tw
}, wT = (n) => gY[n];
function Fz(n, a) {
  let s = wT(n);
  return s !== Tw && (s = mc), s.getAnimatableNone ? s.getAnimatableNone(a) : void 0;
}
const Vz = (n) => /^0[^.\s]+$/.test(n);
function bY(n) {
  if (typeof n == "number")
    return n === 0;
  if (n !== null)
    return n === "none" || n === "0" || Vz(n);
}
function SY(n, a, s, c) {
  const p = ww(a, s);
  let v;
  Array.isArray(s) ? v = [...s] : v = [null, s];
  const h = c.from !== void 0 ? c.from : n.get();
  let b;
  const x = [];
  for (let E = 0; E < v.length; E++)
    v[E] === null && (v[E] = E === 0 ? h : v[E - 1]), bY(v[E]) && x.push(E), typeof v[E] == "string" && v[E] !== "none" && v[E] !== "0" && (b = v[E]);
  if (p && x.length && b)
    for (let E = 0; E < x.length; E++) {
      const w = x[E];
      v[w] = Fz(a, b);
    }
  return v;
}
function xY({ when: n, delay: a, delayChildren: s, staggerChildren: c, staggerDirection: p, repeat: v, repeatType: h, repeatDelay: b, from: x, elapsed: E, ...w }) {
  return !!Object.keys(w).length;
}
function TT(n, a) {
  return n[a] || n.default || n;
}
const kT = (n, a, s, c = {}) => (p) => {
  const v = TT(c, n) || {}, h = v.delay || c.delay || 0;
  let { elapsed: b = 0 } = c;
  b = b - dc(h);
  const x = SY(a, n, s, v), E = x[0], w = x[x.length - 1], k = ww(n, E), _ = ww(n, w);
  yy(k === _, `You are trying to animate ${n} from "${E}" to "${w}". ${E} is not an animatable value - to enable this animation set ${E} to a value animatable to ${w} via the \`style\` property.`);
  let A = {
    keyframes: x,
    velocity: a.getVelocity(),
    ease: "easeOut",
    ...v,
    delay: -b,
    onUpdate: (L) => {
      a.set(L), v.onUpdate && v.onUpdate(L);
    },
    onComplete: () => {
      p(), v.onComplete && v.onComplete();
    }
  };
  if (xY(v) || (A = {
    ...A,
    ...hY(n, A)
  }), A.duration && (A.duration = dc(A.duration)), A.repeatDelay && (A.repeatDelay = dc(A.repeatDelay)), !k || !_ || yW.current || v.type === !1 || IO.skipAnimations)
    return uY(A);
  if (
    /**
     * If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    !c.isHandoff && a.owner && a.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !a.owner.getProps().onUpdate
  ) {
    const L = lY(a, n, A);
    if (L)
      return L;
  }
  return pS(A);
};
function hS(n) {
  return !!(Oi(n) && n.add);
}
const jz = (n) => /^\-?\d*\.?\d+$/.test(n);
function RT(n, a) {
  n.indexOf(a) === -1 && n.push(a);
}
function _T(n, a) {
  const s = n.indexOf(a);
  s > -1 && n.splice(s, 1);
}
class DT {
  constructor() {
    this.subscriptions = [];
  }
  add(a) {
    return RT(this.subscriptions, a), () => _T(this.subscriptions, a);
  }
  notify(a, s, c) {
    const p = this.subscriptions.length;
    if (p)
      if (p === 1)
        this.subscriptions[0](a, s, c);
      else
        for (let v = 0; v < p; v++) {
          const h = this.subscriptions[v];
          h && h(a, s, c);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const vA = /* @__PURE__ */ new Set();
function AT(n, a, s) {
  n || vA.has(a) || (console.warn(a), s && console.warn(s), vA.add(a));
}
const yA = 30, CY = (n) => !isNaN(parseFloat(n));
class EY {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(a, s = {}) {
    this.version = "11.0.3", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (c, p = !0) => {
      const v = Vf.now();
      this.updatedAt !== v && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(c), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), p && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(a), this.canTrackVelocity = CY(this.current), this.owner = s.owner;
  }
  setCurrent(a) {
    this.current = a, this.updatedAt = Vf.now();
  }
  setPrevFrameValue(a = this.current) {
    this.prevFrameValue = a, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(a) {
    return process.env.NODE_ENV !== "production" && AT(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", a);
  }
  on(a, s) {
    this.events[a] || (this.events[a] = new DT());
    const c = this.events[a].add(s);
    return a === "change" ? () => {
      c(), Wn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : c;
  }
  clearListeners() {
    for (const a in this.events)
      this.events[a].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(a, s) {
    this.passiveEffect = a, this.stopPassiveEffect = s;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(a, s = !0) {
    !s || !this.passiveEffect ? this.updateAndNotify(a, s) : this.passiveEffect(a, this.updateAndNotify);
  }
  setWithVelocity(a, s, c) {
    this.set(s), this.prev = void 0, this.prevFrameValue = a, this.prevUpdatedAt = this.updatedAt - c;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(a) {
    this.updateAndNotify(a), this.prev = a, this.prevUpdatedAt = this.prevFrameValue = void 0, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const a = Vf.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || a - this.updatedAt > yA)
      return 0;
    const s = Math.min(this.updatedAt - this.prevUpdatedAt, yA);
    return Lz(parseFloat(this.current) - parseFloat(this.prevFrameValue), s);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(a) {
    return this.stop(), new Promise((s) => {
      this.hasAnimated = !0, this.animation = a(s), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function uh(n, a) {
  return new EY(n, a);
}
const Bz = (n) => (a) => a.test(n), wY = {
  test: (n) => n === "auto",
  parse: (n) => n
}, Uz = [If, it, Qs, sc, $7, L7, wY], Mv = (n) => Uz.find(Bz(n)), TY = [...Uz, ai, mc], kY = (n) => TY.find(Bz(n));
function RY(n, a, s) {
  n.hasValue(a) ? n.getValue(a).set(s) : n.addValue(a, uh(s));
}
function _Y(n, a) {
  const s = VS(n, a);
  let { transitionEnd: c = {}, transition: p = {}, ...v } = s ? n.makeTargetAnimatable(s, !1) : {};
  v = { ...v, ...c };
  for (const h in v) {
    const b = K7(v[h]);
    RY(n, h, b);
  }
}
function DY(n, a, s) {
  var c, p;
  const v = Object.keys(a).filter((b) => !n.hasValue(b)), h = v.length;
  if (h)
    for (let b = 0; b < h; b++) {
      const x = v[b], E = a[x];
      let w = null;
      Array.isArray(E) && (w = E[0]), w === null && (w = (p = (c = s[x]) !== null && c !== void 0 ? c : n.readValue(x)) !== null && p !== void 0 ? p : a[x]), w != null && (typeof w == "string" && (jz(w) || Vz(w)) ? w = parseFloat(w) : !kY(w) && mc.test(E) && (w = Fz(x, E)), n.addValue(x, uh(w, { owner: n })), s[x] === void 0 && (s[x] = w), w !== null && n.setBaseTarget(x, w));
    }
}
function AY(n, a) {
  return a ? (a[n] || a.default || a).from : void 0;
}
function MY(n, a, s) {
  const c = {};
  for (const p in n) {
    const v = AY(p, a);
    if (v !== void 0)
      c[p] = v;
    else {
      const h = s.getValue(p);
      h && (c[p] = h.get());
    }
  }
  return c;
}
function OY({ protectedKeys: n, needsAnimating: a }, s) {
  const c = n.hasOwnProperty(s) && a[s] !== !0;
  return a[s] = !1, c;
}
function zY(n, a) {
  const s = n.get();
  if (Array.isArray(a)) {
    for (let c = 0; c < a.length; c++)
      if (a[c] !== s)
        return !0;
  } else
    return s !== a;
}
function Iz(n, a, { delay: s = 0, transitionOverride: c, type: p } = {}) {
  let { transition: v = n.getDefaultTransition(), transitionEnd: h, ...b } = n.makeTargetAnimatable(a);
  const x = n.getValue("willChange");
  c && (v = c);
  const E = [], w = p && n.animationState && n.animationState.getState()[p];
  for (const k in b) {
    const _ = n.getValue(k), A = b[k];
    if (!_ || A === void 0 || w && OY(w, k))
      continue;
    const L = {
      delay: s,
      elapsed: 0,
      ...TT(v || {}, k)
    };
    if (window.HandoffAppearAnimations) {
      const K = n.getProps()[UO];
      if (K) {
        const W = window.HandoffAppearAnimations(K, k, _, Wn);
        W !== null && (L.elapsed = W, L.isHandoff = !0);
      }
    }
    let $ = !L.isHandoff && !zY(_, A);
    if (L.type === "spring" && (_.getVelocity() || L.velocity) && ($ = !1), _.animation && ($ = !1), $)
      continue;
    _.start(kT(k, _, A, n.shouldReduceMotion && Uf.has(k) ? { type: !1 } : L));
    const Y = _.animation;
    hS(x) && (x.add(k), Y.then(() => x.remove(k))), E.push(Y);
  }
  return h && Promise.all(E).then(() => {
    h && _Y(n, h);
  }), E;
}
function kw(n, a, s = {}) {
  const c = VS(n, a, s.custom);
  let { transition: p = n.getDefaultTransition() || {} } = c || {};
  s.transitionOverride && (p = s.transitionOverride);
  const v = c ? () => Promise.all(Iz(n, c, s)) : () => Promise.resolve(), h = n.variantChildren && n.variantChildren.size ? (x = 0) => {
    const { delayChildren: E = 0, staggerChildren: w, staggerDirection: k } = p;
    return PY(n, a, E + x, w, k, s);
  } : () => Promise.resolve(), { when: b } = p;
  if (b) {
    const [x, E] = b === "beforeChildren" ? [v, h] : [h, v];
    return x().then(() => E());
  } else
    return Promise.all([v(), h(s.delay)]);
}
function PY(n, a, s = 0, c = 0, p = 1, v) {
  const h = [], b = (n.variantChildren.size - 1) * c, x = p === 1 ? (E = 0) => E * c : (E = 0) => b - E * c;
  return Array.from(n.variantChildren).sort(LY).forEach((E, w) => {
    E.notify("AnimationStart", a), h.push(kw(E, a, {
      ...v,
      delay: s + x(w)
    }).then(() => E.notify("AnimationComplete", a)));
  }), Promise.all(h);
}
function LY(n, a) {
  return n.sortNodePosition(a);
}
function $Y(n, a, s = {}) {
  n.notify("AnimationStart", a);
  let c;
  if (Array.isArray(a)) {
    const p = a.map((v) => kw(n, v, s));
    c = Promise.all(p);
  } else if (typeof a == "string")
    c = kw(n, a, s);
  else {
    const p = typeof a == "function" ? VS(n, a, s.custom) : a;
    c = Promise.all(Iz(n, p, s));
  }
  return c.then(() => n.notify("AnimationComplete", a));
}
const NY = [...fT].reverse(), FY = fT.length;
function VY(n) {
  return (a) => Promise.all(a.map(({ animation: s, options: c }) => $Y(n, s, c)));
}
function jY(n) {
  let a = VY(n);
  const s = UY();
  let c = !0;
  const p = (x, E) => {
    const w = VS(n, E);
    if (w) {
      const { transition: k, transitionEnd: _, ...A } = w;
      x = { ...x, ...A, ..._ };
    }
    return x;
  };
  function v(x) {
    a = x(n);
  }
  function h(x, E) {
    const w = n.getProps(), k = n.getVariantContext(!0) || {}, _ = [], A = /* @__PURE__ */ new Set();
    let L = {}, $ = 1 / 0;
    for (let K = 0; K < FY; K++) {
      const W = NY[K], F = s[W], ne = w[W] !== void 0 ? w[W] : k[W], H = oy(ne), le = W === E ? F.isActive : null;
      le === !1 && ($ = K);
      let re = ne === k[W] && ne !== w[W] && H;
      if (re && c && n.manuallyAnimateOnMount && (re = !1), F.protectedKeys = { ...L }, // If it isn't active and hasn't *just* been set as inactive
      !F.isActive && le === null || // If we didn't and don't have any defined prop for this animation type
      !ne && !F.prevProp || // Or if the prop doesn't define an animation
      LS(ne) || typeof ne == "boolean")
        continue;
      let Fe = BY(F.prevProp, ne) || // If we're making this variant active, we want to always make it active
      W === E && F.isActive && !re && H || // If we removed a higher-priority variant (i is in reverse order)
      K > $ && H, ot = !1;
      const vt = Array.isArray(ne) ? ne : [ne];
      let Rt = vt.reduce(p, {});
      le === !1 && (Rt = {});
      const { prevResolvedValues: $e = {} } = F, Be = {
        ...$e,
        ...Rt
      }, jt = (tt) => {
        Fe = !0, A.has(tt) && (ot = !0, A.delete(tt)), F.needsAnimating[tt] = !0;
      };
      for (const tt in Be) {
        const Lt = Rt[tt], he = $e[tt];
        if (L.hasOwnProperty(tt))
          continue;
        let Ce = !1;
        cS(Lt) && cS(he) ? Ce = !dz(Lt, he) : Ce = Lt !== he, Ce ? Lt !== void 0 ? jt(tt) : A.add(tt) : Lt !== void 0 && A.has(tt) ? jt(tt) : F.protectedKeys[tt] = !0;
      }
      F.prevProp = ne, F.prevResolvedValues = Rt, F.isActive && (L = { ...L, ...Rt }), c && n.blockInitialAnimation && (Fe = !1), Fe && (!re || ot) && _.push(...vt.map((tt) => ({
        animation: tt,
        options: { type: W, ...x }
      })));
    }
    if (A.size) {
      const K = {};
      A.forEach((W) => {
        const F = n.getBaseTarget(W);
        F !== void 0 && (K[W] = F);
      }), _.push({ animation: K });
    }
    let Y = !!_.length;
    return c && (w.initial === !1 || w.initial === w.animate) && !n.manuallyAnimateOnMount && (Y = !1), c = !1, Y ? a(_) : Promise.resolve();
  }
  function b(x, E, w) {
    var k;
    if (s[x].isActive === E)
      return Promise.resolve();
    (k = n.variantChildren) === null || k === void 0 || k.forEach((A) => {
      var L;
      return (L = A.animationState) === null || L === void 0 ? void 0 : L.setActive(x, E);
    }), s[x].isActive = E;
    const _ = h(w, x);
    for (const A in s)
      s[A].protectedKeys = {};
    return _;
  }
  return {
    animateChanges: h,
    setActive: b,
    setAnimateFunction: v,
    getState: () => s
  };
}
function BY(n, a) {
  return typeof a == "string" ? a !== n : Array.isArray(a) ? !dz(a, n) : !1;
}
function wf(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function UY() {
  return {
    animate: wf(!0),
    whileInView: wf(),
    whileHover: wf(),
    whileTap: wf(),
    whileDrag: wf(),
    whileFocus: wf(),
    exit: wf()
  };
}
class IY extends vc {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(a) {
    super(a), a.animationState || (a.animationState = jY(a));
  }
  updateAnimationControlsSubscription() {
    const { animate: a } = this.node.getProps();
    this.unmount(), LS(a) && (this.unmount = a.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: a } = this.node.getProps(), { animate: s } = this.node.prevProps || {};
    a !== s && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let HY = 0;
class WY extends vc {
  constructor() {
    super(...arguments), this.id = HY++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: a, onExitComplete: s, custom: c } = this.node.presenceContext, { isPresent: p } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || a === p)
      return;
    const v = this.node.animationState.setActive("exit", !a, { custom: c ?? this.node.getProps().custom });
    s && !a && v.then(() => s(this.id));
  }
  mount() {
    const { register: a } = this.node.presenceContext || {};
    a && (this.unmount = a(this.id));
  }
  unmount() {
  }
}
const YY = {
  animation: {
    Feature: IY
  },
  exit: {
    Feature: WY
  }
}, gA = (n, a) => Math.abs(n - a);
function GY(n, a) {
  const s = gA(n.x, a.x), c = gA(n.y, a.y);
  return Math.sqrt(s ** 2 + c ** 2);
}
class Hz {
  constructor(a, s, { transformPagePoint: c, contextWindow: p, dragSnapToOrigin: v = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const k = GE(this.lastMoveEventInfo, this.history), _ = this.startEvent !== null, A = GY(k.offset, { x: 0, y: 0 }) >= 3;
      if (!_ && !A)
        return;
      const { point: L } = k, { timestamp: $ } = va;
      this.history.push({ ...L, timestamp: $ });
      const { onStart: Y, onMove: K } = this.handlers;
      _ || (Y && Y(this.lastMoveEvent, k), this.startEvent = this.lastMoveEvent), K && K(this.lastMoveEvent, k);
    }, this.handlePointerMove = (k, _) => {
      this.lastMoveEvent = k, this.lastMoveEventInfo = YE(_, this.transformPagePoint), Wn.update(this.updatePoint, !0);
    }, this.handlePointerUp = (k, _) => {
      this.end();
      const { onEnd: A, onSessionEnd: L, resumeAnimation: $ } = this.handlers;
      if (this.dragSnapToOrigin && $ && $(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const Y = GE(k.type === "pointercancel" ? this.lastMoveEventInfo : YE(_, this.transformPagePoint), this.history);
      this.startEvent && A && A(k, Y), L && L(k, Y);
    }, !sz(a))
      return;
    this.dragSnapToOrigin = v, this.handlers = s, this.transformPagePoint = c, this.contextWindow = p || window;
    const h = FS(a), b = YE(h, this.transformPagePoint), { point: x } = b, { timestamp: E } = va;
    this.history = [{ ...x, timestamp: E }];
    const { onSessionStart: w } = s;
    w && w(a, GE(b, this.history)), this.removeListeners = fc(Xl(this.contextWindow, "pointermove", this.handlePointerMove), Xl(this.contextWindow, "pointerup", this.handlePointerUp), Xl(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(a) {
    this.handlers = a;
  }
  end() {
    this.removeListeners && this.removeListeners(), eu(this.updatePoint);
  }
}
function YE(n, a) {
  return a ? { point: a(n.point) } : n;
}
function bA(n, a) {
  return { x: n.x - a.x, y: n.y - a.y };
}
function GE({ point: n }, a) {
  return {
    point: n,
    delta: bA(n, Wz(a)),
    offset: bA(n, qY(a)),
    velocity: QY(a, 0.1)
  };
}
function qY(n) {
  return n[0];
}
function Wz(n) {
  return n[n.length - 1];
}
function QY(n, a) {
  if (n.length < 2)
    return { x: 0, y: 0 };
  let s = n.length - 1, c = null;
  const p = Wz(n);
  for (; s >= 0 && (c = n[s], !(p.timestamp - c.timestamp > dc(a))); )
    s--;
  if (!c)
    return { x: 0, y: 0 };
  const v = Zl(p.timestamp - c.timestamp);
  if (v === 0)
    return { x: 0, y: 0 };
  const h = {
    x: (p.x - c.x) / v,
    y: (p.y - c.y) / v
  };
  return h.x === 1 / 0 && (h.x = 0), h.y === 1 / 0 && (h.y = 0), h;
}
function Xi(n) {
  return n.max - n.min;
}
function Rw(n, a = 0, s = 0.01) {
  return Math.abs(n - a) <= s;
}
function SA(n, a, s, c = 0.5) {
  n.origin = c, n.originPoint = Kn(a.min, a.max, n.origin), n.scale = Xi(s) / Xi(a), (Rw(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1), n.translate = Kn(s.min, s.max, n.origin) - n.originPoint, (Rw(n.translate) || isNaN(n.translate)) && (n.translate = 0);
}
function Kv(n, a, s, c) {
  SA(n.x, a.x, s.x, c ? c.originX : void 0), SA(n.y, a.y, s.y, c ? c.originY : void 0);
}
function xA(n, a, s) {
  n.min = s.min + a.min, n.max = n.min + Xi(a);
}
function KY(n, a, s) {
  xA(n.x, a.x, s.x), xA(n.y, a.y, s.y);
}
function CA(n, a, s) {
  n.min = a.min - s.min, n.max = n.min + Xi(a);
}
function Xv(n, a, s) {
  CA(n.x, a.x, s.x), CA(n.y, a.y, s.y);
}
function XY(n, { min: a, max: s }, c) {
  return a !== void 0 && n < a ? n = c ? Kn(a, n, c.min) : Math.max(n, a) : s !== void 0 && n > s && (n = c ? Kn(s, n, c.max) : Math.min(n, s)), n;
}
function EA(n, a, s) {
  return {
    min: a !== void 0 ? n.min + a : void 0,
    max: s !== void 0 ? n.max + s - (n.max - n.min) : void 0
  };
}
function ZY(n, { top: a, left: s, bottom: c, right: p }) {
  return {
    x: EA(n.x, s, p),
    y: EA(n.y, a, c)
  };
}
function wA(n, a) {
  let s = a.min - n.min, c = a.max - n.max;
  return a.max - a.min < n.max - n.min && ([s, c] = [c, s]), { min: s, max: c };
}
function JY(n, a) {
  return {
    x: wA(n.x, a.x),
    y: wA(n.y, a.y)
  };
}
function eG(n, a) {
  let s = 0.5;
  const c = Xi(n), p = Xi(a);
  return p > c ? s = ly(a.min, a.max - c, n.min) : c > p && (s = ly(n.min, n.max - p, a.min)), hc(0, 1, s);
}
function tG(n, a) {
  const s = {};
  return a.min !== void 0 && (s.min = a.min - n.min), a.max !== void 0 && (s.max = a.max - n.min), s;
}
const _w = 0.35;
function nG(n = _w) {
  return n === !1 ? n = 0 : n === !0 && (n = _w), {
    x: TA(n, "left", "right"),
    y: TA(n, "top", "bottom")
  };
}
function TA(n, a, s) {
  return {
    min: kA(n, a),
    max: kA(n, s)
  };
}
function kA(n, a) {
  return typeof n == "number" ? n : n[a] || 0;
}
const RA = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Wp = () => ({
  x: RA(),
  y: RA()
}), _A = () => ({ min: 0, max: 0 }), fr = () => ({
  x: _A(),
  y: _A()
});
function go(n) {
  return [n("x"), n("y")];
}
function Yz({ top: n, left: a, right: s, bottom: c }) {
  return {
    x: { min: a, max: s },
    y: { min: n, max: c }
  };
}
function rG({ x: n, y: a }) {
  return { top: a.min, right: n.max, bottom: a.max, left: n.min };
}
function aG(n, a) {
  if (!a)
    return n;
  const s = a({ x: n.left, y: n.top }), c = a({ x: n.right, y: n.bottom });
  return {
    top: s.y,
    left: s.x,
    bottom: c.y,
    right: c.x
  };
}
function qE(n) {
  return n === void 0 || n === 1;
}
function Dw({ scale: n, scaleX: a, scaleY: s }) {
  return !qE(n) || !qE(a) || !qE(s);
}
function Tf(n) {
  return Dw(n) || Gz(n) || n.z || n.rotate || n.rotateX || n.rotateY;
}
function Gz(n) {
  return DA(n.x) || DA(n.y);
}
function DA(n) {
  return n && n !== "0%";
}
function mS(n, a, s) {
  const c = n - s, p = a * c;
  return s + p;
}
function AA(n, a, s, c, p) {
  return p !== void 0 && (n = mS(n, p, c)), mS(n, s, c) + a;
}
function Aw(n, a = 0, s = 1, c, p) {
  n.min = AA(n.min, a, s, c, p), n.max = AA(n.max, a, s, c, p);
}
function qz(n, { x: a, y: s }) {
  Aw(n.x, a.translate, a.scale, a.originPoint), Aw(n.y, s.translate, s.scale, s.originPoint);
}
function iG(n, a, s, c = !1) {
  const p = s.length;
  if (!p)
    return;
  a.x = a.y = 1;
  let v, h;
  for (let b = 0; b < p; b++) {
    v = s[b], h = v.projectionDelta;
    const x = v.instance;
    x && x.style && x.style.display === "contents" || (c && v.options.layoutScroll && v.scroll && v !== v.root && Yp(n, {
      x: -v.scroll.offset.x,
      y: -v.scroll.offset.y
    }), h && (a.x *= h.x.scale, a.y *= h.y.scale, qz(n, h)), c && Tf(v.latestValues) && Yp(n, v.latestValues));
  }
  a.x = MA(a.x), a.y = MA(a.y);
}
function MA(n) {
  return Number.isInteger(n) || n > 1.0000000000001 || n < 0.999999999999 ? n : 1;
}
function lc(n, a) {
  n.min = n.min + a, n.max = n.max + a;
}
function OA(n, a, [s, c, p]) {
  const v = a[p] !== void 0 ? a[p] : 0.5, h = Kn(n.min, n.max, v);
  Aw(n, a[s], a[c], h, a.scale);
}
const oG = ["x", "scaleX", "originX"], sG = ["y", "scaleY", "originY"];
function Yp(n, a) {
  OA(n.x, a, oG), OA(n.y, a, sG);
}
function Qz(n, a) {
  return Yz(aG(n.getBoundingClientRect(), a));
}
function lG(n, a, s) {
  const c = Qz(n, s), { scroll: p } = a;
  return p && (lc(c.x, p.offset.x), lc(c.y, p.offset.y)), c;
}
const Kz = ({ current: n }) => n ? n.ownerDocument.defaultView : null, uG = /* @__PURE__ */ new WeakMap();
class cG {
  constructor(a) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = fr(), this.visualElement = a;
  }
  start(a, { snapToCursor: s = !1 } = {}) {
    const { presenceContext: c } = this.visualElement;
    if (c && c.isPresent === !1)
      return;
    const p = (w) => {
      const { dragSnapToOrigin: k } = this.getProps();
      k ? this.pauseAnimation() : this.stopAnimation(), s && this.snapToCursor(FS(w, "page").point);
    }, v = (w, k) => {
      const { drag: _, dragPropagation: A, onDragStart: L } = this.getProps();
      if (_ && !A && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = uz(_), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), go((Y) => {
        let K = this.getAxisMotionValue(Y).get() || 0;
        if (Qs.test(K)) {
          const { projection: W } = this.visualElement;
          if (W && W.layout) {
            const F = W.layout.layoutBox[Y];
            F && (K = Xi(F) * (parseFloat(K) / 100));
          }
        }
        this.originPoint[Y] = K;
      }), L && Wn.update(() => L(w, k), !1, !0);
      const { animationState: $ } = this.visualElement;
      $ && $.setActive("whileDrag", !0);
    }, h = (w, k) => {
      const { dragPropagation: _, dragDirectionLock: A, onDirectionLock: L, onDrag: $ } = this.getProps();
      if (!_ && !this.openGlobalLock)
        return;
      const { offset: Y } = k;
      if (A && this.currentDirection === null) {
        this.currentDirection = fG(Y), this.currentDirection !== null && L && L(this.currentDirection);
        return;
      }
      this.updateAxis("x", k.point, Y), this.updateAxis("y", k.point, Y), this.visualElement.render(), $ && $(w, k);
    }, b = (w, k) => this.stop(w, k), x = () => go((w) => {
      var k;
      return this.getAnimationState(w) === "paused" && ((k = this.getAxisMotionValue(w).animation) === null || k === void 0 ? void 0 : k.play());
    }), { dragSnapToOrigin: E } = this.getProps();
    this.panSession = new Hz(a, {
      onSessionStart: p,
      onStart: v,
      onMove: h,
      onSessionEnd: b,
      resumeAnimation: x
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: E,
      contextWindow: Kz(this.visualElement)
    });
  }
  stop(a, s) {
    const c = this.isDragging;
    if (this.cancel(), !c)
      return;
    const { velocity: p } = s;
    this.startAnimation(p);
    const { onDragEnd: v } = this.getProps();
    v && Wn.update(() => v(a, s));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: a, animationState: s } = this.visualElement;
    a && (a.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: c } = this.getProps();
    !c && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), s && s.setActive("whileDrag", !1);
  }
  updateAxis(a, s, c) {
    const { drag: p } = this.getProps();
    if (!c || !Rb(a, p, this.currentDirection))
      return;
    const v = this.getAxisMotionValue(a);
    let h = this.originPoint[a] + c[a];
    this.constraints && this.constraints[a] && (h = XY(h, this.constraints[a], this.elastic[a])), v.set(h);
  }
  resolveConstraints() {
    var a;
    const { dragConstraints: s, dragElastic: c } = this.getProps(), p = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (a = this.visualElement.projection) === null || a === void 0 ? void 0 : a.layout, v = this.constraints;
    s && Ip(s) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : s && p ? this.constraints = ZY(p.layoutBox, s) : this.constraints = !1, this.elastic = nG(c), v !== this.constraints && p && this.constraints && !this.hasMutatedConstraints && go((h) => {
      this.getAxisMotionValue(h) && (this.constraints[h] = tG(p.layoutBox[h], this.constraints[h]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: a, onMeasureDragConstraints: s } = this.getProps();
    if (!a || !Ip(a))
      return !1;
    const c = a.current;
    xo(c !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: p } = this.visualElement;
    if (!p || !p.layout)
      return !1;
    const v = lG(c, p.root, this.visualElement.getTransformPagePoint());
    let h = JY(p.layout.layoutBox, v);
    if (s) {
      const b = s(rG(h));
      this.hasMutatedConstraints = !!b, b && (h = Yz(b));
    }
    return h;
  }
  startAnimation(a) {
    const { drag: s, dragMomentum: c, dragElastic: p, dragTransition: v, dragSnapToOrigin: h, onDragTransitionEnd: b } = this.getProps(), x = this.constraints || {}, E = go((w) => {
      if (!Rb(w, s, this.currentDirection))
        return;
      let k = x && x[w] || {};
      h && (k = { min: 0, max: 0 });
      const _ = p ? 200 : 1e6, A = p ? 40 : 1e7, L = {
        type: "inertia",
        velocity: c ? a[w] : 0,
        bounceStiffness: _,
        bounceDamping: A,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...v,
        ...k
      };
      return this.startAxisValueAnimation(w, L);
    });
    return Promise.all(E).then(b);
  }
  startAxisValueAnimation(a, s) {
    const c = this.getAxisMotionValue(a);
    return c.start(kT(a, c, 0, s));
  }
  stopAnimation() {
    go((a) => this.getAxisMotionValue(a).stop());
  }
  pauseAnimation() {
    go((a) => {
      var s;
      return (s = this.getAxisMotionValue(a).animation) === null || s === void 0 ? void 0 : s.pause();
    });
  }
  getAnimationState(a) {
    var s;
    return (s = this.getAxisMotionValue(a).animation) === null || s === void 0 ? void 0 : s.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(a) {
    const s = "_drag" + a.toUpperCase(), c = this.visualElement.getProps(), p = c[s];
    return p || this.visualElement.getValue(a, (c.initial ? c.initial[a] : void 0) || 0);
  }
  snapToCursor(a) {
    go((s) => {
      const { drag: c } = this.getProps();
      if (!Rb(s, c, this.currentDirection))
        return;
      const { projection: p } = this.visualElement, v = this.getAxisMotionValue(s);
      if (p && p.layout) {
        const { min: h, max: b } = p.layout.layoutBox[s];
        v.set(a[s] - Kn(h, b, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: a, dragConstraints: s } = this.getProps(), { projection: c } = this.visualElement;
    if (!Ip(s) || !c || !this.constraints)
      return;
    this.stopAnimation();
    const p = { x: 0, y: 0 };
    go((h) => {
      const b = this.getAxisMotionValue(h);
      if (b) {
        const x = b.get();
        p[h] = eG({ min: x, max: x }, this.constraints[h]);
      }
    });
    const { transformTemplate: v } = this.visualElement.getProps();
    this.visualElement.current.style.transform = v ? v({}, "") : "none", c.root && c.root.updateScroll(), c.updateLayout(), this.resolveConstraints(), go((h) => {
      if (!Rb(h, a, null))
        return;
      const b = this.getAxisMotionValue(h), { min: x, max: E } = this.constraints[h];
      b.set(Kn(x, E, p[h]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    uG.set(this.visualElement, this);
    const a = this.visualElement.current, s = Xl(a, "pointerdown", (x) => {
      const { drag: E, dragListener: w = !0 } = this.getProps();
      E && w && this.start(x);
    }), c = () => {
      const { dragConstraints: x } = this.getProps();
      Ip(x) && (this.constraints = this.resolveRefConstraints());
    }, { projection: p } = this.visualElement, v = p.addEventListener("measure", c);
    p && !p.layout && (p.root && p.root.updateScroll(), p.updateLayout()), c();
    const h = Ql(window, "resize", () => this.scalePositionWithinConstraints()), b = p.addEventListener("didUpdate", ({ delta: x, hasLayoutChanged: E }) => {
      this.isDragging && E && (go((w) => {
        const k = this.getAxisMotionValue(w);
        k && (this.originPoint[w] += x[w].translate, k.set(k.get() + x[w].translate));
      }), this.visualElement.render());
    });
    return () => {
      h(), s(), v(), b && b();
    };
  }
  getProps() {
    const a = this.visualElement.getProps(), { drag: s = !1, dragDirectionLock: c = !1, dragPropagation: p = !1, dragConstraints: v = !1, dragElastic: h = _w, dragMomentum: b = !0 } = a;
    return {
      ...a,
      drag: s,
      dragDirectionLock: c,
      dragPropagation: p,
      dragConstraints: v,
      dragElastic: h,
      dragMomentum: b
    };
  }
}
function Rb(n, a, s) {
  return (a === !0 || a === n) && (s === null || s === n);
}
function fG(n, a = 10) {
  let s = null;
  return Math.abs(n.y) > a ? s = "y" : Math.abs(n.x) > a && (s = "x"), s;
}
class dG extends vc {
  constructor(a) {
    super(a), this.removeGroupControls = rr, this.removeListeners = rr, this.controls = new cG(a);
  }
  mount() {
    const { dragControls: a } = this.node.getProps();
    a && (this.removeGroupControls = a.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || rr;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const zA = (n) => (a, s) => {
  n && Wn.update(() => n(a, s));
};
class pG extends vc {
  constructor() {
    super(...arguments), this.removePointerDownListener = rr;
  }
  onPointerDown(a) {
    this.session = new Hz(a, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: Kz(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: a, onPanStart: s, onPan: c, onPanEnd: p } = this.node.getProps();
    return {
      onSessionStart: zA(a),
      onStart: zA(s),
      onMove: c,
      onEnd: (v, h) => {
        delete this.session, p && Wn.update(() => p(v, h));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Xl(this.node.current, "pointerdown", (a) => this.onPointerDown(a));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function hG() {
  const n = ar(py);
  if (n === null)
    return [!0, null];
  const { isPresent: a, onExitComplete: s, register: c } = n, p = Pw();
  return Qi(() => c(p), []), !a && s ? [!1, () => s && s(p)] : [!0];
}
function mG() {
  return vG(ar(py));
}
function vG(n) {
  return n === null ? !0 : n.isPresent;
}
const Qb = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function PA(n, a) {
  return a.max === a.min ? 0 : n / (a.max - a.min) * 100;
}
const Ov = {
  correct: (n, a) => {
    if (!a.target)
      return n;
    if (typeof n == "string")
      if (it.test(n))
        n = parseFloat(n);
      else
        return n;
    const s = PA(n, a.target.x), c = PA(n, a.target.y);
    return `${s}% ${c}%`;
  }
}, yG = {
  correct: (n, { treeScale: a, projectionDelta: s }) => {
    const c = n, p = mc.parse(n);
    if (p.length > 5)
      return c;
    const v = mc.createTransformer(n), h = typeof p[0] != "number" ? 1 : 0, b = s.x.scale * a.x, x = s.y.scale * a.y;
    p[0 + h] /= b, p[1 + h] /= x;
    const E = Kn(b, x, 0.5);
    return typeof p[2 + h] == "number" && (p[2 + h] /= E), typeof p[3 + h] == "number" && (p[3 + h] /= E), v(p);
  }
};
class gG extends qi.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: a, layoutGroup: s, switchLayoutGroup: c, layoutId: p } = this.props, { projection: v } = a;
    _7(bG), v && (s.group && s.group.add(v), c && c.register && p && c.register(v), v.root.didUpdate(), v.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), v.setOptions({
      ...v.options,
      onExitComplete: () => this.safeToRemove()
    })), Qb.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(a) {
    const { layoutDependency: s, visualElement: c, drag: p, isPresent: v } = this.props, h = c.projection;
    return h && (h.isPresent = v, p || a.layoutDependency !== s || s === void 0 ? h.willUpdate() : this.safeToRemove(), a.isPresent !== v && (v ? h.promote() : h.relegate() || Wn.postRender(() => {
      const b = h.getStack();
      (!b || !b.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: a } = this.props.visualElement;
    a && (a.root.didUpdate(), cT.postRender(() => {
      !a.currentAnimation && a.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: a, layoutGroup: s, switchLayoutGroup: c } = this.props, { projection: p } = a;
    p && (p.scheduleCheckAfterUnmount(), s && s.group && s.group.remove(p), c && c.deregister && c.deregister(p));
  }
  safeToRemove() {
    const { safeToRemove: a } = this.props;
    a && a();
  }
  render() {
    return null;
  }
}
function Xz(n) {
  const [a, s] = hG(), c = ar(pT);
  return qi.createElement(gG, { ...n, layoutGroup: c, switchLayoutGroup: ar(YO), isPresent: a, safeToRemove: s });
}
const bG = {
  borderRadius: {
    ...Ov,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ov,
  borderTopRightRadius: Ov,
  borderBottomLeftRadius: Ov,
  borderBottomRightRadius: Ov,
  boxShadow: yG
}, Zz = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], SG = Zz.length, LA = (n) => typeof n == "string" ? parseFloat(n) : n, $A = (n) => typeof n == "number" || it.test(n);
function xG(n, a, s, c, p, v) {
  p ? (n.opacity = Kn(
    0,
    // TODO Reinstate this if only child
    s.opacity !== void 0 ? s.opacity : 1,
    CG(c)
  ), n.opacityExit = Kn(a.opacity !== void 0 ? a.opacity : 1, 0, EG(c))) : v && (n.opacity = Kn(a.opacity !== void 0 ? a.opacity : 1, s.opacity !== void 0 ? s.opacity : 1, c));
  for (let h = 0; h < SG; h++) {
    const b = `border${Zz[h]}Radius`;
    let x = NA(a, b), E = NA(s, b);
    if (x === void 0 && E === void 0)
      continue;
    x || (x = 0), E || (E = 0), x === 0 || E === 0 || $A(x) === $A(E) ? (n[b] = Math.max(Kn(LA(x), LA(E), c), 0), (Qs.test(E) || Qs.test(x)) && (n[b] += "%")) : n[b] = E;
  }
  (a.rotate || s.rotate) && (n.rotate = Kn(a.rotate || 0, s.rotate || 0, c));
}
function NA(n, a) {
  return n[a] !== void 0 ? n[a] : n.borderRadius;
}
const CG = Jz(0, 0.5, xz), EG = Jz(0.5, 0.95, rr);
function Jz(n, a, s) {
  return (c) => c < n ? 0 : c > a ? 1 : s(ly(n, a, c));
}
function FA(n, a) {
  n.min = a.min, n.max = a.max;
}
function vo(n, a) {
  FA(n.x, a.x), FA(n.y, a.y);
}
function VA(n, a, s, c, p) {
  return n -= a, n = mS(n, 1 / s, c), p !== void 0 && (n = mS(n, 1 / p, c)), n;
}
function wG(n, a = 0, s = 1, c = 0.5, p, v = n, h = n) {
  if (Qs.test(a) && (a = parseFloat(a), a = Kn(h.min, h.max, a / 100) - h.min), typeof a != "number")
    return;
  let b = Kn(v.min, v.max, c);
  n === v && (b -= a), n.min = VA(n.min, a, s, b, p), n.max = VA(n.max, a, s, b, p);
}
function jA(n, a, [s, c, p], v, h) {
  wG(n, a[s], a[c], a[p], a.scale, v, h);
}
const TG = ["x", "scaleX", "originX"], kG = ["y", "scaleY", "originY"];
function BA(n, a, s, c) {
  jA(n.x, a, TG, s ? s.x : void 0, c ? c.x : void 0), jA(n.y, a, kG, s ? s.y : void 0, c ? c.y : void 0);
}
function UA(n) {
  return n.translate === 0 && n.scale === 1;
}
function eP(n) {
  return UA(n.x) && UA(n.y);
}
function RG(n, a) {
  return n.x.min === a.x.min && n.x.max === a.x.max && n.y.min === a.y.min && n.y.max === a.y.max;
}
function tP(n, a) {
  return Math.round(n.x.min) === Math.round(a.x.min) && Math.round(n.x.max) === Math.round(a.x.max) && Math.round(n.y.min) === Math.round(a.y.min) && Math.round(n.y.max) === Math.round(a.y.max);
}
function IA(n) {
  return Xi(n.x) / Xi(n.y);
}
class _G {
  constructor() {
    this.members = [];
  }
  add(a) {
    RT(this.members, a), a.scheduleRender();
  }
  remove(a) {
    if (_T(this.members, a), a === this.prevLead && (this.prevLead = void 0), a === this.lead) {
      const s = this.members[this.members.length - 1];
      s && this.promote(s);
    }
  }
  relegate(a) {
    const s = this.members.findIndex((p) => a === p);
    if (s === 0)
      return !1;
    let c;
    for (let p = s; p >= 0; p--) {
      const v = this.members[p];
      if (v.isPresent !== !1) {
        c = v;
        break;
      }
    }
    return c ? (this.promote(c), !0) : !1;
  }
  promote(a, s) {
    const c = this.lead;
    if (a !== c && (this.prevLead = c, this.lead = a, a.show(), c)) {
      c.instance && c.scheduleRender(), a.scheduleRender(), a.resumeFrom = c, s && (a.resumeFrom.preserveOpacity = !0), c.snapshot && (a.snapshot = c.snapshot, a.snapshot.latestValues = c.animationValues || c.latestValues), a.root && a.root.isUpdating && (a.isLayoutDirty = !0);
      const { crossfade: p } = a.options;
      p === !1 && c.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((a) => {
      const { options: s, resumingFrom: c } = a;
      s.onExitComplete && s.onExitComplete(), c && c.options.onExitComplete && c.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((a) => {
      a.instance && a.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function HA(n, a, s) {
  let c = "";
  const p = n.x.translate / a.x, v = n.y.translate / a.y;
  if ((p || v) && (c = `translate3d(${p}px, ${v}px, 0) `), (a.x !== 1 || a.y !== 1) && (c += `scale(${1 / a.x}, ${1 / a.y}) `), s) {
    const { rotate: x, rotateX: E, rotateY: w } = s;
    x && (c += `rotate(${x}deg) `), E && (c += `rotateX(${E}deg) `), w && (c += `rotateY(${w}deg) `);
  }
  const h = n.x.scale * a.x, b = n.y.scale * a.y;
  return (h !== 1 || b !== 1) && (c += `scale(${h}, ${b})`), c || "none";
}
const DG = (n, a) => n.depth - a.depth;
class AG {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(a) {
    RT(this.children, a), this.isDirty = !0;
  }
  remove(a) {
    _T(this.children, a), this.isDirty = !0;
  }
  forEach(a) {
    this.isDirty && this.children.sort(DG), this.isDirty = !1, this.children.forEach(a);
  }
}
function MG(n, a) {
  const s = Vf.now(), c = ({ timestamp: p }) => {
    const v = p - s;
    v >= a && (eu(c), n(v - a));
  };
  return Wn.read(c, !0), () => eu(c);
}
function OG(n) {
  window.MotionDebug && window.MotionDebug.record(n);
}
function zG(n) {
  return n instanceof SVGElement && n.tagName !== "svg";
}
function PG(n, a, s) {
  const c = Oi(n) ? n : uh(n);
  return c.start(kT("", c, a, s)), c.animation;
}
const WA = ["", "X", "Y", "Z"], LG = { visibility: "hidden" }, YA = 1e3;
let $G = 0;
const kf = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function nP({ attachResizeListener: n, defaultParent: a, measureScroll: s, checkIsScrollRoot: c, resetTransform: p }) {
  return class {
    constructor(h = {}, b = a == null ? void 0 : a()) {
      this.id = $G++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, kf.totalNodes = kf.resolvedTargetDeltas = kf.recalculatedProjection = 0, this.nodes.forEach(VG), this.nodes.forEach(HG), this.nodes.forEach(WG), this.nodes.forEach(jG), OG(kf);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = h, this.root = b ? b.root || b : this, this.path = b ? [...b.path, b] : [], this.parent = b, this.depth = b ? b.depth + 1 : 0;
      for (let x = 0; x < this.path.length; x++)
        this.path[x].shouldResetTransform = !0;
      this.root === this && (this.nodes = new AG());
    }
    addEventListener(h, b) {
      return this.eventHandlers.has(h) || this.eventHandlers.set(h, new DT()), this.eventHandlers.get(h).add(b);
    }
    notifyListeners(h, ...b) {
      const x = this.eventHandlers.get(h);
      x && x.notify(...b);
    }
    hasListeners(h) {
      return this.eventHandlers.has(h);
    }
    /**
     * Lifecycles
     */
    mount(h, b = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = zG(h), this.instance = h;
      const { layoutId: x, layout: E, visualElement: w } = this.options;
      if (w && !w.current && w.mount(h), this.root.nodes.add(this), this.parent && this.parent.children.add(this), b && (E || x) && (this.isLayoutDirty = !0), n) {
        let k;
        const _ = () => this.root.updateBlockedByResize = !1;
        n(h, () => {
          this.root.updateBlockedByResize = !0, k && k(), k = MG(_, 250), Qb.hasAnimatedSinceResize && (Qb.hasAnimatedSinceResize = !1, this.nodes.forEach(qA));
        });
      }
      x && this.root.registerSharedNode(x, this), this.options.animate !== !1 && w && (x || E) && this.addEventListener("didUpdate", ({ delta: k, hasLayoutChanged: _, hasRelativeTargetChanged: A, layout: L }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const $ = this.options.transition || w.getDefaultTransition() || KG, { onLayoutAnimationStart: Y, onLayoutAnimationComplete: K } = w.getProps(), W = !this.targetLayout || !tP(this.targetLayout, L) || A, F = !_ && A;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || F || _ && (W || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(k, F);
          const ne = {
            ...TT($, "layout"),
            onPlay: Y,
            onComplete: K
          };
          (w.shouldReduceMotion || this.options.layoutRoot) && (ne.delay = 0, ne.type = !1), this.startAnimation(ne);
        } else
          _ || qA(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = L;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const h = this.getStack();
      h && h.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, eu(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(YG), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: h } = this.options;
      return h && h.getProps().transformTemplate;
    }
    willUpdate(h = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let w = 0; w < this.path.length; w++) {
        const k = this.path[w];
        k.shouldResetTransform = !0, k.updateScroll("snapshot"), k.options.layoutRoot && k.willUpdate(!1);
      }
      const { layoutId: b, layout: x } = this.options;
      if (b === void 0 && !x)
        return;
      const E = this.getTransformTemplate();
      this.prevTransformTemplateValue = E ? E(this.latestValues, "") : void 0, this.updateSnapshot(), h && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(GA);
        return;
      }
      this.isUpdating || this.nodes.forEach(UG), this.isUpdating = !1, this.nodes.forEach(IG), this.nodes.forEach(NG), this.nodes.forEach(FG), this.clearAllSnapshots();
      const b = Vf.now();
      va.delta = hc(0, 1e3 / 60, b - va.timestamp), va.timestamp = b, va.isProcessing = !0, FE.update.process(va), FE.preRender.process(va), FE.render.process(va), va.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, cT.read(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(BG), this.sharedNodes.forEach(GG);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Wn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Wn.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let x = 0; x < this.path.length; x++)
          this.path[x].updateScroll();
      const h = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = fr(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: b } = this.options;
      b && b.notify("LayoutMeasure", this.layout.layoutBox, h ? h.layoutBox : void 0);
    }
    updateScroll(h = "measure") {
      let b = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === h && (b = !1), b && (this.scroll = {
        animationId: this.root.animationId,
        phase: h,
        isRoot: c(this.instance),
        offset: s(this.instance)
      });
    }
    resetTransform() {
      if (!p)
        return;
      const h = this.isLayoutDirty || this.shouldResetTransform, b = this.projectionDelta && !eP(this.projectionDelta), x = this.getTransformTemplate(), E = x ? x(this.latestValues, "") : void 0, w = E !== this.prevTransformTemplateValue;
      h && (b || Tf(this.latestValues) || w) && (p(this.instance, E), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(h = !0) {
      const b = this.measurePageBox();
      let x = this.removeElementScroll(b);
      return h && (x = this.removeTransform(x)), XG(x), {
        animationId: this.root.animationId,
        measuredBox: b,
        layoutBox: x,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: h } = this.options;
      if (!h)
        return fr();
      const b = h.measureViewportBox(), { scroll: x } = this.root;
      return x && (lc(b.x, x.offset.x), lc(b.y, x.offset.y)), b;
    }
    removeElementScroll(h) {
      const b = fr();
      vo(b, h);
      for (let x = 0; x < this.path.length; x++) {
        const E = this.path[x], { scroll: w, options: k } = E;
        if (E !== this.root && w && k.layoutScroll) {
          if (w.isRoot) {
            vo(b, h);
            const { scroll: _ } = this.root;
            _ && (lc(b.x, -_.offset.x), lc(b.y, -_.offset.y));
          }
          lc(b.x, w.offset.x), lc(b.y, w.offset.y);
        }
      }
      return b;
    }
    applyTransform(h, b = !1) {
      const x = fr();
      vo(x, h);
      for (let E = 0; E < this.path.length; E++) {
        const w = this.path[E];
        !b && w.options.layoutScroll && w.scroll && w !== w.root && Yp(x, {
          x: -w.scroll.offset.x,
          y: -w.scroll.offset.y
        }), Tf(w.latestValues) && Yp(x, w.latestValues);
      }
      return Tf(this.latestValues) && Yp(x, this.latestValues), x;
    }
    removeTransform(h) {
      const b = fr();
      vo(b, h);
      for (let x = 0; x < this.path.length; x++) {
        const E = this.path[x];
        if (!E.instance || !Tf(E.latestValues))
          continue;
        Dw(E.latestValues) && E.updateSnapshot();
        const w = fr(), k = E.measurePageBox();
        vo(w, k), BA(b, E.latestValues, E.snapshot ? E.snapshot.layoutBox : void 0, w);
      }
      return Tf(this.latestValues) && BA(b, this.latestValues), b;
    }
    setTargetDelta(h) {
      this.targetDelta = h, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(h) {
      this.options = {
        ...this.options,
        ...h,
        crossfade: h.crossfade !== void 0 ? h.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== va.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(h = !1) {
      var b;
      const x = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = x.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = x.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = x.isSharedProjectionDirty);
      const E = !!this.resumingFrom || this !== x;
      if (!(h || E && this.isSharedProjectionDirty || this.isProjectionDirty || !((b = this.parent) === null || b === void 0) && b.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: k, layoutId: _ } = this.options;
      if (!(!this.layout || !(k || _))) {
        if (this.resolvedRelativeTargetAt = va.timestamp, !this.targetDelta && !this.relativeTarget) {
          const A = this.getClosestProjectingParent();
          A && A.layout && this.animationProgress !== 1 ? (this.relativeParent = A, this.forceRelativeParentToResolveTarget(), this.relativeTarget = fr(), this.relativeTargetOrigin = fr(), Xv(this.relativeTargetOrigin, this.layout.layoutBox, A.layout.layoutBox), vo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = fr(), this.targetWithTransforms = fr()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), KY(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : vo(this.target, this.layout.layoutBox), qz(this.target, this.targetDelta)) : vo(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const A = this.getClosestProjectingParent();
            A && !!A.resumingFrom == !!this.resumingFrom && !A.options.layoutScroll && A.target && this.animationProgress !== 1 ? (this.relativeParent = A, this.forceRelativeParentToResolveTarget(), this.relativeTarget = fr(), this.relativeTargetOrigin = fr(), Xv(this.relativeTargetOrigin, this.target, A.target), vo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          kf.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Dw(this.parent.latestValues) || Gz(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var h;
      const b = this.getLead(), x = !!this.resumingFrom || this !== b;
      let E = !0;
      if ((this.isProjectionDirty || !((h = this.parent) === null || h === void 0) && h.isProjectionDirty) && (E = !1), x && (this.isSharedProjectionDirty || this.isTransformDirty) && (E = !1), this.resolvedRelativeTargetAt === va.timestamp && (E = !1), E)
        return;
      const { layout: w, layoutId: k } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(w || k))
        return;
      vo(this.layoutCorrected, this.layout.layoutBox);
      const _ = this.treeScale.x, A = this.treeScale.y;
      iG(this.layoutCorrected, this.treeScale, this.path, x), b.layout && !b.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (b.target = b.layout.layoutBox, b.targetWithTransforms = fr());
      const { target: L } = b;
      if (!L) {
        this.projectionTransform && (this.projectionDelta = Wp(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = Wp(), this.projectionDeltaWithTransform = Wp());
      const $ = this.projectionTransform;
      Kv(this.projectionDelta, this.layoutCorrected, L, this.latestValues), this.projectionTransform = HA(this.projectionDelta, this.treeScale), (this.projectionTransform !== $ || this.treeScale.x !== _ || this.treeScale.y !== A) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", L)), kf.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(h = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), h) {
        const b = this.getStack();
        b && b.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(h, b = !1) {
      const x = this.snapshot, E = x ? x.latestValues : {}, w = { ...this.latestValues }, k = Wp();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !b;
      const _ = fr(), A = x ? x.source : void 0, L = this.layout ? this.layout.source : void 0, $ = A !== L, Y = this.getStack(), K = !Y || Y.members.length <= 1, W = !!($ && !K && this.options.crossfade === !0 && !this.path.some(QG));
      this.animationProgress = 0;
      let F;
      this.mixTargetDelta = (ne) => {
        const H = ne / 1e3;
        QA(k.x, h.x, H), QA(k.y, h.y, H), this.setTargetDelta(k), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Xv(_, this.layout.layoutBox, this.relativeParent.layout.layoutBox), qG(this.relativeTarget, this.relativeTargetOrigin, _, H), F && RG(this.relativeTarget, F) && (this.isProjectionDirty = !1), F || (F = fr()), vo(F, this.relativeTarget)), $ && (this.animationValues = w, xG(w, E, this.latestValues, H, W, K)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = H;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(h) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (eu(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Wn.update(() => {
        Qb.hasAnimatedSinceResize = !0, this.currentAnimation = PG(0, YA, {
          ...h,
          onUpdate: (b) => {
            this.mixTargetDelta(b), h.onUpdate && h.onUpdate(b);
          },
          onComplete: () => {
            h.onComplete && h.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const h = this.getStack();
      h && h.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(YA), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const h = this.getLead();
      let { targetWithTransforms: b, target: x, layout: E, latestValues: w } = h;
      if (!(!b || !x || !E)) {
        if (this !== h && this.layout && E && rP(this.options.animationType, this.layout.layoutBox, E.layoutBox)) {
          x = this.target || fr();
          const k = Xi(this.layout.layoutBox.x);
          x.x.min = h.target.x.min, x.x.max = x.x.min + k;
          const _ = Xi(this.layout.layoutBox.y);
          x.y.min = h.target.y.min, x.y.max = x.y.min + _;
        }
        vo(b, x), Yp(b, w), Kv(this.projectionDeltaWithTransform, this.layoutCorrected, b, w);
      }
    }
    registerSharedNode(h, b) {
      this.sharedNodes.has(h) || this.sharedNodes.set(h, new _G()), this.sharedNodes.get(h).add(b);
      const E = b.options.initialPromotionConfig;
      b.promote({
        transition: E ? E.transition : void 0,
        preserveFollowOpacity: E && E.shouldPreserveFollowOpacity ? E.shouldPreserveFollowOpacity(b) : void 0
      });
    }
    isLead() {
      const h = this.getStack();
      return h ? h.lead === this : !0;
    }
    getLead() {
      var h;
      const { layoutId: b } = this.options;
      return b ? ((h = this.getStack()) === null || h === void 0 ? void 0 : h.lead) || this : this;
    }
    getPrevLead() {
      var h;
      const { layoutId: b } = this.options;
      return b ? (h = this.getStack()) === null || h === void 0 ? void 0 : h.prevLead : void 0;
    }
    getStack() {
      const { layoutId: h } = this.options;
      if (h)
        return this.root.sharedNodes.get(h);
    }
    promote({ needsReset: h, transition: b, preserveFollowOpacity: x } = {}) {
      const E = this.getStack();
      E && E.promote(this, x), h && (this.projectionDelta = void 0, this.needsReset = !0), b && this.setOptions({ transition: b });
    }
    relegate() {
      const h = this.getStack();
      return h ? h.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: h } = this.options;
      if (!h)
        return;
      let b = !1;
      const { latestValues: x } = h;
      if ((x.rotate || x.rotateX || x.rotateY || x.rotateZ) && (b = !0), !b)
        return;
      const E = {};
      for (let w = 0; w < WA.length; w++) {
        const k = "rotate" + WA[w];
        x[k] && (E[k] = x[k], h.setStaticValue(k, 0));
      }
      h.render();
      for (const w in E)
        h.setStaticValue(w, E[w]);
      h.scheduleRender();
    }
    getProjectionStyles(h) {
      var b, x;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return LG;
      const E = {
        visibility: ""
      }, w = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, E.opacity = "", E.pointerEvents = Gb(h == null ? void 0 : h.pointerEvents) || "", E.transform = w ? w(this.latestValues, "") : "none", E;
      const k = this.getLead();
      if (!this.projectionDelta || !this.layout || !k.target) {
        const $ = {};
        return this.options.layoutId && ($.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, $.pointerEvents = Gb(h == null ? void 0 : h.pointerEvents) || ""), this.hasProjected && !Tf(this.latestValues) && ($.transform = w ? w({}, "") : "none", this.hasProjected = !1), $;
      }
      const _ = k.animationValues || k.latestValues;
      this.applyTransformsToTarget(), E.transform = HA(this.projectionDeltaWithTransform, this.treeScale, _), w && (E.transform = w(_, E.transform));
      const { x: A, y: L } = this.projectionDelta;
      E.transformOrigin = `${A.origin * 100}% ${L.origin * 100}% 0`, k.animationValues ? E.opacity = k === this ? (x = (b = _.opacity) !== null && b !== void 0 ? b : this.latestValues.opacity) !== null && x !== void 0 ? x : 1 : this.preserveOpacity ? this.latestValues.opacity : _.opacityExit : E.opacity = k === this ? _.opacity !== void 0 ? _.opacity : "" : _.opacityExit !== void 0 ? _.opacityExit : 0;
      for (const $ in lS) {
        if (_[$] === void 0)
          continue;
        const { correct: Y, applyTo: K } = lS[$], W = E.transform === "none" ? _[$] : Y(_[$], k);
        if (K) {
          const F = K.length;
          for (let ne = 0; ne < F; ne++)
            E[K[ne]] = W;
        } else
          E[$] = W;
      }
      return this.options.layoutId && (E.pointerEvents = k === this ? Gb(h == null ? void 0 : h.pointerEvents) || "" : "none"), E;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((h) => {
        var b;
        return (b = h.currentAnimation) === null || b === void 0 ? void 0 : b.stop();
      }), this.root.nodes.forEach(GA), this.root.sharedNodes.clear();
    }
  };
}
function NG(n) {
  n.updateLayout();
}
function FG(n) {
  var a;
  const s = ((a = n.resumeFrom) === null || a === void 0 ? void 0 : a.snapshot) || n.snapshot;
  if (n.isLead() && n.layout && s && n.hasListeners("didUpdate")) {
    const { layoutBox: c, measuredBox: p } = n.layout, { animationType: v } = n.options, h = s.source !== n.layout.source;
    v === "size" ? go((k) => {
      const _ = h ? s.measuredBox[k] : s.layoutBox[k], A = Xi(_);
      _.min = c[k].min, _.max = _.min + A;
    }) : rP(v, s.layoutBox, c) && go((k) => {
      const _ = h ? s.measuredBox[k] : s.layoutBox[k], A = Xi(c[k]);
      _.max = _.min + A, n.relativeTarget && !n.currentAnimation && (n.isProjectionDirty = !0, n.relativeTarget[k].max = n.relativeTarget[k].min + A);
    });
    const b = Wp();
    Kv(b, c, s.layoutBox);
    const x = Wp();
    h ? Kv(x, n.applyTransform(p, !0), s.measuredBox) : Kv(x, c, s.layoutBox);
    const E = !eP(b);
    let w = !1;
    if (!n.resumeFrom) {
      const k = n.getClosestProjectingParent();
      if (k && !k.resumeFrom) {
        const { snapshot: _, layout: A } = k;
        if (_ && A) {
          const L = fr();
          Xv(L, s.layoutBox, _.layoutBox);
          const $ = fr();
          Xv($, c, A.layoutBox), tP(L, $) || (w = !0), k.options.layoutRoot && (n.relativeTarget = $, n.relativeTargetOrigin = L, n.relativeParent = k);
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: c,
      snapshot: s,
      delta: x,
      layoutDelta: b,
      hasLayoutChanged: E,
      hasRelativeTargetChanged: w
    });
  } else if (n.isLead()) {
    const { onExitComplete: c } = n.options;
    c && c();
  }
  n.options.transition = void 0;
}
function VG(n) {
  kf.totalNodes++, n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = !!(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function jG(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function BG(n) {
  n.clearSnapshot();
}
function GA(n) {
  n.clearMeasurements();
}
function UG(n) {
  n.isLayoutDirty = !1;
}
function IG(n) {
  const { visualElement: a } = n.options;
  a && a.getProps().onBeforeLayoutMeasure && a.notify("BeforeLayoutMeasure"), n.resetTransform();
}
function qA(n) {
  n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0, n.isProjectionDirty = !0;
}
function HG(n) {
  n.resolveTargetDelta();
}
function WG(n) {
  n.calcProjection();
}
function YG(n) {
  n.resetRotation();
}
function GG(n) {
  n.removeLeadSnapshot();
}
function QA(n, a, s) {
  n.translate = Kn(a.translate, 0, s), n.scale = Kn(a.scale, 1, s), n.origin = a.origin, n.originPoint = a.originPoint;
}
function KA(n, a, s, c) {
  n.min = Kn(a.min, s.min, c), n.max = Kn(a.max, s.max, c);
}
function qG(n, a, s, c) {
  KA(n.x, a.x, s.x, c), KA(n.y, a.y, s.y, c);
}
function QG(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const KG = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, XA = (n) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(n), ZA = XA("applewebkit/") && !XA("chrome/") ? Math.round : rr;
function JA(n) {
  n.min = ZA(n.min), n.max = ZA(n.max);
}
function XG(n) {
  JA(n.x), JA(n.y);
}
function rP(n, a, s) {
  return n === "position" || n === "preserve-aspect" && !Rw(IA(a), IA(s), 0.2);
}
const ZG = nP({
  attachResizeListener: (n, a) => Ql(n, "resize", a),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), QE = {
  current: void 0
}, aP = nP({
  measureScroll: (n) => ({
    x: n.scrollLeft,
    y: n.scrollTop
  }),
  defaultParent: () => {
    if (!QE.current) {
      const n = new ZG({});
      n.mount(window), n.setOptions({ layoutScroll: !0 }), QE.current = n;
    }
    return QE.current;
  },
  resetTransform: (n, a) => {
    n.style.transform = a !== void 0 ? a : "none";
  },
  checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed"
}), JG = {
  pan: {
    Feature: pG
  },
  drag: {
    Feature: dG,
    ProjectionNode: aP,
    MeasureLayout: Xz
  }
}, eq = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function tq(n) {
  const a = eq.exec(n);
  if (!a)
    return [,];
  const [, s, c] = a;
  return [s, c];
}
const nq = 4;
function Mw(n, a, s = 1) {
  xo(s <= nq, `Max CSS variable fallback depth detected in property "${n}". This may indicate a circular fallback dependency.`);
  const [c, p] = tq(n);
  if (!c)
    return;
  const v = window.getComputedStyle(a).getPropertyValue(c);
  if (v) {
    const h = v.trim();
    return jz(h) ? parseFloat(h) : h;
  } else
    return Sw(p) ? Mw(p, a, s + 1) : p;
}
function rq(n, { ...a }, s) {
  const c = n.current;
  if (!(c instanceof Element))
    return { target: a, transitionEnd: s };
  s && (s = { ...s }), n.values.forEach((p) => {
    const v = p.get();
    if (!Sw(v))
      return;
    const h = Mw(v, c);
    h && p.set(h);
  });
  for (const p in a) {
    const v = a[p];
    if (!Sw(v))
      continue;
    const h = Mw(v, c);
    h && (a[p] = h, s || (s = {}), s[p] === void 0 && (s[p] = v));
  }
  return { target: a, transitionEnd: s };
}
const aq = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), iP = (n) => aq.has(n), iq = (n) => Object.keys(n).some(iP), _b = (n) => n === If || n === it, eM = (n, a) => parseFloat(n.split(", ")[a]), tM = (n, a) => (s, { transform: c }) => {
  if (c === "none" || !c)
    return 0;
  const p = c.match(/^matrix3d\((.+)\)$/);
  if (p)
    return eM(p[1], a);
  {
    const v = c.match(/^matrix\((.+)\)$/);
    return v ? eM(v[1], n) : 0;
  }
}, oq = /* @__PURE__ */ new Set(["x", "y", "z"]), sq = hy.filter((n) => !oq.has(n));
function lq(n) {
  const a = [];
  return sq.forEach((s) => {
    const c = n.getValue(s);
    c !== void 0 && (a.push([s, c.get()]), c.set(s.startsWith("scale") ? 1 : 0));
  }), a.length && n.render(), a;
}
const ch = {
  // Dimensions
  width: ({ x: n }, { paddingLeft: a = "0", paddingRight: s = "0" }) => n.max - n.min - parseFloat(a) - parseFloat(s),
  height: ({ y: n }, { paddingTop: a = "0", paddingBottom: s = "0" }) => n.max - n.min - parseFloat(a) - parseFloat(s),
  top: (n, { top: a }) => parseFloat(a),
  left: (n, { left: a }) => parseFloat(a),
  bottom: ({ y: n }, { top: a }) => parseFloat(a) + (n.max - n.min),
  right: ({ x: n }, { left: a }) => parseFloat(a) + (n.max - n.min),
  // Transform
  x: tM(4, 13),
  y: tM(5, 14)
};
ch.translateX = ch.x;
ch.translateY = ch.y;
const uq = (n, a, s) => {
  const c = a.measureViewportBox(), p = a.current, v = getComputedStyle(p), { display: h } = v, b = {};
  h === "none" && a.setStaticValue("display", n.display || "block"), s.forEach((E) => {
    b[E] = ch[E](c, v);
  }), a.render();
  const x = a.measureViewportBox();
  return s.forEach((E) => {
    const w = a.getValue(E);
    w && w.jump(b[E]), n[E] = ch[E](x, v);
  }), n;
}, cq = (n, a, s = {}, c = {}) => {
  a = { ...a }, c = { ...c };
  const p = Object.keys(a).filter(iP);
  let v = [], h = !1;
  const b = [];
  if (p.forEach((x) => {
    const E = n.getValue(x);
    if (!n.hasValue(x))
      return;
    let w = s[x], k = Mv(w);
    const _ = a[x];
    let A;
    if (cS(_)) {
      const L = _.length, $ = _[0] === null ? 1 : 0;
      w = _[$], k = Mv(w);
      for (let Y = $; Y < L && _[Y] !== null; Y++)
        A ? xo(Mv(_[Y]) === A, "All keyframes must be of the same type") : (A = Mv(_[Y]), xo(A === k || _b(k) && _b(A), "Keyframes must be of the same dimension as the current value"));
    } else
      A = Mv(_);
    if (k !== A)
      if (_b(k) && _b(A)) {
        const L = E.get();
        typeof L == "string" && E.set(parseFloat(L)), typeof _ == "string" ? a[x] = parseFloat(_) : Array.isArray(_) && A === it && (a[x] = _.map(parseFloat));
      } else
        k != null && k.transform && (A != null && A.transform) && (w === 0 || _ === 0) ? w === 0 ? E.set(A.transform(w)) : a[x] = k.transform(_) : (h || (v = lq(n), h = !0), b.push(x), c[x] = c[x] !== void 0 ? c[x] : a[x], E.jump(_));
  }), b.length) {
    const x = b.indexOf("height") >= 0 ? window.pageYOffset : null, E = uq(a, n, b);
    return v.length && v.forEach(([w, k]) => {
      n.getValue(w).set(k);
    }), n.render(), PS && x !== null && window.scrollTo({ top: x }), { target: E, transitionEnd: c };
  } else
    return { target: a, transitionEnd: c };
};
function fq(n, a, s, c) {
  return iq(a) ? cq(n, a, s, c) : { target: a, transitionEnd: c };
}
const dq = (n, a, s, c) => {
  const p = rq(n, a, c);
  return a = p.target, c = p.transitionEnd, fq(n, a, s, c);
}, Ow = { current: null }, oP = { current: !1 };
function pq() {
  if (oP.current = !0, !!PS)
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"), a = () => Ow.current = n.matches;
      n.addListener(a), a();
    } else
      Ow.current = !1;
}
function hq(n, a, s) {
  const { willChange: c } = a;
  for (const p in a) {
    const v = a[p], h = s[p];
    if (Oi(v))
      n.addValue(p, v), hS(c) && c.add(p), process.env.NODE_ENV === "development" && AT(v.version === "11.0.3", `Attempting to mix Framer Motion versions ${v.version} with 11.0.3 may not work as expected.`);
    else if (Oi(h))
      n.addValue(p, uh(v, { owner: n })), hS(c) && c.remove(p);
    else if (h !== v)
      if (n.hasValue(p)) {
        const b = n.getValue(p);
        !b.hasAnimated && b.set(v);
      } else {
        const b = n.getStaticValue(p);
        n.addValue(p, uh(b !== void 0 ? b : v, { owner: n }));
      }
  }
  for (const p in s)
    a[p] === void 0 && n.removeValue(p);
  return a;
}
const nM = /* @__PURE__ */ new WeakMap(), sP = Object.keys(sy), mq = sP.length, rM = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], vq = dT.length;
class yq {
  constructor({ parent: a, props: s, presenceContext: c, reducedMotionConfig: p, visualState: v }, h = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => Wn.render(this.render, !1, !0);
    const { latestValues: b, renderState: x } = v;
    this.latestValues = b, this.baseTarget = { ...b }, this.initialValues = s.initial ? { ...b } : {}, this.renderState = x, this.parent = a, this.props = s, this.presenceContext = c, this.depth = a ? a.depth + 1 : 0, this.reducedMotionConfig = p, this.options = h, this.isControllingVariants = $S(s), this.isVariantNode = WO(s), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(a && a.current);
    const { willChange: E, ...w } = this.scrapeMotionValuesFromProps(s, {});
    for (const k in w) {
      const _ = w[k];
      b[k] !== void 0 && Oi(_) && (_.set(b[k], !1), hS(E) && E.add(k));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(a, s) {
    return {};
  }
  mount(a) {
    this.current = a, nM.set(a, this), this.projection && !this.projection.instance && this.projection.mount(a), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((s, c) => this.bindToMotionValue(c, s)), oP.current || pq(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Ow.current, process.env.NODE_ENV !== "production" && AT(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    nM.delete(this.current), this.projection && this.projection.unmount(), eu(this.notifyUpdate), eu(this.render), this.valueSubscriptions.forEach((a) => a()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const a in this.events)
      this.events[a].clear();
    for (const a in this.features)
      this.features[a].unmount();
    this.current = null;
  }
  bindToMotionValue(a, s) {
    const c = Uf.has(a), p = s.on("change", (h) => {
      this.latestValues[a] = h, this.props.onUpdate && Wn.update(this.notifyUpdate, !1, !0), c && this.projection && (this.projection.isTransformDirty = !0);
    }), v = s.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(a, () => {
      p(), v();
    });
  }
  sortNodePosition(a) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== a.type ? 0 : this.sortInstanceNodePosition(this.current, a.current);
  }
  loadFeatures({ children: a, ...s }, c, p, v) {
    let h, b;
    if (process.env.NODE_ENV !== "production" && p && c) {
      const x = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      s.ignoreStrict ? yy(!1, x) : xo(!1, x);
    }
    for (let x = 0; x < mq; x++) {
      const E = sP[x], { isEnabled: w, Feature: k, ProjectionNode: _, MeasureLayout: A } = sy[E];
      _ && (h = _), w(s) && (!this.features[E] && k && (this.features[E] = new k(this)), A && (b = A));
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && h) {
      this.projection = new h(this.latestValues, this.parent && this.parent.projection);
      const { layoutId: x, layout: E, drag: w, dragConstraints: k, layoutScroll: _, layoutRoot: A } = s;
      this.projection.setOptions({
        layoutId: x,
        layout: E,
        alwaysMeasureLayout: !!w || k && Ip(k),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof E == "string" ? E : "both",
        initialPromotionConfig: v,
        layoutScroll: _,
        layoutRoot: A
      });
    }
    return b;
  }
  updateFeatures() {
    for (const a in this.features) {
      const s = this.features[a];
      s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : fr();
  }
  getStaticValue(a) {
    return this.latestValues[a];
  }
  setStaticValue(a, s) {
    this.latestValues[a] = s;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(a, s = !0) {
    return this.makeTargetAnimatableFromInstance(a, s);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(a, s) {
    (a.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = a, this.prevPresenceContext = this.presenceContext, this.presenceContext = s;
    for (let c = 0; c < rM.length; c++) {
      const p = rM[c];
      this.propEventSubscriptions[p] && (this.propEventSubscriptions[p](), delete this.propEventSubscriptions[p]);
      const v = a["on" + p];
      v && (this.propEventSubscriptions[p] = this.on(p, v));
    }
    this.prevMotionValues = hq(this, this.scrapeMotionValuesFromProps(a, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(a) {
    return this.props.variants ? this.props.variants[a] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(a = !1) {
    if (a)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const c = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (c.initial = this.props.initial), c;
    }
    const s = {};
    for (let c = 0; c < vq; c++) {
      const p = dT[c], v = this.props[p];
      (oy(v) || v === !1) && (s[p] = v);
    }
    return s;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(a) {
    const s = this.getClosestVariantNode();
    if (s)
      return s.variantChildren && s.variantChildren.add(a), () => s.variantChildren.delete(a);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(a, s) {
    s !== this.values.get(a) && (this.removeValue(a), this.bindToMotionValue(a, s)), this.values.set(a, s), this.latestValues[a] = s.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(a) {
    this.values.delete(a);
    const s = this.valueSubscriptions.get(a);
    s && (s(), this.valueSubscriptions.delete(a)), delete this.latestValues[a], this.removeValueFromRenderState(a, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(a) {
    return this.values.has(a);
  }
  getValue(a, s) {
    if (this.props.values && this.props.values[a])
      return this.props.values[a];
    let c = this.values.get(a);
    return c === void 0 && s !== void 0 && (c = uh(s, { owner: this }), this.addValue(a, c)), c;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(a) {
    var s;
    return this.latestValues[a] !== void 0 || !this.current ? this.latestValues[a] : (s = this.getBaseTargetFromProps(this.props, a)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, a, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(a, s) {
    this.baseTarget[a] = s;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(a) {
    var s;
    const { initial: c } = this.props, p = typeof c == "string" || typeof c == "object" ? (s = ST(this.props, c)) === null || s === void 0 ? void 0 : s[a] : void 0;
    if (c && p !== void 0)
      return p;
    const v = this.getBaseTargetFromProps(this.props, a);
    return v !== void 0 && !Oi(v) ? v : this.initialValues[a] !== void 0 && p === void 0 ? void 0 : this.baseTarget[a];
  }
  on(a, s) {
    return this.events[a] || (this.events[a] = new DT()), this.events[a].add(s);
  }
  notify(a, ...s) {
    this.events[a] && this.events[a].notify(...s);
  }
}
class lP extends yq {
  sortInstanceNodePosition(a, s) {
    return a.compareDocumentPosition(s) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(a, s) {
    return a.style ? a.style[s] : void 0;
  }
  removeValueFromRenderState(a, { vars: s, style: c }) {
    delete s[a], delete c[a];
  }
  makeTargetAnimatableFromInstance({ transition: a, transitionEnd: s, ...c }, p) {
    const v = MY(c, a || {}, this);
    if (p) {
      DY(this, c, v);
      const h = dq(this, c, v, s);
      s = h.transitionEnd, c = h.target;
    }
    return {
      transition: a,
      transitionEnd: s,
      ...c
    };
  }
}
function gq(n) {
  return window.getComputedStyle(n);
}
class bq extends lP {
  constructor() {
    super(...arguments), this.type = "html";
  }
  readValueFromInstance(a, s) {
    if (Uf.has(s)) {
      const c = wT(s);
      return c && c.default || 0;
    } else {
      const c = gq(a), p = (QO(s) ? c.getPropertyValue(s) : c[s]) || 0;
      return typeof p == "string" ? p.trim() : p;
    }
  }
  measureInstanceViewportBox(a, { transformPagePoint: s }) {
    return Qz(a, s);
  }
  build(a, s, c, p) {
    mT(a, s, c, p.transformTemplate);
  }
  scrapeMotionValuesFromProps(a, s) {
    return bT(a, s);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: a } = this.props;
    Oi(a) && (this.childSubscription = a.on("change", (s) => {
      this.current && (this.current.textContent = `${s}`);
    }));
  }
  renderInstance(a, s, c, p) {
    tz(a, s, c, p);
  }
}
class Sq extends lP {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1;
  }
  getBaseTargetFromProps(a, s) {
    return a[s];
  }
  readValueFromInstance(a, s) {
    if (Uf.has(s)) {
      const c = wT(s);
      return c && c.default || 0;
    }
    return s = nz.has(s) ? s : uT(s), a.getAttribute(s);
  }
  measureInstanceViewportBox() {
    return fr();
  }
  scrapeMotionValuesFromProps(a, s) {
    return az(a, s);
  }
  build(a, s, c, p) {
    yT(a, s, c, this.isSVGTag, p.transformTemplate);
  }
  renderInstance(a, s, c, p) {
    rz(a, s, c, p);
  }
  mount(a) {
    this.isSVGTag = gT(a.tagName), super.mount(a);
  }
}
const xq = (n, a) => hT(n) ? new Sq(a, { enableHardwareAcceleration: !1 }) : new bq(a, { enableHardwareAcceleration: !0 }), Cq = {
  layout: {
    ProjectionNode: aP,
    MeasureLayout: Xz
  }
}, Eq = {
  ...YY,
  ...hW,
  ...JG,
  ...Cq
}, wq = /* @__PURE__ */ k7((n, a) => tW(n, a, Eq, xq));
function uP() {
  const n = ga(!1);
  return lT(() => (n.current = !0, () => {
    n.current = !1;
  }), []), n;
}
function Tq() {
  const n = uP(), [a, s] = jf(0), c = Zp(() => {
    n.current && s(a + 1);
  }, [a]);
  return [Zp(() => Wn.postRender(c), [c]), a];
}
class kq extends kt.Component {
  getSnapshotBeforeUpdate(a) {
    const s = this.props.childRef.current;
    if (s && a.isPresent && !this.props.isPresent) {
      const c = this.props.sizeRef.current;
      c.height = s.offsetHeight || 0, c.width = s.offsetWidth || 0, c.top = s.offsetTop, c.left = s.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Rq({ children: n, isPresent: a }) {
  const s = Pw(), c = ga(null), p = ga({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return uM(() => {
    const { width: v, height: h, top: b, left: x } = p.current;
    if (a || !c.current || !v || !h)
      return;
    c.current.dataset.motionPopId = s;
    const E = document.createElement("style");
    return document.head.appendChild(E), E.sheet && E.sheet.insertRule(`
          [data-motion-pop-id="${s}"] {
            position: absolute !important;
            width: ${v}px !important;
            height: ${h}px !important;
            top: ${b}px !important;
            left: ${x}px !important;
          }
        `), () => {
      document.head.removeChild(E);
    };
  }, [a]), kt.createElement(kq, { isPresent: a, childRef: c, sizeRef: p }, kt.cloneElement(n, { ref: c }));
}
const KE = ({ children: n, initial: a, isPresent: s, onExitComplete: c, custom: p, presenceAffectsLayout: v, mode: h }) => {
  const b = iz(_q), x = Pw(), E = Ki(
    () => ({
      id: x,
      initial: a,
      isPresent: s,
      custom: p,
      onExitComplete: (w) => {
        b.set(w, !0);
        for (const k of b.values())
          if (!k)
            return;
        c && c();
      },
      register: (w) => (b.set(w, !1), () => b.delete(w))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    v ? void 0 : [s]
  );
  return Ki(() => {
    b.forEach((w, k) => b.set(k, !1));
  }, [s]), kt.useEffect(() => {
    !s && !b.size && c && c();
  }, [s]), h === "popLayout" && (n = kt.createElement(Rq, { isPresent: s }, n)), kt.createElement(py.Provider, { value: E }, n);
};
function _q() {
  return /* @__PURE__ */ new Map();
}
function Dq(n) {
  return Qi(() => () => n(), []);
}
const Rf = (n) => n.key || "";
function Aq(n, a) {
  n.forEach((s) => {
    const c = Rf(s);
    a.set(c, s);
  });
}
function Mq(n) {
  const a = [];
  return i4.forEach(n, (s) => {
    o4(s) && a.push(s);
  }), a;
}
const Oq = ({ children: n, custom: a, initial: s = !0, onExitComplete: c, exitBeforeEnter: p, presenceAffectsLayout: v = !0, mode: h = "sync" }) => {
  xo(!p, "Replace exitBeforeEnter with mode='wait'");
  const b = ar(pT).forceRender || Tq()[0], x = uP(), E = Mq(n);
  let w = E;
  const k = ga(/* @__PURE__ */ new Map()).current, _ = ga(w), A = ga(/* @__PURE__ */ new Map()).current, L = ga(!0);
  if (lT(() => {
    L.current = !1, Aq(E, A), _.current = w;
  }), Dq(() => {
    L.current = !0, A.clear(), k.clear();
  }), L.current)
    return kt.createElement(kt.Fragment, null, w.map((W) => kt.createElement(KE, { key: Rf(W), isPresent: !0, initial: s ? void 0 : !1, presenceAffectsLayout: v, mode: h }, W)));
  w = [...w];
  const $ = _.current.map(Rf), Y = E.map(Rf), K = $.length;
  for (let W = 0; W < K; W++) {
    const F = $[W];
    Y.indexOf(F) === -1 && !k.has(F) && k.set(F, void 0);
  }
  return h === "wait" && k.size && (w = []), k.forEach((W, F) => {
    if (Y.indexOf(F) !== -1)
      return;
    const ne = A.get(F);
    if (!ne)
      return;
    const H = $.indexOf(F);
    let le = W;
    if (!le) {
      const re = () => {
        k.delete(F);
        const De = Array.from(A.keys()).filter((Fe) => !Y.includes(Fe));
        if (De.forEach((Fe) => A.delete(Fe)), _.current = E.filter((Fe) => {
          const ot = Rf(Fe);
          return (
            // filter out the node exiting
            ot === F || // filter out the leftover children
            De.includes(ot)
          );
        }), !k.size) {
          if (x.current === !1)
            return;
          b(), c && c();
        }
      };
      le = kt.createElement(KE, { key: Rf(ne), isPresent: !1, onExitComplete: re, custom: a, presenceAffectsLayout: v, mode: h }, ne), k.set(F, le);
    }
    w.splice(H, 0, le);
  }), w = w.map((W) => {
    const F = W.key;
    return k.has(F) ? W : kt.createElement(KE, { key: Rf(W), isPresent: !0, presenceAffectsLayout: v, mode: h }, W);
  }), process.env.NODE_ENV !== "production" && h === "wait" && w.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), kt.createElement(kt.Fragment, null, k.size ? w : w.map((W) => a4(W)));
};
var zq = {
  initial: (n) => {
    const { position: a } = n, s = ["top", "bottom"].includes(a) ? "y" : "x";
    let c = ["top-right", "bottom-right"].includes(a) ? 1 : -1;
    return a === "bottom" && (c = 1), {
      opacity: 0,
      [s]: c * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
}, cP = s4((n) => {
  const {
    id: a,
    message: s,
    onCloseComplete: c,
    onRequestRemove: p,
    requestClose: v = !1,
    position: h = "bottom",
    duration: b = 5e3,
    containerStyle: x,
    motionVariants: E = zq,
    toastSpacing: w = "0.5rem"
  } = n, [k, _] = jf(b), A = mG();
  X2(() => {
    A || c == null || c();
  }, [A]), X2(() => {
    _(b);
  }, [b]);
  const L = () => _(null), $ = () => _(b), Y = () => {
    A && p();
  };
  Qi(() => {
    A && v && p();
  }, [A, v, p]), h7(Y, k);
  const K = Ki(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: w,
      ...x
    }),
    [x, w]
  ), W = Ki(() => f7(h), [h]);
  return /* @__PURE__ */ Oe.jsx(
    wq.div,
    {
      layout: !0,
      className: "chakra-toast",
      variants: E,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: L,
      onHoverEnd: $,
      custom: { position: h },
      style: W,
      children: /* @__PURE__ */ Oe.jsx(
        os.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: K,
          children: cc(s, { id: a, onClose: Y })
        }
      )
    }
  );
});
cP.displayName = "ToastComponent";
var aM = {
  path: /* @__PURE__ */ Oe.jsxs("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ Oe.jsx(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ Oe.jsx(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ Oe.jsx("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
}, by = mh((n, a) => {
  const {
    as: s,
    viewBox: c,
    color: p = "currentColor",
    focusable: v = !1,
    children: h,
    className: b,
    __css: x,
    ...E
  } = n, w = hh("chakra-icon", b), k = sT("Icon", n), _ = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: p,
    ...x,
    ...k
  }, A = {
    ref: a,
    focusable: v,
    className: w,
    __css: _
  }, L = c ?? aM.viewBox;
  if (s && typeof s != "string")
    return /* @__PURE__ */ Oe.jsx(os.svg, { as: s, ...A, ...E });
  const $ = h ?? aM.path;
  return /* @__PURE__ */ Oe.jsx(os.svg, { verticalAlign: "middle", viewBox: L, ...A, ...E, children: $ });
});
by.displayName = "Icon";
function Pq(n) {
  return /* @__PURE__ */ Oe.jsx(by, { viewBox: "0 0 24 24", ...n, children: /* @__PURE__ */ Oe.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function Lq(n) {
  return /* @__PURE__ */ Oe.jsx(by, { viewBox: "0 0 24 24", ...n, children: /* @__PURE__ */ Oe.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function iM(n) {
  return /* @__PURE__ */ Oe.jsx(by, { viewBox: "0 0 24 24", ...n, children: /* @__PURE__ */ Oe.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}
var $q = XM({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
}), fP = mh((n, a) => {
  const s = sT("Spinner", n), {
    label: c = "Loading...",
    thickness: p = "2px",
    speed: v = "0.45s",
    emptyColor: h = "transparent",
    className: b,
    ...x
  } = tT(n), E = hh("chakra-spinner", b), w = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: p,
    borderBottomColor: h,
    borderLeftColor: h,
    animation: `${$q} ${v} linear infinite`,
    ...s
  };
  return /* @__PURE__ */ Oe.jsx(
    os.div,
    {
      ref: a,
      __css: w,
      className: E,
      ...x,
      children: c && /* @__PURE__ */ Oe.jsx(os.span, { srOnly: !0, children: c })
    }
  );
});
fP.displayName = "Spinner";
var [Nq, MT] = fy({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
}), [Fq, OT] = fy({
  name: "AlertStylesContext",
  hookName: "useAlertStyles",
  providerName: "<Alert />"
}), dP = {
  info: { icon: Lq, colorScheme: "blue" },
  warning: { icon: iM, colorScheme: "orange" },
  success: { icon: Pq, colorScheme: "green" },
  error: { icon: iM, colorScheme: "red" },
  loading: { icon: fP, colorScheme: "blue" }
};
function Vq(n) {
  return dP[n].colorScheme;
}
function jq(n) {
  return dP[n].icon;
}
var pP = mh(
  function(a, s) {
    const c = OT(), { status: p } = MT(), v = {
      display: "inline",
      ...c.description
    };
    return /* @__PURE__ */ Oe.jsx(
      os.div,
      {
        ref: s,
        "data-status": p,
        ...a,
        className: hh("chakra-alert__desc", a.className),
        __css: v
      }
    );
  }
);
pP.displayName = "AlertDescription";
function hP(n) {
  const { status: a } = MT(), s = jq(a), c = OT(), p = a === "loading" ? c.spinner : c.icon;
  return /* @__PURE__ */ Oe.jsx(
    os.span,
    {
      display: "inherit",
      "data-status": a,
      ...n,
      className: hh("chakra-alert__icon", n.className),
      __css: p,
      children: n.children || /* @__PURE__ */ Oe.jsx(s, { h: "100%", w: "100%" })
    }
  );
}
hP.displayName = "AlertIcon";
var mP = mh(
  function(a, s) {
    const c = OT(), { status: p } = MT();
    return /* @__PURE__ */ Oe.jsx(
      os.div,
      {
        ref: s,
        "data-status": p,
        ...a,
        className: hh("chakra-alert__title", a.className),
        __css: c.title
      }
    );
  }
);
mP.displayName = "AlertTitle";
var vP = mh(function(a, s) {
  var c;
  const { status: p = "info", addRole: v = !0, ...h } = tT(a), b = (c = a.colorScheme) != null ? c : Vq(p), x = YH("Alert", { ...a, colorScheme: b }), E = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...x.container
  };
  return /* @__PURE__ */ Oe.jsx(Nq, { value: { status: p }, children: /* @__PURE__ */ Oe.jsx(Fq, { value: x, children: /* @__PURE__ */ Oe.jsx(
    os.div,
    {
      "data-status": p,
      role: v ? "alert" : void 0,
      ref: s,
      ...h,
      className: hh("chakra-alert", a.className),
      __css: E
    }
  ) }) });
});
vP.displayName = "Alert";
function Bq(n) {
  return /* @__PURE__ */ Oe.jsx(by, { focusable: "false", "aria-hidden": !0, ...n, children: /* @__PURE__ */ Oe.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
var yP = mh(
  function(a, s) {
    const c = sT("CloseButton", a), { children: p, isDisabled: v, __css: h, ...b } = tT(a), x = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ Oe.jsx(
      os.button,
      {
        type: "button",
        "aria-label": "Close",
        ref: s,
        disabled: v,
        __css: {
          ...x,
          ...c,
          ...h
        },
        ...b,
        children: p || /* @__PURE__ */ Oe.jsx(Bq, { width: "1em", height: "1em" })
      }
    );
  }
);
yP.displayName = "CloseButton";
var Uq = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
}, Zv = Iq(Uq);
function Iq(n) {
  let a = n;
  const s = /* @__PURE__ */ new Set(), c = (p) => {
    a = p(a), s.forEach((v) => v());
  };
  return {
    getState: () => a,
    subscribe: (p) => (s.add(p), () => {
      c(() => n), s.delete(p);
    }),
    /**
     * Delete a toast record at its position
     */
    removeToast: (p, v) => {
      c((h) => ({
        ...h,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [v]: h[v].filter((b) => b.id != p)
      }));
    },
    notify: (p, v) => {
      const h = Hq(p, v), { position: b, id: x } = h;
      return c((E) => {
        var w, k;
        const A = b.includes("top") ? [h, ...(w = E[b]) != null ? w : []] : [...(k = E[b]) != null ? k : [], h];
        return {
          ...E,
          [b]: A
        };
      }), x;
    },
    update: (p, v) => {
      p && c((h) => {
        const b = { ...h }, { position: x, index: E } = K2(b, p);
        return x && E !== -1 && (b[x][E] = {
          ...b[x][E],
          ...v,
          message: Yq(v)
        }), b;
      });
    },
    closeAll: ({ positions: p } = {}) => {
      c((v) => (p ?? [
        "bottom",
        "bottom-right",
        "bottom-left",
        "top",
        "top-left",
        "top-right"
      ]).reduce(
        (x, E) => (x[E] = v[E].map((w) => ({
          ...w,
          requestClose: !0
        })), x),
        { ...v }
      ));
    },
    close: (p) => {
      c((v) => {
        const h = VO(v, p);
        return h ? {
          ...v,
          [h]: v[h].map((b) => b.id == p ? {
            ...b,
            requestClose: !0
          } : b)
        } : v;
      });
    },
    isActive: (p) => !!K2(Zv.getState(), p).position
  };
}
var oM = 0;
function Hq(n, a = {}) {
  var s, c;
  oM += 1;
  const p = (s = a.id) != null ? s : oM, v = (c = a.position) != null ? c : "bottom";
  return {
    id: p,
    message: n,
    position: v,
    duration: a.duration,
    onCloseComplete: a.onCloseComplete,
    onRequestRemove: () => Zv.removeToast(String(p), v),
    status: a.status,
    requestClose: !1,
    containerStyle: a.containerStyle
  };
}
var Wq = (n) => {
  const {
    status: a,
    variant: s = "solid",
    id: c,
    title: p,
    isClosable: v,
    onClose: h,
    description: b,
    colorScheme: x,
    icon: E
  } = n, w = c ? {
    root: `toast-${c}`,
    title: `toast-${c}-title`,
    description: `toast-${c}-description`
  } : void 0;
  return /* @__PURE__ */ Oe.jsxs(
    vP,
    {
      addRole: !1,
      status: a,
      variant: s,
      id: w == null ? void 0 : w.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme: x,
      children: [
        /* @__PURE__ */ Oe.jsx(hP, { children: E }),
        /* @__PURE__ */ Oe.jsxs(os.div, { flex: "1", maxWidth: "100%", children: [
          p && /* @__PURE__ */ Oe.jsx(mP, { id: w == null ? void 0 : w.title, children: p }),
          b && /* @__PURE__ */ Oe.jsx(pP, { id: w == null ? void 0 : w.description, display: "block", children: b })
        ] }),
        v && /* @__PURE__ */ Oe.jsx(
          yP,
          {
            size: "sm",
            onClick: h,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function Yq(n = {}) {
  const { render: a, toastComponent: s = Wq } = n;
  return (p) => typeof a == "function" ? a({ ...p, ...n }) : /* @__PURE__ */ Oe.jsx(s, { ...p, ...n });
}
var [Gq, lQ] = fy({
  name: "ToastOptionsContext",
  strict: !1
}), qq = (n) => {
  const a = l4(
    Zv.subscribe,
    Zv.getState,
    Zv.getState
  ), {
    motionVariants: s,
    component: c = cP,
    portalProps: p
  } = n, h = Object.keys(a).map((b) => {
    const x = a[b];
    return /* @__PURE__ */ Oe.jsx(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${b}`,
        id: `chakra-toast-manager-${b}`,
        style: d7(b),
        children: /* @__PURE__ */ Oe.jsx(Oq, { initial: !1, children: x.map((E) => /* @__PURE__ */ Oe.jsx(
          c,
          {
            motionVariants: s,
            ...E
          },
          E.id
        )) })
      },
      b
    );
  });
  return /* @__PURE__ */ Oe.jsx(_S, { ...p, children: h });
}, Qq = (n) => function({
  children: s,
  theme: c = n,
  toastOptions: p,
  ...v
}) {
  return /* @__PURE__ */ Oe.jsxs(u7, { theme: c, ...v, children: [
    /* @__PURE__ */ Oe.jsx(Gq, { value: p == null ? void 0 : p.defaultOptions, children: s }),
    /* @__PURE__ */ Oe.jsx(qq, { ...p })
  ] });
}, Kq = Qq(AH);
const Xq = {
  "3.5": "0.875rem",
  // 16px
  "4.5": "1.125rem",
  // 18px
  7: "1.75rem"
  // 28px
}, Zq = {
  config: {
    initialColorMode: "light",
    useSystemColorMode: !1
  },
  breakpoints: AV,
  colors: kV,
  fonts: _V,
  fontSizes: DV,
  shadows: RV,
  components: {},
  lineHeights: Xq
}, Jq = PH(Zq), uQ = ({
  children: n
}) => /* @__PURE__ */ Oe.jsx(Kq, { theme: Jq, children: n });
export {
  aQ as Button,
  uQ as ThemeProvider,
  AV as breakpoints,
  kV as colors,
  DV as fontSizes,
  _V as fonts,
  iQ as loadingAnimation,
  RV as shadows,
  Jq as theme,
  Zq as themeOverrides
};
//# sourceMappingURL=index.es.js.map
